[{"content":"최근 우연히 한빛미디어에서 제공하는 혼공학습단(링크) 모집 공고를 보게 되었는데, 흥미로워서 신청하게 되었습니다.\n그 동안 실무에서 백엔드, 프론트엔드, 데브옵스, WPF 등 정말 다양한 분야를 경험해봤는데, 머신러닝과 딥러닝은 경험하기가 쉽지 않은 것 같더라구요.\n그래서 한번 경험해보고 싶다는 생각이 들어 신청하게 되었습니다.\n아래 커리큘럼에 따라 6주 만에 책 한 권을 완주해야 합니다.\n음.. 아무래도 강제적으로 실습 내용을 블로그에 정리해야 하기 때문에, 잘 따라가기만 하면 6주 만에 책 한 권을 완독할 수 있다는 장점이 있습니다.\n그럼 바로 시작해보겠습니다!\n내용 정리 지도 학습: 정답(타깃)이 있으니 알고리즘이 정답을 맞히는 것을 학습 비지도 학습: 알고리즘은 타깃 없이 입력 데이터만 사용하며, 이런 종류의 알고리즘은 정답을 사용하지 않으므로 무언가를 맞힐 수가 없음. 대신 데이터를 잘 파악하거나 변형하는데 도움을 줌 강화 학습: 타깃이 아니라 알고리즘이 행동한 결과로 얻은 보상을 사용해 학습(이 책에서는 다루지 않음..) 실습내용 Chapter01 간단하게 데이터를 차트로 표시하는 것 같네요.\nmatplotlib 라이브러리를 통해 데이터를 시각화해서 볼 수 있습니다.\n생선의 길이와 무게를 하나의 배열을 가진 2차원 리스트 생성합니다.\n이밖에도 참고데이터를 판단하는 라이브러리로 새로운 데이터가 도미인지 빙어인지 맞출 수 있는 실습을 진행합니다.\nChapter02 훈련 세트와 테스트 세트에 대해 학습합니다.\n샘플링 편향을 없애기 위해 훈련 세트와 테스트 세트에 모두 도미와 빙어 정보를 넣는 작업을 실습합니다.\n넘파이를 활용하여 샘플링 편향이 발생하지 않은 학습 데이터를 생성합니다.\nKNeighborsClassifier 클래스는 주어진 샘플에서 가장 가까운 5개의 이웃을 반환하는데 해당 데이터에서는 빙어가 더 많이 검출돼서 빙어(0)로 결과를 예측합니다.\n위와 같이 빙어가 4개 더 많이 걸립니다. 위와 같이 데이터를 표현하는 기준이 다른 경우는 알고리즘이 올바르게 예측할 수 없습니다. 데이터 전처리가 필요합니다.\n분산은 데이터에서 평균을 뺀 값을 모두 제곱한 다음 평균을 내어 구합니다.\n표준편차는 분산의 제곱근으로 데이터가 분산된 정도를 나타냅니다.\n표준점수는 각 데이터가 원점에서 몇 표준편차만큼 떨어져 있는지를 나타내는 값입니다.\n위와 같이 데이터 전처리를 거치면 샘플 값의 정보를 제대로 알 수 있습니다.\n순서대로 하니 큰 문제 없이 챕터 2장까지는 해결할 수 있었네요..!\n","permalink":"https://haservi.github.io/posts/books/hg-mldl/week-1/","summary":"혼자 공부하는 머신러닝+딥러닝 1주차 학습 내용","title":"[혼공머신] 1주차 학습 내용"},{"content":"윈도우에서는 PowerToys 프로그램을 이용하면 파일들의 이름을 쉽게 일괄 변경할 수 있습니다.\nMac에서도 비슷한 기능을 찾아보니, 기본 Finder 기능과 Automator를 이용한 두 가지 방법으로 파일 이름을 일괄 변경할 수 있더군요.\n1. Finder를 이용한 기본적인 파일 이름 변경 가장 간단한 방법은 Finder를 이용하는 것입니다.\n위와 같이 이미지를 선택한 후 우클릭하여 \u0026lsquo;Rename\u0026hellip;\u0026lsquo;을 선택하면 아래와 같은 이름 변경 창이 나타납니다.\n이 방법을 사용하면 선택한 파일들이 다음과 같이 자동으로 이름이 변경됩니다.\nimage1.png image2.png image3.png \u0026hellip; 2. Automator를 이용한 고급 파일 이름 변경 만약 파일 이름을 \u0026lsquo;image01.png\u0026rsquo;, \u0026lsquo;image02.png\u0026rsquo;와 같이 두 자리 숫자로 변경하고 싶다면, Automator를 사용해야 합니다.\nAutomator 실행 방법 Spotlight 검색(Command + Space)에서 \u0026lsquo;Automator\u0026rsquo;를 검색하여 실행합니다. \u0026lsquo;Rename Finder Items\u0026rsquo;를 추가하면 두 개의 항목이 나타납니다. 위 항목: 변경할 파일 목록 아래 항목: 이름 변경 방식 선택 이름 변경 설정 \u0026lsquo;Make Sequential\u0026rsquo; 설정을 사용하여 이름을 커스터마이즈할 수 있습니다.\n이름 형식: \u0026rsquo;new-image 01.xxx\u0026rsquo; 숫자 위치: 이름 끝에 추가 결과: 파일들이 순서대로 변경 위의 설정 후 오른쪽 위의 재생 버튼을 누르면 자동으로 파일 이름이 변경됩니다.\n이 방법을 사용하면 파일 이름을 더 손쉽게 관리할 수 있습니다. 특히 많은 수의 이미지 파일을 정리할 때 유용합니다.\n","permalink":"https://haservi.github.io/posts/tips/mac-imagefile-renames/","summary":"Mac에서 이미지 파일 이름을 일괄적으로 변경하는 두 가지 방법","title":"Mac에서 이미지 파일 이름 일괄 변경하는 방법"},{"content":"맥에서 개발을 하다 보면 5000번 포트 충돌 문제를 자주 마주하게 됩니다. 이는 여러 개발 도구와 프레임워크가 기본적으로 5000번 포트를 사용하기 때문입니다.\n5000번 포트를 사용하는 주요 애플리케이션 Logstash: ELK 스택의 데이터 수집 도구 Flask: Python 웹 프레임워크 (기본 포트: 5000) AirPlay Receiver: 맥의 기본 기능 문제 상황 제 경우는 Docker를 이용해 ELK 스택을 사용하던 중 Logstash가 동작하지 않는 문제가 발생했습니다.\n문제의 원인을 찾아보니, Logstash가 기본적으로 5000번 포트를 사용하는데, Mac에서는 AirPlay Receiver가 기본적으로 5000번 포트를 점유하기 때문이었습니다. 처음에는 Docker 네트워크 설정을 변경해보기도 했지만, 결국 이는 Mac의 시스템 설정 문제였습니다.\n포트 충돌을 확인하기 위해 다음 명령어를 사용할 수 있습니다.\n1 lsof -i :5000 이 명령어를 실행하면 5000번 포트를 사용 중인 프로세스를 확인할 수 있습니다.\n해결 방법 계속해서 포트가 점유되는 문제를 해결하기 위해서는 시스템 설정에서 AirPlay Receiver를 비활성화해야 합니다. 다음과 같은 단계로 진행할 수 있습니다.\n시스템 설정(Settings)을 열기 일반(General) 탭 선택 AirPlay \u0026amp; Handoff 설정으로 이동 AirPlay Receiver를 비활성화 대체 해결 방법 만약 AirPlay Receiver를 비활성화하기 어려운 상황이라면, 다음과 같은 대체 방법들을 사용할 수 있습니다.\n애플리케이션 포트 변경\nFlask의 경우: app.run(port=5001)로 포트 변경 Logstash의 경우: 설정 파일에서 http.port 값 변경 다른 포트 사용\n개발 서버를 3000, 8000, 8080 등의 다른 포트로 실행 예: flask run --port=5001 포트 포워딩 사용\n로컬에서 다른 포트로 실행하고, 필요한 경우 포트 포워딩 설정 추가 정보 이 설정을 변경한 후에는 Mac을 재시작할 필요가 없습니다. AirPlay Receiver를 비활성화해도 다른 AirPlay 기능(예: iPhone에서 Mac으로 화면 미러링)은 계속 사용할 수 있습니다. 개발 환경에서는 가능한 5000번 포트를 피하고, 다른 포트를 사용하는 것이 좋습니다. 이렇게 설정을 변경하면 5000번 포트가 해제되어 애플리케이션이 정상적으로 동작할 수 있습니다.\n","permalink":"https://haservi.github.io/posts/tips/mac-5000-port-disable/","summary":"Mac에서 5000번 포트 충돌 문제 해결 방법","title":"Mac에서 5000번 포트 사용 해제하기"},{"content":"Mac에서 잠자기 모드 해제하기 최근 Mac mini m4로 변경하면서 컴퓨터 셋팅을 다시하고 있습니다..\n맥북이나 Mac mini를 사용하다 보면 일정 시간 동안 사용하지 않으면 자동으로 잠자기 모드로 전환되는 경우가 있습니다. 이는 배터리 절약과 시스템 보호에 도움이 되지만, 때로는 컴퓨터가 계속 켜져 있길 원하는 상황이 있습니다.\n예를 들어, 장시간 다운로드를 실행하거나 서버를 운영할 때 컴퓨터가 잠자기 모드로 들어가지 않도록 설정해야 할 필요가 있습니다.\nMac의 시스템 환경설정을 통해서도 이런 설정을 변경할 수 있지만, 터미널 명령어를 사용하면 더 세밀하게 제어할 수 있습니다.\n이 글에서는 터미널을 이용해 Mac의 잠자기 모드를 해제하는 방법을 알아보겠습니다.\n터미널을 이용한 잠자기 모드 해제 방법 1. 터미널 열기 먼저 터미널 앱을 실행합니다.\nFinder에서 \u0026ldquo;응용 프로그램\u0026rdquo; \u0026gt; \u0026ldquo;유틸리티\u0026rdquo; \u0026gt; \u0026ldquo;터미널\u0026quot;을 엽니다. 또는 Spotlight(⌘ + Space)에서 \u0026ldquo;터미널\u0026quot;을 검색하여 실행할 수 있습니다. 2. 잠자기 모드 해제 명령어 터미널에서 다음 명령어들을 사용하여 다양한 잠자기 설정을 제어할 수 있습니다.\n시스템 잠자기 모드 해제 Mac이 절대 잠자기 모드로 들어가지 않게 하려면 다음 명령을 실행합니다.\n1 sudo pmset -a sleep 0 디스플레이 잠자기 모드 해제 화면 디스플레이만 잠자기 모드로 들어가지 않게 하려면 다음 명령을 실행합니다.\n1 sudo pmset -a displaysleep 0 디스크 잠자기 모드 해제 하드 디스크가 잠자기 모드로 들어가지 않게 하려면 다음 명령을 실행합니다.\n1 sudo pmset -a disksleep 0 3. 설정 확인하기 위 명령어로 설정을 변경한 후, 현재 잠자기 모드 설정을 확인하려면 다음 명령어를 사용할 수 있습니다.\n1 sudo systemsetup -getsleep 또한 모든 전원 관리 설정을 자세히 보려면 다음 명령어를 입력합니다\n1 pmset -g 설정이 올바르게 적용되었다면 아래와 같이 모든 항목이 \u0026lsquo;0\u0026rsquo; 또는 \u0026lsquo;Never\u0026rsquo;로 표시됩니다.\n원래 설정으로 되돌리기 나중에 원래 설정으로 돌아가고 싶다면, 다음 명령어를 사용하여 기본 설정으로 복원할 수 있습니다\n1 2 3 sudo pmset -a sleep 1 sudo pmset -a displaysleep 10 sudo pmset -a disksleep 10 위 숫자는 각각 설정할 시간(분)을 의미합니다. 필요에 따라 원하는 시간으로 조정할 수 있습니다.\n이 방법을 통해 Mac이 절대 잠자기 모드로 들어가지 않도록 설정할 수 있습니다.\n장시간 작업을 실행하거나 서버 운영 등의 용도로 매우 유용하게 활용할 수 있습니다.\n","permalink":"https://haservi.github.io/posts/tips/mac-wake-sleepmode/","summary":"Mac에서 터미널 명령어를 사용하여 잠자기 모드를 해제하는 방법","title":"Mac에서 터미널로 잠자기 모드 해제하는 방법"},{"content":"맥북과 윈도우를 함께 사용하다 보면 Ctrl과 Command 키 배열이 달라 불편할 때가 많습니다.\n많은 블로그에서는 Karabiner를 활용해 키 설정을 변경하는 방법을 소개하지만, 외부 키보드마다 설정을 변경하는 것보다는 맥북 내부 키보드 자체를 조정하는 것이 더 효율적입니다.\n이렇게 설정해 두면 키보드를 자주 바꿔 사용할 때마다 별도로 변경할 필요 없이 편리하게 사용할 수 있습니다.\n우선 Karabiner-Elements를 다운로드 합니다.\n우선 맥북 기본 키보드는 위와 같이 설정합니다.\n그리고 모든 키보드 설정은 위와 같이 설정하면 됩니다.\n키보드 설정에서 한영키를 커맨드로 변경하도록 설정합니다.\n내부 키보드 function 키도 외부 키보드와 동일하게 동작하도록 변경합니다.\nSpotlight는 비활성화(RayCast 툴로 대체) Finder는 단축키로 열 수 있도록 설정합니다.\n이렇게 하면 키보드를 바꿔 사용해도 더 이상 설정(맥북 전용 키보드 사용 시 내부 키보드 같이 설정 필요..)을 할 필요가 없습니다.\n그 외 다른 프로그램 추천 해당 프로그램 이외에 mac에서 이용하면 좋은 프로그램은 아래와 같습니다.\nSnipaste(mac, window, linux) 사이트 링크 캡쳐 프로그램으로 가볍게 캡쳐하고 삭제가 가능(윈도우, 맥, 리눅스 모두 가능), 리뷰 Raycast(mac) 사이트 링크 단축키를 활용하여 생산성 향상 프로그램, 리뷰 Karabiner-Elements(mac) 사이트 링크 karabiner 프로그램으로 맥북 키보드 설정, 리뷰 Rectangle(mac) 사이트 링크 프로그램 화면 크기 조절 프로그램, 리뷰 Logitech Options(mac) 사이트 링크 Logitech 제품 마우스 커스텀 프로그램, 리뷰 Dbeaver(mac, window) 사이트 링크 DB 접근 제어 프로그램 일부 커스텀 방법, 리뷰 ScreeToGif(mac, window) 사이트 링크 간단하게 화면을 gif로 만드는 프로그램 소개, 리뷰 ","permalink":"https://haservi.github.io/posts/tools/how-to-mac-key-setting/","summary":"맥북과 윈도우를 함께 사용하다 보면 Ctrl과 Command 키 배열이 달라 불편할 때가 많습니다.\n많은 블로그에서는 Karabiner를 활용해 키 설정을 변경하는 방법을 소개하지만, 외부 키보드마다 설정을 변경하는 것보다는 맥북 내부 키보드 자체를 조정하는 것이 더 효율적입니다.\n이렇게 설정해 두면 키보드를 자주 바꿔 사용할 때마다 별도로 변경할 필요 없이 편리하게 사용할 수 있습니다.\n우선 Karabiner-Elements를 다운로드 합니다.\n우선 맥북 기본 키보드는 위와 같이 설정합니다.\n그리고 모든 키보드 설정은 위와 같이 설정하면 됩니다.","title":"맥북 외부 키보드 Ctrl와 Command 키 바꿔 사용하기"},{"content":"C# WPF 프로젝트를 진행하면서 간단하게 코드 컨벤션과 코드 정렬을 하는 방법에 대해 알아보겠습니다.\n협업을 하는 경우 코드스타일이 이왕이면 일관된 것을 선호하는 편입니다.\n코드 컨벤션 공식 문서 에서 전반적으로 코딩 규칙에 대해 작성돼 있습니다.\n코드 컨벤션은 위의 문서를 읽어보면 도움이 될 것이라 생각됩니다.\n이번에 작성할 내용은 간단하게 포맷을 정렬하여 팀에서 코드 정렬과 관련한 스타일을 통일시키는 방법에 대해 알아보겠습니다.\nCode Formatting 코드 정렬은 2개의 설정만 바꿔주면 됩니다. 생각보다 간단하기에 이렇게 쓰면 좋습니다.\ncs 파일 formatting 코드를 일관성 있게 작성하는 것은 중요합니다. cs 파일의 경우 단축키(ctrl + k, ctrl + d)를 이용해서 파일을 수정할 수도 있지만 아래와 같은 방법을 사용하는 것을 추천드립니다.\n환경설정의 옵션(Tools -\u0026gt; Options)에서 아래와 같이 설정해주면 됩니다.\n위와 같이 설정을 하면 코드 정렬을 할 수 있습니다.\n정보\n위의 cs 파일 설정은 Visual Studio 2022 이상부터 지원하는 것 같아요. :(\nxaml 파일 formatting xaml 파일을 설정을 통해서도 정렬을 할 수 있지만 각 설정마다 아래와 같이 포맷이 다른 경우가 있습니다.\n그러니.. 확장 프로그램에서 플러그인을 설치하는 것을 추천드립니다.\n해당 플러그인을 설치하면 코드 정렬을 자동으로 할 수 있습니다.\nWPF로 작업할 때 위 2가지 설정만 해 놓으면 큰 문제 없이 코드 정렬 및 포맷에 대한 고민을 줄일 수 있습니다.\n번외 1(Settings.XamlStyler) XAML Styler 플러그인도 어느 정도 한계가 있습니다.\n그것을 해결하기 위해서 위의 플러그인을 설치하고 프로젝트 최상단에 Settings.XamlStyler로 파일명을 추가한 후 아래와 같이 추가 커스텀을 할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 { \u0026#34;AttributesTolerance\u0026#34;: 2, \u0026#34;KeepFirstAttributeOnSameLine\u0026#34;: false, \u0026#34;MaxAttributeCharactersPerLine\u0026#34;: 0, \u0026#34;MaxAttributesPerLine\u0026#34;: 1, \u0026#34;NewlineExemptionElements\u0026#34;: \u0026#34;RadialGradientBrush, GradientStop, LinearGradientBrush, ScaleTransform, SkewTransform, RotateTransform, TranslateTransform, Trigger, Condition, Setter\u0026#34;, \u0026#34;SeparateByGroups\u0026#34;: false, \u0026#34;AttributeIndentation\u0026#34;: 0, \u0026#34;AttributeIndentationStyle\u0026#34;: 1, \u0026#34;RemoveDesignTimeReferences\u0026#34;: false, \u0026#34;IgnoreDesignTimeReferencePrefix\u0026#34;: false, \u0026#34;OrderAttributesByName\u0026#34;: true, \u0026#34;EnableAttributeReordering\u0026#34;: true, \u0026#34;AttributeOrderingRuleGroups\u0026#34;: [ \u0026#34;x:Class\u0026#34;, \u0026#34;xmlns, xmlns:x\u0026#34;, \u0026#34;xmlns:*\u0026#34;, \u0026#34;x:Key, Key, x:Name, Name, x:Uid, Uid, Title\u0026#34;, \u0026#34;Grid.Row, Grid.RowSpan, Grid.Column, Grid.ColumnSpan, Canvas.Left, Canvas.Top, Canvas.Right, Canvas.Bottom\u0026#34;, \u0026#34;Width, Height, MinWidth, MinHeight, MaxWidth, MaxHeight\u0026#34;, \u0026#34;Margin, Padding, HorizontalAlignment, VerticalAlignment, HorizontalContentAlignment, VerticalContentAlignment, Panel.ZIndex\u0026#34;, \u0026#34;*:*, *\u0026#34;, \u0026#34;PageSource, PageIndex, Offset, Color, TargetName, Property, Value, StartPoint, EndPoint\u0026#34;, \u0026#34;mc:Ignorable, d:IsDataSource, d:LayoutOverrides, d:IsStaticText\u0026#34;, \u0026#34;Storyboard.*, From, To, Duration\u0026#34; ], \u0026#34;FirstLineAttributes\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;PutEndingBracketOnNewLine\u0026#34;: false, \u0026#34;RemoveEndingTagOfEmptyElement\u0026#34;: true, \u0026#34;SpaceBeforeClosingSlash\u0026#34;: true, \u0026#34;RootElementLineBreakRule\u0026#34;: 0, \u0026#34;ReorderVSM\u0026#34;: 1, \u0026#34;ReorderGridChildren\u0026#34;: false, \u0026#34;ReorderCanvasChildren\u0026#34;: false, \u0026#34;ReorderSetters\u0026#34;: 3, \u0026#34;FormatMarkupExtension\u0026#34;: true, \u0026#34;NoNewLineMarkupExtensions\u0026#34;: \u0026#34;x:Bind, Binding\u0026#34;, \u0026#34;ThicknessSeparator\u0026#34;: 2, \u0026#34;ThicknessAttributes\u0026#34;: \u0026#34;Margin, Padding, BorderThickness, ThumbnailClipMargin\u0026#34;, \u0026#34;FormatOnSave\u0026#34;: true, \u0026#34;CommentPadding\u0026#34;: 2 } 제 경우에는 종종 스타일 지정할 때 \u0026lt;Setter Property=\u0026quot;FontSize\u0026quot; Value=\u0026quot;14\u0026quot; /\u0026gt; 이런식의 코드를 쓸 때가 있습니다.\n이 경우는 XAML Styler 기본 속성으로는 정렬을 할 수 없지만 아래와 같이 설정하면 ReorderSetters값을 3으로 지정하면 알파벳 순서로 자동 정렬이 됩니다.\n설정과 관련된 정보는 XAML Config 문서를 보면 아래와 같이 속성에 대한 설명이 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 AttributeIndentationStyle - Mixed = 0 - Spaces = 1 - RootElementLineBreakRule Default = 0 - Always = 1 - Never = 2 ReorderVSM - None = 0 - First = 1 - Last = 2 ReorderSetters - None = 0 - Property = 1 - TargetName = 2 - TargetNameThenProperty = 3 ThicknessSeparator - None = 0 - Space = 1 - Comma = 2 번외 2(.editorconfig) 위의 설정으로도 충분하지만 .editorconfig 파일을 통해 설정하는 방법입니다.\n.editorconfig는 코드 스타일 및 포맷팅 규칙을 프로젝트 내에서 정의하고 유지하도록 도와주는 구성 파일입니다.\nVisual Studio, Rider, VS Code 등 대부분의 IDE와 협력하여 일관된 코드 스타일을 유지할 수 있습니다.\n다양한 개발 환경에서 협업하는 경우, 여러 사람이 동일한 파일을 편집하더라도 코드 스타일이 일관되게 유지되도록 설정할 수 있습니다.\n.editorconfig 파일은 프로젝트 루트 디렉토리에 위치하며, 다음과 같은 내용을 추가하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 root = true [*.cs] # 들여쓰기 스타일: 공백 사용 indent_style = space # 들여쓰기 크기: 4칸 indent_size = 4 # 줄 끝 스타일: CRLF 사용 (Windows) end_of_line = crlf # 문자 인코딩: UTF-8 charset = utf-8 # 맨 끝에 공백 줄 추가 insert_final_newline = true [*] indent_size = 4 indent_style = space 위의 설정외에도 다른 여러 설정을 추가할 수 있습니다.\n.editorconfig를 지정하면 협업시 팀의 코드 스타일을 통일할 수 있습니다.\n제가 생각하기에는 cs 설정과 xaml styler 만 있어도 충분한 것 같습니다.\n참조 C# 코드 저장 시 자동 정렬 XAMLStyler XAMLStyler Configurations cover 출처 ","permalink":"https://haservi.github.io/posts/wpf/codiing-convention/","summary":"C# WPF 프로젝트를 진행하면서 간단하게 코드 컨벤션과 코드 정렬을 하는 방법에 대해 알아보겠습니다.\n협업을 하는 경우 코드스타일이 이왕이면 일관된 것을 선호하는 편입니다.\n코드 컨벤션 공식 문서 에서 전반적으로 코딩 규칙에 대해 작성돼 있습니다.\n코드 컨벤션은 위의 문서를 읽어보면 도움이 될 것이라 생각됩니다.\n이번에 작성할 내용은 간단하게 포맷을 정렬하여 팀에서 코드 정렬과 관련한 스타일을 통일시키는 방법에 대해 알아보겠습니다.\nCode Formatting 코드 정렬은 2개의 설정만 바꿔주면 됩니다. 생각보다 간단하기에 이렇게 쓰면 좋습니다.","title":"비쥬얼 스튜디오에서 C#, XAML 코드 자동정렬 방법"},{"content":"도커는 애플리케이션을 컨테이너화하여 개발, 배포 과정을 단순화하는 강력한 도구입니다.\n멀티 스테이지 빌드는 도커 이미지의 크기를 줄이고, 빌드 속도를 개선하는 데 유용한 기능입니다.\n도커파일만 이용할 경우에는 구조가 단순하며, 빠른 설정이 가능합니다. 하지만, 멀티스테이지 도커에 비해 이미지 크기가 크며, 중간 빌드 결과물(ex: 컴파일 도구, 라이브러리 등)이 모두 포함되므로 리소스 낭비가 발생할 수 있습니다.\n멀티스테이지 도커를 이용할 경우 아래와 같은 장점이 있습니다.\n이미지의 크기를 줄일 수 있음 개발 단계에서 사용된 도구나 라이브러리를 최종 이미지에서 제외함으로써 이미지의 크기를 최소화 보안을 강화 불필요한 소프트웨어가 최종 이미지에 포함되지 않기 때문에 공격 범위를 줄일 수 있음 빌드 속도를 향상시킬 수 있음 멀티 스테이지 빌드를 사용하면 필요한 단계만 실행하여 빌드 시간을 단축 위와 같은 장점이 있긴 하지만, 멀티스테이지 도커를 위한 커맨드를 작성하기 위해서 Dockerfile이 단계가 복잡할 수 있으며, 빌드에 필요한 단계별 설정이 필요하기 때문에 초기 설정 시간이 더 걸릴 수 있습니다.\n그렇지만 도커와 멀티스테이지도커의 이미지 크기가 최대 2~10배 정도까지 차이가 날 수 있습니다.\n아래는 vue frontend를 init을 Dockerfile.single과 Dockerfile.multi로 이미지를 만들때 이미지의 크기의 차이를 확인할 수 있습니다.\n실습을 하면 우선 vue quickstart에서 프로젝트를 생성 후 해당 폴더에 아래와 같이 Dockerfile들을 추가합니다.\nDockerfile.single Script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 FROM node:20.18-alpine WORKDIR /app # 의존성 파일 복사 및 설치 COPY package*.json ./ RUN npm install # 애플리케이션 소스 코드 복사 COPY . . # 빌드 RUN npm run build RUN npm install -g http-server EXPOSE 8080 CMD [ \u0026#34;http-server\u0026#34;, \u0026#34;dist\u0026#34; ] Dockerfile.multi Script 1 2 3 4 5 6 7 8 9 10 11 12 13 # build stage FROM node:20.18-alpine as build-stage WORKDIR /app COPY package*.json ./ RUN npm install COPY . . RUN npm run build # production stage FROM nginx:1.26-alpine as production-stage COPY --from=build-stage /app/dist /usr/share/nginx/html EXPOSE 80 CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon off;\u0026#34;] 정확히 속성들이 맞는지는 모르겠지만 일반 Docker에서는 node 이미지를 이용해 빌드 후 http-server로 배포한 것에 비해 멀티스테이지 Dockerfile에서는 node에서 build만 이용하고, 실제 배포된 파일을 nginx를 통해 배포하게 됩니다.\n이렇게 배포하니 이미지의 크기가 꽤 줄어든 것을 확인할 수 있습니다.\nDockerfile을 쉽게 배포하기 위해서 아래와 같이 docker-compose.yml 을 아래와 같이 설정하면 좋습니다.\ndocker-compose.yml Script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3\u0026#39; services: node-app-single: build: context: . dockerfile: Dockerfile.single ports: - \u0026#34;3000:8080\u0026#34; node-app-multi: build: context: . dockerfile: Dockerfile.multi ports: - \u0026#34;3001:80\u0026#34; 그리고 시작과 종료를 아래와 같이 하면 컨테이너와 이미지를 깔끔하게 정리할 수 있습니다.\n1 2 3 4 5 6 7 8 # 시작 docker-compose up # localhost:3000 -\u0026gt; 일반도커 # localhost:3001 -\u0026gt; 멀티스테이지빌드도커 # 종료 docker-compose down --rmi all 멀티스테이지빌드를 이용하면 MSA 환경에서 여러 이미지들이 배포될 때 이미지의 크기를 꽤 줄일 수 있으므로 용량 최적화에 좋을 것으로 생각됩니다.\n또한, .dockerginore을 이용하면 불필요한 파일을 이미지에 올리지 않을 수도 있습니다.\nGithub에서 예제 코드를 확인할 수 있습니다.\n","permalink":"https://haservi.github.io/posts/devops/docker/docker-multi-stage-build/","summary":"도커는 애플리케이션을 컨테이너화하여 개발, 배포 과정을 단순화하는 강력한 도구입니다.\n멀티 스테이지 빌드는 도커 이미지의 크기를 줄이고, 빌드 속도를 개선하는 데 유용한 기능입니다.\n도커파일만 이용할 경우에는 구조가 단순하며, 빠른 설정이 가능합니다. 하지만, 멀티스테이지 도커에 비해 이미지 크기가 크며, 중간 빌드 결과물(ex: 컴파일 도구, 라이브러리 등)이 모두 포함되므로 리소스 낭비가 발생할 수 있습니다.\n멀티스테이지 도커를 이용할 경우 아래와 같은 장점이 있습니다.\n이미지의 크기를 줄일 수 있음 개발 단계에서 사용된 도구나 라이브러리를 최종 이미지에서 제외함으로써 이미지의 크기를 최소화 보안을 강화 불필요한 소프트웨어가 최종 이미지에 포함되지 않기 때문에 공격 범위를 줄일 수 있음 빌드 속도를 향상시킬 수 있음 멀티 스테이지 빌드를 사용하면 필요한 단계만 실행하여 빌드 시간을 단축 위와 같은 장점이 있긴 하지만, 멀티스테이지 도커를 위한 커맨드를 작성하기 위해서 Dockerfile이 단계가 복잡할 수 있으며, 빌드에 필요한 단계별 설정이 필요하기 때문에 초기 설정 시간이 더 걸릴 수 있습니다.","title":"vue를 이용하여 도커와 멀티스테이지빌드 도커 차이 확인하기"},{"content":"Udemy에서 유료 강의(링크)를 학습하며, 필요한 내용을 정리한 저장소입니다.\n기존 소스 코드를 참고하며 학습한 내용을 정리했습니다.\n학습한 코드의 저장소는 해당 링크 입니다.\nUdemy는 잦은 주기로 90% 할인을 할 때가 많으니 그 때 구매하면 좋습니다.\n꽤 시간이 지난 후 다시 코드를 보면서 하나씩 봐보는데 역시 자주 안하면 기억을 못하네요.\n그래도 다시 코드를 들춰보고 큰 챕터별로 했었던 실습 예제 프로젝트를 정리해보겠습니다..!\n우선 하나씩 다시 실행해보고 동작하는지 확인해봤습니다. 시간이 꽤 지났지만 그래도 잘 동작(몇몇 설정은 config가 있어야 함)하네요.\n전체적으로 잘 따라할 수 있게 구성된 것 같았어요. 아래는 전체 강의에 대해 필요한 부분을 정리한 내용입니다.\n01. Roll Dice App 이미지를 여러개 넣어 놓고 랜덤으로 화면을 전환하는 앱입니다.\n구조가 간단하고 기본적인 플러터의 기능에 대해 학습할 수 있는 앱이라고 생각합니다.\n02. Quiz App 퀴즈 항목 샘플 데이터를 넣고 해당 값이 정답 유무를 확인하는 앱입니다.\n위의 앱과 내장 DB 또는 API를 활용하여 다양한 방법으로 활용할 수 있을 것으로 생각됩니다.\n03. expanded App 해당 앱은 가게부라기보다는 계산 또는 뭐.. 그런저런 기능을 체험하는 앱이라 생각합니다.\n04. Checkbox Radio App 기본적인 라디오 버튼과 체크박스 사용 방법에 대해 학습할 수 있습니다.\n05. Food Recipe App Riverpod에 대한 고민도 필요하고.. 순간 진입 장벽이 느껴졌습니다.\n전역 변수를 쉽게 관리하기 위한 방법인 것 같은데 이게 많이 쓰이는지는 모르겠지만 우선 좀 어렵네요.\nonWillPop 해당 기능이 deprecated 됐으며, PopScope 변경(\u0026lsquo;WillPopScope\u0026rsquo; is deprecated and shouldn\u0026rsquo;t be used. Use PopScope instead. This feature was deprecated after v3.12.0-1.0.pre)이 됐습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Widget build(BuildContext context) { return Scaffold( body: WillPopScope( onWillPop: () async { Navigator.of(context).pop({ Filter.glutenFree: _glutenFreeFilterSet, Filter.lactoseFree: _lactoseFreeFilterSet, Filter.vegetarian: _vegetarianFilterSet, Filter.vegan: _veganFilterSet, }); return false; }, child: Column( children: [ ], ), ), ); } 기존 코드를 위와 같은 형태 였다면 지금은 아래와 같이 해줘야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Widget build(BuildContext context) { return Scaffold( body: PopScope( canPop: false, onPopInvoked: (didPop) async { if (didPop) { return; } Navigator.of(context).pop({ Filter.glutenFree: _glutenFreeFilterSet, Filter.lactoseFree: _lactoseFreeFilterSet, Filter.vegetarian: _vegetarianFilterSet, Filter.vegan: _veganFilterSet, }); }, child: Column( children: [ ], ), ), ); } 위의 설정은 최근 flutter를 업데이트 하면서 발생한 이슈로 판단됩니다. 3.10을 쓰다가 3.20 올리면서 발생한 이슈라고 생각되네요.\n이와 관련된 이슈로 3.16 이전 버전의 Flutter는 Gradle의 선언적 플러그인 {} 블록을 쓰기 때문에 변경(문서 링크) 해야 합니다.\n학습 중 안드로이드 폰이 어느 순간 배포가 안돼서 삽질을 조금 했는데 문제의 원인은 C Type 케이블 불량이었습니다.\n계속 배포가 안돼서 apk를 만들어서 직접 올려보려다가 폰으로 업로드가 중간에 안돼서 혹시나 바꿔보니 잘 되던\u0026hellip; 혹시나 안되면 케이블 문제일 수 있습니다.\nRiverpod 상태 관리를 위해 하나의 상태를 모든 화면에서 끌고 들어가는 부분이 있는데 Reverpod를 쓰면 이러한 상태 관리를 조금 더 쉽게 할 수 있는 것 같습니다. 공식 문서를 읽어보면 좋을 거 같다 생각합니다.\n06. Shopping List App 드디어 Frontend와 Backend가 분리된 예제를 학습했습니다.\n기본적으로 항목을 추가하고 제거 하는 기존 강의에 Firebase를 이용하여 외부에서 데이터를 관리하는 앱을 만들 수 있습니다.\nfirebase에서 로그인 후 프로젝트 생성 후 데모 프로젝트로 Realtime Database를 만든 후 url을 해당 코드에서 assets/config/.env의 key 값만 변경 시 테스트 할 수 있습니다.\n정상적으로 동작하면 아래와 같이 항목을 추가 제거 할 수 있습니다.\n이번 강의에서는 Future를 사용하여 snapshot을 이용해 코드를 더욱 직관적으로 만들 수 있던 점이 아닐까 생각합니다.\n07. Place Save App 개인적인 생각으로 이 정도까지만 배우면 Flutter를 이용해서 간단한 App은 만들 수 있을 것이라 생각됩니다.\n해당 강의에서는 내부 DB(sqllite)를 이용해 DB의 정보를 저장하고 로드 시 불러오는 기능을 구현했습니다.\n실제로 구글 지도의 API를 지정하기 위해 각각의 android ios 폴더에 key 값을 저장(따로 confing로 분리)해서 해보니 나름 재밋었던 것 같네요.\n08. Chatting App Firebase 설정은 공식 문서를 참조하여 firebase 설정을 할 수 있습니다.\nFirebase에 로그인 상태에서 아래의 명령어를 입력하면 flutter firebase 설정을 할 수 있습니다.\n1 flutterfire configure 위와 같이 회원가입을 하면 Firebase에 저장되고 실제 데이터를 읽어와서 로그인 할 수 있습니다.\nchat 컬렉션안에는 여러 키리스트가 있고 그 값들을 이용해서 채팅 리스트 항목을 만드는 것 같습니다.\n그렇지만 위의 예제처럼 채팅 컬렉션에 다 넣으면 나중에 성능 이슈가 나올 것 같다고 생각되지만(아닐 수도..?), 예제를 통해 Flutter를 알기 쉽게 설명해주는 예제라 생각됩니다.\n","permalink":"https://haservi.github.io/posts/review/udemy-flutter/","summary":"Flutter 강의를 듣고 개인적으로 필요한 내용을 정리했습니다.","title":"[Udemy] Flutter \u0026 Dart 강의 리뷰"},{"content":"Android 개발 또는 Flutter 를 통한 개발 중에 실제 안드로이드 폰을 이용해 테스트 시를 할 경우 무선으로 연결하는 방법입니다.\n우선 USB가 없이 테스트를 할 수 있으니 조금 더 쾌적하게 개발을 할 수 있습니다?..\n설정 방법 우선 전제 조건으로 동일한 Wi_Fi를 이용해야 합니다.\n먼저 안드로이드 휴대폰을 개발자 모드로 활성화(설정 -\u0026gt; 시스템 -\u0026gt; 휴대전화 정보 -\u0026gt; 빌드 번호 연타)하고 개발자 옵션에서 USB 디버깅을 실행합니다.\n위와 같이 휴대폰에 나온 IP 주소 및 포트를 아래와 같은 형식으로 입력하면 됩니다.\n1 adb connect 172.30.1.15:44237 정상적으로 연결 됐다면 아래와 같이 입력해보면 연결된 것을 확인할 수 있습니다.\n1 adb devices 이 상태를 유지하기 위해 충전중인 경우에는 화면을 끄지 않는 설정도 해놓으면 조금 더 편하게 디버깅을 할 수 있습니다.\n알림\n만약 위와 같이 설정이 되지 않는 경우 유선으로 한번 휴대폰 디버깅 연결하면 정상적으로 될 수 있습니다.\n","permalink":"https://haservi.github.io/posts/tips/android-wireless-debug/","summary":"Android 무선 디버깅 하는 방법입니다.","title":"안드로이드 Wi-Fi 무선 디버깅 방법"},{"content":"몇몇 Git 저장소를 fork하여 참조할 때 또는 여러 컴퓨터에서 git을 이용해 작업을 진행할 때 이미 알고 있는 저장내역을 한번에 pull 하는 방법에 대해 알아보겠습니다.\nmac에서 사용 방법 아래와 같이 명령어를 입력하면 이용할 수 있습니다.\n1 find . -type d -name .git -print 2\u0026gt;/dev/null -exec git --git-dir={} --work-tree=$PWD/{}/.. pull \\; 만약 특정 함수를 지정하여 명령어로 이용하고 싶다면 ./zshrc 기준으로 아래와 같이 함수를 추가합니다.\n1 2 3 4 5 6 7 vim ~/.zshrc # 편집 function pull { find . -type d -name .git -print 2\u0026gt;/dev/null -exec git --git-dir={} --work-tree=$PWD/{}/.. pull \\; } source ~/.zshrc # 적용 실행하고 싶은 상단에서 해당 명령어를 입력하면 됩니다.\nwindow에서 사용 방법 아래의 압축파일을 다운로드하여 .bat 파일을 여러 git을 호출하고 싶은 위치의 상단에서 실행하면 됩니다.\npowershell 파일도 마찬가지로 상단에서 해당 파일을 powershell에서 실행할 수 있습니다.\n압축파일\n실행하면 아래와 같이 순차적으로 git pull을 할 수 있습니다..!\n.bat 스크립트 코드(feat. gpt)는 아래와 같습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @echo off setlocal enabledelayedexpansion :: 현재 디렉터리와 하위 디렉터리에서 .git 디렉터리를 찾습니다. for /f \u0026#34;delims=\u0026#34; %%i in (\u0026#39;dir /s /b /ad .git 2^\u0026gt;nul\u0026#39;) do ( set \u0026#34;repoPath=%%i\u0026#34; set \u0026#34;workTreePath=%%~dpi\u0026#34; set \u0026#34;workTreePath=!workTreePath:~0,-1!\u0026#34; echo Updating repository at !workTreePath! pushd !workTreePath! git pull popd ) endlocal pause .ps1 스크립트 코드는 아래와 같습니다.\n1 2 3 4 5 6 7 8 9 # 현재 디렉터리 및 하위 디렉터리에서 모든 .git 디렉터리를 찾음 $gitDirs = Get-ChildItem -Recurse -Directory -Force -Filter \u0026#34;.git\u0026#34; foreach ($gitDir in $gitDirs) { $repoPath = $gitDir.FullName $workTreePath = Split-Path $repoPath -Parent Write-Output \u0026#34;Updating repository at $workTreePath\u0026#34; git --git-dir=$repoPath --work-tree=$workTreePath pull } 참고 stack overflow Git) 여러개의 Git 저장소 한번에 fetch / pull ","permalink":"https://haservi.github.io/posts/tips/git-recursive-pull/","summary":"상위 폴더에서 여러 Git 저장소를 한번에 pull 하는 방법입니다.(window, mac)","title":"Git 상위 폴더에서 한번에 pull하기"},{"content":"최근 프로그래머스 Java 도서를 구매하여 매일 한 문제씩 풀기 시작했습니다.\n전반적으로 Level 1에서 Level 3까지의 문제들이 책에 나왔으며, 이 과정에서 문제 풀이 방법과 몇 가지 팁을 공유하고자 합니다.\n알고리즘 문제 풀이 방법 아래의 내용은 주관적이며, 저도 때때로 그냥 풀 때도 있지만.. 아래와 같이 문제를 풀면 좋을 것 같다 생각합니다..!\n알고리즘 문제를 효과적으로 풀기 위해서는 체계적인 접근 방식이 필요합니다. 다음은 제가 사용하는 알고리즘 문제 풀이 방법입니다.\n문제 이해 및 분석: 주어진 문제를 철저히 분석하고, 해결을 위해 필요한 알고리즘과 자료구조를 선택합니다.\n코드 작성 및 테스트: 문제 해결을 위한 코드를 작성한 후, 다양한 테스트 케이스를 통해 코드의 정확성과 효율성을 검증합니다.\n해설 확인: 문제를 푼 후, 해설을 통해 다른 접근 방법이나 최적화 방법을 학습하고, 자신의 코드와 비교해 개선점을 찾습니다.\n코드 리뷰 및 개선: 해설을 참고하여 작성한 코드를 다시 검토하고, 개선할 부분을 수정합니다.\n문제 정리: 문제를 풀고 난 후, 프로그래머스 사이트에서 문제를 정리하고, 풀이 과정을 Github 기록했습니다. 특히 어려웠던 문제는 README에 체크하여 나중에 복습할 때 참고하면 좋을 것 같습니다.\n추가 팁 시간 제한 설정: 문제를 풀 때 적절한 시간 제한을 설정하면 시간 낭비를 줄이고 더 많은 문제를 풀 수 있습니다. 예를 들어, 한 문제당 30분 이상 고민하지 않기로 규칙을 정합니다. Focus To do 프로그램을 이용하면 조금 더 집중하기 쉬울 수 있습니다.\n코드 리뷰: 다른 사람의 코드를 읽고 리뷰하는 것도 유익합니다. 이를 통해 새로운 접근 방식을 배우고, 코드의 가독성과 효율성을 향상시킬 수 있습니다.\n자동완성 도구 사용 자제: 알고리즘 문제를 풀 때는 자동완성 도구 사용을 자제합니다. 자동완성에 의존하면 기본 개념과 코딩 능력을 향상시키는 데 방해가 될 수 있기 때문입니다. 직접 코드를 작성하며 논리적 사고와 문제 해결 능력을 기르는 것이 중요합니다.\n꾸준한 연습: 알고리즘 문제 해결 능력은 꾸준한 연습을 통해 향상됩니다. 매일 일정 시간을 할애하여 문제를 풀어보는 습관을 기르는 것이 좋습니다.\n알고리즘 패턴 문제를 풀다 보면 다양한 알고리즘 패턴이 존재함을 알 수 있습니다. BFS, DFS, 탐욕 알고리즘 등 다양한 패턴을 통해 문제를 해결할 수 있습니다.\n또한, 문제를 풀 때는 어느 정도 템플릿을 사용하는 것이 도움이 됩니다. 아래는 문제를 풀다보면 자주 사용하는 템플릿을 정리했습니다.\nDFS (Depth-First Search) 깊이 우선 탐색은 그래프나 트리의 노드를 깊이 우선으로 탐색하는 알고리즘입니다. 하나의 경로를 끝까지 탐색한 후, 다른 경로를 탐색합니다. 경로가 매우 긴 경우에 효과적입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private static int[] dx = {0, 1, 0, -1}; private static int[] dy = {1, 0, -1, 0}; public void search(int[][] grid) { int rows = grid.length; int cols = grid[0].length; for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; cols; j++) { if (grid[i][j] == 1) { dfs(grid, i, j); } } } } private void dfs(int[][] grid, int x, int y) { grid[x][y] = -1; // 방문 표시 for (int i = 0; i \u0026lt; 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if (nx \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt; grid.length \u0026amp;\u0026amp; ny \u0026lt; grid[0].length \u0026amp;\u0026amp; grid[nx][ny] == 1) { dfs(grid, nx, ny); } } } BFS (Breadth-First Search) 너비 우선 탐색은 그래프나 트리의 노드를 너비 우선으로 탐색하는 알고리즘입니다. 시작 노드와 같은 깊이의 노드들을 먼저 탐색한 후, 다음 깊이의 노드들을 탐색합니다.\n최단 경로 탐색에 유리합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private static int[] dx = {0, 1, 0, -1}; private static int[] dy = {1, 0, -1, 0}; public int bfs(int[][] grid, int startX, int startY) { Queue\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(new int[]{startX, startY}); grid[startX][startY] = -1; // 방문 표시 int steps = 0; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i \u0026lt; size; i++) { int[] point = queue.poll(); int x = point[0], y = point[1]; for (int j = 0; j \u0026lt; 4; j++) { int nx = x + dx[j]; int ny = y + dy[j]; if (nx \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt; grid.length \u0026amp;\u0026amp; ny \u0026lt; grid[0].length \u0026amp;\u0026amp; grid[nx][ny] == 1) { queue.offer(new int[]{nx, ny}); grid[nx][ny] = -1; // 방문 표시 } } } steps++; } return steps; } 알고리즘 문제를 풀 때 위와 같은 템플릿을 사용하면 좋습니다.\n문제의 유형에 따라 적절한 알고리즘과 자료구조를 선택하고, 이를 기반으로 문제를 해결해 나가는 것이 중요합니다.\n또한, 다양한 예제를 풀어보며 다양한 접근 방식을 익히는 것도 큰 도움이 될 것이라 생각됩니다.\n느낀점 알고리즘 문제를 풀면서 어려움을 겪기도 했지만, 꾸준한 연습을 통해 성장할 수 있었습니다.\n특히 Level 2까지는 어느 정도 풀었지만, Level 3 이상부터는 상당한 난이도를 느꼈습니다. 그래도 계속 문제를 풀다 보니 알고리즘 문제마다 특정 패턴이 있다는 것을 알게 되었습니다.\n문제를 풀고 다른 사람들의 풀이를 보면서 \u0026ldquo;어떻게 저런 생각을 할 수 있을까?\u0026ldquo;라는 고민을 자주 하게 되었고, 이 과정에서 새로운 시각과 접근 방법을 배울 수 있었습니다.\n","permalink":"https://haservi.github.io/posts/books/programmers-java/","summary":"취업과 이직을 위한 프로그래머스 코딩 테스트 문제 풀이 전략 자바 편 도서 리뷰입니다.","title":"[도서] 취업과 이직을 위한 프로그래머스 코딩 테스트 문제 풀이 전략 리뷰"},{"content":"평소 AI에 관심만 있던 상황에서 최근 우연치 않게 야놀자 회사에서 LLM(Large Language Models) 관련 논문이 LLM 우수 모델로 수상됐다는 기사를 보고 급 관심이 가서 LLM을 어떻게 쓰는지 찾아봤습니다.\n사실 논문을 봐도 무슨 내용인지 모르겠더라구요.\n대략적으로 영어 중심 언어 모델을 다른 언어(한국어)로 확장하고 새로운 언어 토큰을 효과적으로 통합하는 방법이라 합니다. 이런 것들을 보면 정말 대단하신 분들이 많은 것 같고 나는 코딩하는 김아무개가 아닐까..\nLLM 관련하여 계속 찾다 보니 Ollama가 학습한 LLM 모델을 실행시켜 준다는 것을 알고 해당 방법으로 로컬에서 LLM 모델을 사용하는 방법에 대해 포스팅 해보겠습니다.\nOllama 란? Ollama는 다양한 오픈소스 대형 언어 모델(LLM)을 로컬 컴퓨터에서 쉽게 실행할 수 있도록 도와주는 도구입니다.\nLlama3, Mistral, codegemma등 다양한 오픈소스 LLM을 지원하며, 모델 가중치, 설정, 데이터셋을 하나의 패키지로 묶어 Modelfile로 관리할 수 있습니다.\nOllama 설치 우선 Ollama를 공식 사이트에서 다운로드 받습니다.\n해당 글은 Window를 기준으로 하기에 Window 파일로 다운로드 받습니다.\nModels 항목에는 여러 유명 LLM 모델들이 있으니 관심이 가는 모델을 다운로드 받을 수 있습니다.\n모델 파일 D드라이브로 이동 방법 C드라이브 용량이 부족한 경우 D드라이브에 model을 저장할 수 있습니다.\n관련 이슈를 참조해보면 환경 변수를 OLLAMA_MODELS로 저장하고 경로를 추가해주면 Ollama를 통해 모델 다운로드 시 해당 경로에 저장되는 것을 확인 할 수 있습니다.\nllama3 사용 방법 사이트에서 제공하는 model을 이용하면 쉽게 이용이 가능합니다. 공식 사이트에서 Models 항목에 여러가지의 models이 있습니다.\n그 중 llama3가 현재 가장 인기 있는 모델 중 하나입니다. Ollama가 실행된 상태에서 터미널에 아래와 같이 입력하면 설치 후 다시 입력하면 실행 할 수 있습니다.\n1 ollama run llama3:8b 70b도 있지만 일반적인 노트북 또는 컴퓨터로는 8b정도를 돌리는 것도 생각보다 어렵습니다. 8b면 80억개의 파라미터니까 이 정도면 충분하지 않을까도 생각됩니다.\n위처럼 입력해주면 로컬 환경에서도 AI를 이용할 수 있습니다..!\n설치된 모델을 확인하고 싶은 경우 아래와 같이 입력하면 됩니다.\n1 ollama list 다른 모델 적용 방법 알림\nHugging Face에는 다양한 모델이 있지만, Ollama를 이용한 경우 거의 대부분 대화형 AI 모델만 이용할 수 있습니다.\n뭔가.. 대답도 잘하고 많이 알고 있는거 같은데 영어로 대답하니 정감이 가지 않더군요.. 찾아보니 한국어 전용 LLM이 있었습니다..!\n친절하게 .gguf 파일(링크)도 만들어주셔서 다운로드 받아서 model을 만들어 보겠습니다.\nREADME를 보면 파이썬으로 할 수 있는 것 같은데.. 파이썬 설치 버전 문제랑 TensorFlow??? cuda???? Flax????? 입문자가 알아야 할게 많은 것 같습니다.\ngguf 파일을 Ollama에서 동작 시킬 수 있기 때문에 아래와 같이 gguf 파일만 다운로드 받습니다.\nModelfile을 생성하는 방법은 공식 문서에서도 볼 수 있습니다.\n그런데 이것도 모델마다 모델의 Template이 다른 것 같네요. Bllossom은 llama3를 base로 한 것 같으니 llama3 Modelfile의 template을 참조하여 작성하겠습니다. 우선 아래와 같이 설치된 llama3 모델 파일 정보를 확인합니다.\n1 ollama show --modelfile llama3 위와 같이 입력하면 llama3의 Modelfile의 정보는 아래와 같습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Modelfile generated by \u0026#34;ollama show\u0026#34; # To build a new Modelfile based on this, replace FROM with: # FROM llama3:latest FROM D:\\ProgramFiles\\ollama_model\\blobs\\sha256-6a0746a1ec1aef3e7ec53868f220ff6e389f6f8ef87a01d77c96807de94ca2aa TEMPLATE \u0026#34;{{ if .System }}\u0026lt;|start_header_id|\u0026gt;system\u0026lt;|end_header_id|\u0026gt; {{ .System }}\u0026lt;|eot_id|\u0026gt;{{ end }}{{ if .Prompt }}\u0026lt;|start_header_id|\u0026gt;user\u0026lt;|end_header_id|\u0026gt; {{ .Prompt }}\u0026lt;|eot_id|\u0026gt;{{ end }}\u0026lt;|start_header_id|\u0026gt;assistant\u0026lt;|end_header_id|\u0026gt; {{ .Response }}\u0026lt;|eot_id|\u0026gt;\u0026#34; PARAMETER num_keep 24 PARAMETER stop \u0026lt;|start_header_id|\u0026gt; PARAMETER stop \u0026lt;|end_header_id|\u0026gt; PARAMETER stop \u0026lt;|eot_id|\u0026gt; LICENSE \u0026#34;META LLAMA 3 COMMUNITY LICENSE AGREEMENT ... 라이센스 정보... 일단 보니까 go 느낌인거 같네요. 다운로드 받은 gguf 파일과 Modelfile의 파일명으로 아래의 정보를 추가합니다.\nFROM 절에는 gguf 다운로드 받은 파일의 절대 경로를 입력해주세요.\n한 곳에 두고 아래의 명령어를 입력하면 ollama에 모델을 학습할 수 있습니다.\n제 경우 Modelfile은 아래와 같이 입력했습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 FROM D:\\Reference\\llm_model\\llama3-korean\\llama-3-Korean-Bllossom-8B-Q4_K_M.gguf TEMPLATE \u0026#34;\u0026#34;\u0026#34; {{ if .System }}\u0026lt;|start_header_id|\u0026gt;system\u0026lt;|end_header_id|\u0026gt; {{ .System }}\u0026lt;|eot_id|\u0026gt;{{ end }}{{ if .Prompt }}\u0026lt;|start_header_id|\u0026gt;user\u0026lt;|end_header_id|\u0026gt; {{ .Prompt }}\u0026lt;|eot_id|\u0026gt;{{ end }}\u0026lt;|start_header_id|\u0026gt;assistant\u0026lt;|end_header_id|\u0026gt; {{ .Response }}\u0026lt;|eot_id|\u0026gt; \u0026#34;\u0026#34;\u0026#34; # 모델 온도(높을수록 창의적으로 대답함 기본 0.8) PARAMETER temperature 0.1 # 텍스트 예상 토큰 수(기본 128, -1 = 무한 생성) PARAMETER num_predict 3000 PARAMETER stop \u0026lt;|start_header_id|\u0026gt; PARAMETER stop \u0026lt;|end_header_id|\u0026gt; PARAMETER stop \u0026lt;|eot_id|\u0026gt; 그리고 아래와 같이 명령어를 이용해 모델을 생성하면 됩니다.\n1 ollama create ko-llama3 -f Modelfile 그리고 실행을 하면 사용할 수 있습니다..!\n1 ollama run ko-llama3 처음에는 PARAMETER의 temperature를 1로 주고 모델을 생성하니 뭐랄까.. 조금 이상하게 설명을 한 것 같습니다.\n이후 답변이 마음에 안들어서 지적하니까 GPU가 부족한건지 그 뒤로 한참동안 답변이 없더라구요.. 😂\n다시 temperature를 0.1로 변경하여 모델을 만들어서 실행해보니 아래와 같이 조금은 맞게 답변을 해주는 것 같긴 했습니다.\n나무위키에서 찾아본 손흥민 선수의 정보와 다르긴 하지만 그래도 대략적으로 맞는 것을 보면 또 신기하기도 하고..\nJava 코딩도 대략 맞는 것 같네요.\nLLM에서 GGUF(Georgi Gerganov Unified Format) 파일 구조 및 어떻게 만드는지도 궁금하긴 하지만 이 정도만 알아도 사용하는데 문제는 없을 것이라 생각됩니다..!\n이것을 응용해보면 Hugging Face 사이트에서 gguf와 관련된 모델을 찾아서 이용할 수 있습니다.\n마치며 위처럼 Hugging Face에서 모델 항목에서 다운로드 수로 정렬을 해보면 다양한 모델들이 많이 있습니다. 결국 제대로 이용하고 싶다면 python과 공식 문서를 보면서 공부해야 할 것 같아요.\n평소에 Web Backend와 Frontend, Devops 위주로 보다 AI 쪽을 찍먹해보니.. 뭔가 다른 세상 같기도 신기하면서도 알아야 할게 많은 것 같네요.\nAI Roadmap(링크)을 봐도 꽤 낯설긴 합니다.\n우선 다시 Backend와 Devops에 집중해야겠습니다. :D..\n","permalink":"https://haservi.github.io/posts/review/ollama-custom/","summary":"Ollama를 이용해 다양한 LLM Model 구동하기","title":"Ollama LLM Model 사용하기"},{"content":"Raycast란 Mac에서 이용할 수 있는 Raycast는 빠르고 확장 가능한 생산성 프로그램입니다. 간단하게 맥의 스팟라이트 또는 Alfred의 대체제로 생각하면 될 것 같아요.\nAlfred도 나름 잘 이용하고 있었지만, Raycast가 조금 더 상위 호환되는 느낌입니다. 그래서 제 기준으로 자주 사용하는 기능에 대해 정리했습니다.\n설치 및 기능 소개 brew를 이용(brew install --cask raycast)하거나 직접 다운로드링크하면 됩니다.\n기본 기능외에 확장 기능까지 이용하면 정말 다양한 기능을 활용 할 수 있을 것이라 생각됩니다.\n기본 설정하기 프로그램 설치 후 아래와 같이 프로그램 실행 단축키(option + space)를 설정합니다.\n설정 후 단축키를 입력하면 맥의 스팟라이트 처럼 맥에 설치된 프로그램을 실행할 수 있습니다.\n기본적으로 설치된 프로그램을 실행한다거나 지정된 단축키 또는 Alias로 지정한 값을 호출할 수 있습니다.\nClipboard History 복사한 항목이 자동으로 저장되는 기능입니다.\n우선 Raycast 단축키 설정(option + v)에서 아래와 같이 설정합니다.\n이렇게 설정하고 여러 문장을 복사한 뒤 Clipboard History(option + v)를 확인하면 아래와 같이 확인할 수 있습니다.\n종종 여러 작업을 하면서 2,3개의 비슷한 항목을 복사할 때 괜찮은 기능이라 생각합니다.\nWindow에서는 window + v가 텍스트랑 이미지도 복사가 되긴 하는데.. 그래도 이 정도도 충분히 좋은 것 같습니다..!\nQuickLink 브라우저에서 chatGPT 또는 번역기를 이용하면 3단계를 거치게 됩니다. 브라우저 실행 후 -\u0026gt; 특정 링크로 이동 -\u0026gt; 검색어 입력을 해야하죠.\nQuickLink를 이용하면 QuickLink 실행 -\u0026gt; 검색어 입력으로 단계를 줄일 수 있습니다.\n우선 QuickLink 단축키를 설정해야 합니다. 상단의 Raycast에서 우클릭 후 설정으로 이동합니다.\n아래와 같이 QuickLink 실행 단축키(option + f)를 지정합니다.\n그리고 QuickLink에 어떤 항목을 넣을지 설정하면 됩니다.\n위 처럼 CreateLink를 선택 후 QuickLink 항목을 추가하면 됩니다.\n주소창에 QueryString을 넣을 수 있는 경우는 아래 처럼 {Query}를 추가하면 됩니다.\n예를 들어 번역 사이트(Deepl)를 이용하고 싶다면 Link에 QueryString을 아래와 같이 추가할 수 있습니다. {Query}는 QuickLink에 입력된 입력값이 들어갑니다.\n1 https://www.deepl.com/translator#ko/en/{Query} 이렇게 설정하면 아래와 같이 QuickLink 항목들을 추가할 수 있습니다. Alias를 지정하면 ChatGPT의 경우 option+f -\u0026gt; c를 누르면 chrome에서 chatGPT를 바로 열 수 있습니다.\n제가 집에서 등록하고 이용하는 QuickLink 항목입니다. 이렇게 설정해 놓으면 조금은 간편하게 인터넷 쇼핑을 이용할 수 있습니다?\n1 2 3 4 5 6 7 8 - 뽐뿌 검색 https://www.ppomppu.co.kr/zboard/zboard.php?id=ppomppu\u0026amp;page_num=20\u0026amp;category=\u0026amp;search_type=sub_memo\u0026amp;keyword={Query} - 다음 쇼핑 https://shoppinghow.kakao.com/search/{Query} - 네이버 쇼핑 https://search.shopping.naver.com/search/all?query={Query} Popup 메모장 화면에 떠다니는 노트를 펼칠 수 있습니다. 급하게 메모할 때 유용합니다.\n우선 아래와 같이 단축키(option + option)를 지정합니다.\n이렇게 지정하고 단축키를 입력하면 아래와 같은 화면을 볼 수 있습니다. 급하게 메모할 때도 편리하게 이용할 수 있습니다. 색상도 예쁘고 정리하기 편한 것 같아 자주 쓸 것 같은 기능이라 생각됩니다..!\nExtension 기능 Raycast에서는 Store에서 검색을 통해 다양한 확장 기능을 사용할 수 있습니다.\nNotion, Github, VSCode, Slack 등 많은 프로그램을 연동할 수 있습니다.\n그중 한 가지만 소개해 드리면 Kill Process 입니다.\n우선 Store를 선택하면 아래처럼 다양한 확장자가 있습니다.\n검색창에서 kill process를 검색하면 아래와 같이 목록이 나오고 설치하면 됩니다.\n단축키 설정(option + k)로 설정합니다.\n설정 후 kill process를 틀어보면 mac에서 동작하는 process list를 확인할 수 있으며, kill 하고 싶은 process가 있다면 kill 하면 삭제가 됩니다.\n정리 Raycast는 프로그램은 키보드 단축키를 사용하여 맥에서 다양한 작업을 자동화 할 수 있습니다. 위의 기능 이외에도 JavaScript를 사용하여 자신만의 스크립트를 작성하여 Raycast를 확장할 수도 있습니다.\n제가 느낀 Raycast의 장점은 단축키를 활용하여 다양한 앱을 조금 더 빠르게 동작하게 하는 거라 생각됩니다.\n잘 이용하면 효율적이고, 개인에 맞는 작업 환경을 설정하여 생산성을 향상할 수 있다고 생각합니다.\n그 외 다른 프로그램 추천 해당 프로그램 이외에 mac에서 이용하면 좋은 프로그램은 아래와 같습니다.\nSnipaste(mac, window, linux) 사이트 링크 캡쳐 프로그램으로 가볍게 캡쳐하고 삭제가 가능(윈도우, 맥, 리눅스 모두 가능), 리뷰 Raycast(mac) 사이트 링크 단축키를 활용하여 생산성 향상 프로그램, 리뷰 Karabiner-Elements(mac) 사이트 링크 karabiner 프로그램으로 맥북 키보드 설정, 리뷰 Rectangle(mac) 사이트 링크 프로그램 화면 크기 조절 프로그램, 리뷰 Logitech Options(mac) 사이트 링크 Logitech 제품 마우스 커스텀 프로그램, 리뷰 Dbeaver(mac, window) 사이트 링크 DB 접근 제어 프로그램 일부 커스텀 방법, 리뷰 ScreeToGif(mac, window) 사이트 링크 간단하게 화면을 gif로 만드는 프로그램 소개, 리뷰 ","permalink":"https://haservi.github.io/posts/tools/how-to-raycast/","summary":"Raycast의 특정 기능 및 유용한 팁을 공유합니다.","title":"Raycast를 이용하여 업무 효율성 높이기"},{"content":"윈도우를 쓰면 PowerToys를 이용하면 더 세밀하게 화면 크기를 조절할 수 있습니다.\nmac에서는 PowerToys가 없는 것 같지만 magnet 또는 rectangle를 이용하면 화면 크기 조절을 할 수 있습니다.\nmagnet도 좋은 앱이지만 유료이기 때문에 무료인 rectangle을 추천합니다.\n개인적으로 이것만 이용해도 화면 조절에 큰 무리 없이 이용할 수 있다 생각됩니다.\n설치 및 설정 Rectangle 해당 링크에서 우선 다운로드 후 설치합니다.\n사실 Rectangle은 별로 설정할게 없습니다.\n설치 후 단축키 설정만 하면 됩니다.\n제가 설정한 단축키 설정은 아래와 같습니다.\n기존에 magnet을 이용하고 있어서 이와 유사하게 설정한 게 편하여 이렇게 설정한 것 같아요.\n그 외 다른 프로그램 추천 해당 프로그램 이외에 mac에서 이용하면 좋은 프로그램은 아래와 같습니다.\nSnipaste(mac, window, linux) 사이트 링크 캡쳐 프로그램으로 가볍게 캡쳐하고 삭제가 가능(윈도우, 맥, 리눅스 모두 가능), 리뷰 Raycast(mac) 사이트 링크 단축키를 활용하여 생산성 향상 프로그램, 리뷰 Karabiner-Elements(mac) 사이트 링크 karabiner 프로그램으로 맥북 키보드 설정, 리뷰 Rectangle(mac) 사이트 링크 프로그램 화면 크기 조절 프로그램, 리뷰 Logitech Options(mac) 사이트 링크 Logitech 제품 마우스 커스텀 프로그램, 리뷰 Dbeaver(mac, window) 사이트 링크 DB 접근 제어 프로그램 일부 커스텀 방법, 리뷰 ScreeToGif(mac, window) 사이트 링크 간단하게 화면을 gif로 만드는 프로그램 소개, 리뷰 ","permalink":"https://haservi.github.io/posts/tools/how-to-rectangle/","summary":"윈도우를 쓰면 PowerToys를 이용하면 더 세밀하게 화면 크기를 조절할 수 있습니다.\nmac에서는 PowerToys가 없는 것 같지만 magnet 또는 rectangle를 이용하면 화면 크기 조절을 할 수 있습니다.\nmagnet도 좋은 앱이지만 유료이기 때문에 무료인 rectangle을 추천합니다.\n개인적으로 이것만 이용해도 화면 조절에 큰 무리 없이 이용할 수 있다 생각됩니다.\n설치 및 설정 Rectangle 해당 링크에서 우선 다운로드 후 설치합니다.\n사실 Rectangle은 별로 설정할게 없습니다.\n설치 후 단축키 설정만 하면 됩니다.\n제가 설정한 단축키 설정은 아래와 같습니다.","title":"Rectangle 이용하여 화면 크기 조절하기"},{"content":"최범균 저자님의 책을 처음 접한 것은 예전 스프링5 프로그래밍 입문하기 책이었습니다. 그때의 기억을 생각하면 어렵지 않게 중요한 개념을 쉽게 풀어쓴 책이라 생각됩니다.\n육각형 개발자는 종종 개발 블로그 분들이 포스팅을 해주신 것을 봐서 책의 존재는 알고 있었지만 읽을 기회가 없었는데 마침 회사에 비치돼 있어 읽어봤습니다.\n공감된 내용 및 정리 책을 읽고 공감된 내용의 일부를 발췌해 봤어요. 몇몇 글은\nHTTP 프로토콜, 네트워크 프로그래밍 기초, 동시성 처리, 프로그래밍 언어 등 유행에 상관없는 기술은 공부하는 것이 좋다. 기술을 적용할 때는 유연함이 필요하다. 마이크로서비스 아키텍처도 기능이 적고 사용자가 많지 않은데 기능을 잘게 나눠 별도 서비스로 분리하면 서비스를 분리했을 때 얻는 이점이 반감된다. 오히려 시스템만 복잡해지고 운영이 힘들어질 수 있다. 흥미로운 주제가 있다면 관련 자료를 찾아보거나 기술 트렌드에 민감하게 반응하는 인물의 SNS를 찾아보는 것도 괜찮다. 버그를 수정하는 시간보다 버그 원인을 찾는 데 시간이 더 오래 걸리는 경우가 많다. 메서드 추출을 잘 활용하면 코드 가독성을 높이면서 응집도도 함께 높일 수 있다. 변수를 사용할 때는 최초 사용하기 전에 선언하는 게 좋다. 그렇지 않으면 쓸모없는 코드를 읽어야 할 수 있다. 오래된 주석을 삭제하고 싶다면 먼저 확인한 날짜를 코드에 기입한 후에 조금 더 지켜본 뒤(3~6개월)에 삭제하는 것이 좋다. 메서드를 분리할 때는 다음 순서대로 진행한다. 두 기능 중 한 기능을 위한 메서드를 추가한다. 이 메서드는 내부에서 기존 메서드를 호출한다. 기존 메서드를 호출하는 코드가 새 메서드를 호출하도록 변경한다. 기존 메서드의 코드를 새 메서드로 이동한다. 이름을 변경하고, 코드를 정리한다. 루프를 1번 돌아서 여러 로직을 처리하는 것보다 2번 돌려서 하나의 로직씩 처리하는 게 더 이점이 크다. 복잡한 코드보다 이해하기 좋은 코드가 주는 이점이 훨씬 크다. 새로 만들 때의 단점보다 이점이 더 클 때 개선의 방법으로 마이크로서비스를 선택해야 한다. 아키텍처를 설계할 때는 모든 면에서 최고인 아키텍처를 추구하면 안 된다. 모든 게 완벽한 아키텍처가 아닌 가장 나쁘지 않은 아키텍처를 선택해야 한다. 아키텍처가 중요한 이유는 시스템의 골격 역할을 하고, 품질 속성에 영향을 미치기 때문이다. 마이크로서비스 아키텍처를 선택하면 탄력성, 배포 가능성이 커지지만 데이터 무결성을 위한 구조는 더 복잡해진다. 설득을 위한 자료를 작성한다면 SCQA 프레임워크 활용한다. 상황(Situation): 현재 상태와 문맥을 제공한다. 문제점(Complication): 현 상황에서 무엇이 문제 되는지 기술한다. 의문점(Question): 문제점에서 도출되는 의문 사항이다. 해결(Answer): 의문점에 대한 해결책을 제시한다. 5가지 글쓰기 팁 문장 짧게 쓰기 글머리 기호 목록 번호 목록 사용하기 표나 그래프 사용하기 그림 사용하기 시각적 효과 사용하기 복잡한 시스템을 알맞은 단위로 분해하고 진행 계획을 세우는 역량 역시 시니어 개발자가 가져야 할 중요 역량이다. 동료가 제시한 구현 기술 후보 중에서 현재 상황에 맞는 기술을 선택할 수 있는 기준을 갖추는 것도 중요하다. 관리자와 관계 유지 방법(스태프 엔지니어 책 발췌) 관리자를 놀라게 하지 말자. 관리자를 놀라게 하면 신뢰가 사라질 수 있다. 관리자에게 놀라지 말자. 관리자가 모든 세세한 사항을 챙길 것이라고 기대하지 말자. 대신 관리자와 적극적으로 소통해서 정보 피드백을 얻자 관리자에게 관련 정보를 제공하자. 유용하다고 생각하는 정보가 있다면 관리자에게 전달한다. 사회적 기술(구글 엔지니어 책 발췌) 겸손: 우주의 중심은 내가 아니다. 나는 다 알지 못하며 완벽하지도 않다. 그리고 스스로 발전하는 데 열려 있다. 존중: 진심으로 상대를 배려한다. 동료에게 친절히 대하고 동료의 능력과 성취를 인정한다. 신뢰: 동료가 능숙하게 올바른 일을 하리라 믿는다. 추천책 책을 읽다보면 책 안에서 또 다른 책을 추천하는 경우가 많이 있습니다. 아래는 책을 읽으면서 저도 읽어보고 싶어 정리한 책입니다.\n개발 관련 레거시 코드 활용 전략(에이콘출판사) 도메인 주도 개발 시작하기(한빛미디어) - 테스트 관련 글쓰기 관련 유시민의 글쓰기 특상(생각의 길) 엔지니어를 위한 문장의 기술(로드북) 마케터의 문장(인풀루엔셜) 내 문장이 그렇게 이상한가요?(유유) 직업 관계 기술 테크니컬 리더(인사이트) 스태프 엔지니어(길벗) - 관리자와 관계를 유지하는 방법 제시 구본형의 THE BOSS 쿨한 동행(살림Biz) 구글 엔지니어는 이렇게 일한다(한빛미디어) 켄트 벡의 구현 패턴(에이콘출판사) 후기 및 감상평 제가 느끼기엔 점점 더 개발자의 역량이 높아지는 것 같습니다. 알아야 할 지식의 범위도 늘어나고 있으며 backend 개발자의 경우로 보면 devops의 역량과 기본적인 front 지식도 필요하다 생각됩니다.\n책의 내용을 읽어봤을 때 들었던 느낀 점은 리팩토링 책과 클린코드, 오브젝트, 클린 아키텍쳐 등의 책에서 중요하게 강조한 핵심 내용을 전반적으로 넓고 얇게 다루고 있어서 편하게 읽을 수 있었습니다. 또한, 개발 역량뿐 아니라 커뮤니케이션 기술 및 최신 기술트랜드를 따라가는 방법 등이 있습니다.\n책에서 소개한 개념에 대한 예제도 이해하기 쉽게 표현한 것 같으며, 코드도 Java를 조금이라도 해본 적이 있다면 큰 문제 없이 이해할 수 있을 거라 생각됩니다.\n종종 책 저자분의 경험담이 나오는데 몇몇 경험담은 조금은 공감도 됐던 것 같아요.\n제 생각에 이 책은 0~2년 차 개발자가 읽으면 좋을 것 같습니다. 조금 연차가 있는 개발자분이 보시면 그냥 맞는 얘기를 하는 것 같아 쉽게 쉽게 넘어갈 수 있다 생각됩니다.\n","permalink":"https://haservi.github.io/posts/books/hexagonal-developer/","summary":"최범균 저자님의 책을 처음 접한 것은 예전 스프링5 프로그래밍 입문하기 책이었습니다. 그때의 기억을 생각하면 어렵지 않게 중요한 개념을 쉽게 풀어쓴 책이라 생각됩니다.\n육각형 개발자는 종종 개발 블로그 분들이 포스팅을 해주신 것을 봐서 책의 존재는 알고 있었지만 읽을 기회가 없었는데 마침 회사에 비치돼 있어 읽어봤습니다.\n공감된 내용 및 정리 책을 읽고 공감된 내용의 일부를 발췌해 봤어요. 몇몇 글은\nHTTP 프로토콜, 네트워크 프로그래밍 기초, 동시성 처리, 프로그래밍 언어 등 유행에 상관없는 기술은 공부하는 것이 좋다.","title":"[도서] 육각형 개발자 리뷰"},{"content":"매년 초가 되면 항상 회고를 작성해야겠다 생각하지만, 시간이 지나가면서 점점 다음으로 미루게 되는 경향이 있네요.\n1분기는 끝나가지만 남은 3분기를 그래도 이전에 무엇을 했고, 올해는 어떻게 할지 적어보려 합니다.\n💼 사내 업무 작년에는 사내 프로젝트로 Node.js로 Backend 서버 구현과 C/C++이 로봇 프로그램 기능 추가 및 유지 보수를 진행했었습니다.\nNode.js를 이용한 backend는 처음 구현해 봤지만, 생각보다다 구현이 쉬웠고, 성능도 괜찮은 것 같다고 생각합니다.\n중간에 코드가 적응된 뒤에 JavaScript의 코드를 TypeScript로 바꾼 점도 이후 유지보수에 더 좋았던 것 같아요.\n한 가지 아쉬운 점이라면 그 당시에는 기간(6개월)이 짧았기 때문에 프레임워크로 Express를 선택했지만, 프로젝트가 시간이 지나면서 유지 관리를 하고, 조금씩 코드 스타일도 적응이 돼가면서 NestJS로 시작해 보는 것도 괜찮았을 거라는 생각도 듭니다.\n프로젝트를 하면서 TypeScript와 TypeORM을 이용하여 Spring JPA 같이 프로젝트를 해보니 생각보다 괜찮았으며, Type을 잘 정의하면 코드 관리도 쉽게 잘 됐던 것 같아요.\nNode.js는 싱글 쓰레드 논 블로킹으로 동작합니다. I/O 처리의 경우는 Event Loop를 이용해 비동기로 처리하면서 Event Loop를 하는 부분이 있었는데 생각보다 성능이 잘 나와서 신기했던 경험이 있었습니다.\nNodeJS Event Loop파헤치기라는 글이 Event Loop에 대해 잘 설명한 내용인 것 같아요.\n위의 개념이 들어 있던 기능 중 하나는 웹에서 특정 파일을 업로드 하면 적게는 100mb 많게는 4gb가 넘는 파일을 업로드 또는 이어올리기 하는 기능입니다.\n이후 backend에서는 해당 파일을 압축해제 후 기존 프로토콜 문서에 맞게 암호화 작업을 하고, 파일과 동일한 부분은 제거하는 diff 처리를 하는 작업 후 AWS S3에 업로드 하는 기능이 있었습니다. 위 로직에서 워커 쓰레드도 이용하고 diff 처리를 위해 c++ 코드도 들어가는데 이러한 작업은 모두 비동기로 동작해야 하는 점입니다.\n짧게는 1분도 안 걸리지만 용량이 크면 10분 이상 걸리는 작업도 Event Loop를 통해 안정적으로 처리되면서 기존의 api도 문제 없이 동작한다는게 꽤 신기했던 것 같습니다.\n처음엔 Node.js로 Backend를 처리할 때 프로그램이 너무 잘 죽고 조금만 문제가 있어도 서버가 꺼지는 현상이 있었지만, 로그도 추가하고, 예외 처리, API 템플릿 구성, PM2, CI/CD 등 조금씩 기능을 추가하다보니 나름 안정적으로 관리가 됐던 것 같아요.\n지금은 다시 Spring Backend 서버 프로젝트를 하고 있으며, 조만간 다시 입사 초에 했던 WPF를 하게 될 것 같습니다. WPF가 그 당시에는 정말 자료도 많이 없고, 찰스페졸드의 WPF 책이 거의 교과서였던 시절이었는데.. 지금 근황은 어떨지 찾아봐야겠네요 ㅎㅎ..\n📧 우테캠 Pro 5기 참여 벌써 재작년(2022년) 이야기지만 나름 의미 있고 열정적으로 참여한 활동으로 생각한 우테캠 Pro 5기 참여입니다.\n실무 3년 차 이상 개발자 중에 사전 과제 테스트를 통과한 60여 명? 정도가 2달 동안 8개의 과제를 하는 과정이에요.\n운 좋게 참여할 기회를 받고 사전 과제도 다행히 합격하여 국비 지원 이후 처음? 참여한 외부 활동입니다.\n우테캠 Pro 과제의 진행 방식은 모두 Github을 통해 지정된 코드 리뷰어가 평가하는 방식이었습니다.\n약 2달간 평일에는 회사 업무를 하고 평일 저녁과 새벽 그리고 주말에 과제를 진행하면서 코드 리뷰도 받아보고, 좋은 코드를 작성하기 위해 리뷰어분과 Github 코멘트로 이야기하는 게 신기하고 재밌었습니다.\n또 한 가지 위 활동에 열심히 참여한 이유 중 하나는 교육비 환급도 있었습니다. 과제를 진행하며 코드 리뷰어 분들의 전체적인 평가로 상위 50퍼센트 이내에 들게 되면 교육비의 30퍼센트를 환급해 주는 것도 큰 몫을 차지한 것 같아요. 다행히 50퍼센트 이내에 들어서 돈 벌었다고 생각했었네요.\n해당 교육 과정은 코로나 시기에 진행돼서 그런지 교육 과정이 끝나기 전에 딱 한 번 오프라인 모임을 했습니다.\n회사 밖에서 다른 개발자분들과 만나서 대화를 하는게 흔한 상황은 아니라 꽤 신기했던 경험이었습니다. 이야기를 나누다 보니 다들 똑같은 사람이구나라는 생각도 들고 사람 사는 거 다 비슷하구나.. 그런 생각도 들고, 그렇게 지나간 것 같아요.\n이상한 점은 매년 부트캠프를 모집하는 줄 알았는데 우테캠 Pro 5기 이후 아직까지는 모집을 안 하는 것 같아요.\n아래는 위 교육과정의 주차 유형별 주제 및 제가 작업했던 코드 링크를 추가했습니다.\n코드는 과제마다 step을 두고 branch로 관리하면서 점점 진행하는 방식으로 진행했었는데 정말 괜찮은 방법이라 생각되네요.\n1주차 로또 - TDD Github 기반으로 온라인 코드 리뷰하는 경험 TDD 기반으로 프로그래밍하는 경험 메소드 분리 + 클래스를 분리하는 리팩토링 경험 점진적으로 리팩토링하는 경험 2주차 Q\u0026amp;A - JPA JPA 학습 테스트를 통한 JPA 학습 Q\u0026amp;A 서비스를 JPA로 매핑 3주차 지하철 노선도 - ATDD ATDD Cycle 인수 테스트 4주차 서비스 구성 및 배포 - 그럴듯한 서비스 서비스 구성 및 배포 5주차 지하철 노선도 - ATDD 내에서 TDD TDD, 단위 테스트와 통합 테스트 로그인 상태 인수 테스트 6주차 성능 테스트 및 모니터링 - 서비스 진단하기 부하 테스트 및 성능 모니터링 7주차 지하철 노선도 - 레거시 코드 리팩토링 레거시 코드 리팩터링 with 테스트 멀티 모듈, DDD 8주차 화면 응답, 조회 성능 개선하기 - 안정적인 서비스 만들기 서비스 진단 및 화면 응답 개선하기, SQL 최적화 시간이 꽤 지나서 복습도 할 겸 다시 Github 코드 보고 Kotlin으로 변경하는 것도 꽤 재밌을 것 같네요.\n처음에는 코드 리뷰를 받는 것에 익숙하지도 않았고, 과제도 제 기준으로는 힘들었던 거 같았는데 이게 또 지나고 보니 나름 열정적으로 해서 추억이 된 거 같기도..\n🎫 인프콘 인프콘 티켓팅에 선정돼서 2023년 8월 15일 컨퍼런스에 참여할 수 있었습니다.\n발표자 분중에 김영한님 세션도 있어서 꼭 한번 실물로 보고 싶었는데 목표를 달성해서 뿌듯한? 느낌도 있었습니다.\n실무를 하며 김영한님의 책(JPA 프로그래밍)도 많은 도움이 됐고, 인프런 강의 사이트에서 유일하게 유료 구매를 거의 다 했던 강의가 김영한님 강의라 실물로 뵙게되니 신기하기도 하고 그랬습니다.\n현재 발표 자료는 Youtube 인프런 채널에서 발표 영상을 볼 수 있습니다. 이외에도 해당 채널에서 인프콘 2023 발표 영상을 확인할 수 있습니다.\n전 아래의 세션을 들었습니다.\n인프런 아키텍처 2023 ~ 2024 커뮤니케이션 잘하는 개발자의 4가지 습관 어느 날 고민 많은 주니어 개발자가 찾아왔다 2탄: 주니어 시절 성장과 고민들 인프런에서는 수천 개의 테스트 코드를 이렇게 다루고 있어요 우리는 이렇게 모듈을 나눴어요: 멀티 모듈을 설계하는 또 다른 관점! 발표를 들으면서 제가 평소에 생각해왔던 것은 모든 프로젝트에 적합한 기술을 선택해야 한다는 것입니다.\n서비스의 성격이나 규모를 미리 알 수 없는 경우에는 과하게 아키텍쳐를 고려해서 구현하는 것은 조금 지나친 느낌이 들기도 합니다. 중요한 것은 상황에 맞는 적절한 기술을 선택하고 그에 맞게 코드를 구현하는 것이라고 생각합니다.\n발표자 분들의 이야기를 들으면서 이러한 관점에서 공감하는 부분이 많았습니다.\n🚲 제주도 자전거 환상종주 작년 10월 중순, 회사 워크숍으로 제주도를 다녀왔습니다. 워크숍 이후에는 자유롭게 일정을 정할 수 있어서, 회사 동료분들과 함께 자전거를 타고 제주도를 한 바퀴 도는 일정을 1박 2일로 잡았습니다.\n제주도 환상종주의 총거리가 약 230km여서 하루에 115km씩 타야 완주할 수 있었습니다.\n자전거는 보통 출퇴근 따릉이만 타는 입장에서 할 수 있을지 걱정이 됐지만 그럭저럭 잘 따라갔었던 것 같아요.\n제주도 한바퀴 코스를 하기 전에 체력 증진 및 완주를 위해 2번의 예비 라이딩도 했었네요.\n우선 자전거가 없으니, 당근에서 중고 로드 자전거 15만원 정도에 구매하고 기본 장비도 사서 라이딩 연습을 했었습니다. 첫 번째 라이딩으로는 안양천 합수부에서 정서진까지 왕복 약 60km 정도를 갔었으며, 두 번째는 안양천 합수부에서 팔당 두물머리 코스(왕복 약 130km)를 갔었네요.\n2번째 라이딩은 시간으로 보면 오전 8시에 출발해서 점심 저녁 먹고 집에 오니 저녁 8시였으니 대략 7~9시간 자전거를 탔던 것 같네요. 이 정도 타니 안장통이 뭔지와 엉뽕이 왜 중요한지 알겠더라구요..\n제주도에서 라이딩을 했을때는 자전거 대여점에서 대여할 수 있는 종류가 많지 않아 MTB 자전거를 대여해서 라이딩을 했습니다.\nMTB를 타보니 로드보다는 MTB가 더 안정적이라 조만간에 자전거를 바꿀 로드에서 MTB로 바꿔야겠다 생각했네요.\n🏊‍♀️ 수영 작년 9월부터 수영을 시작했습니다. 해보니 정말 재밋어서 아마 평생 운동이 될 것 같아요.\n위의 커리큘럼으로 현재까지 수업은 진행했습니다. 음.. Jira를 개인 용도로 쓰고 있긴 한데 프로젝트 관리 하기에 정말 좋을 것 같아요.\n뭐 프로젝트가 아니라도 무언가 관리하기 좋은거 같아 개인 용도로 잘 쓰고 있습니다. ㅎㅎ.. 타임라인 기능이 직관적이라 지속적으로 하는 작업은 저렇게 가끔 정리하면 좋겠다 생각합니다.\n수영을 처음할 때는 저녁 초급반으로 시작했습니다. 초급반에서는 나름 에이스라고 생각하면서 여유롭게 수영을 했었는데, 중급반을 가니 다들 너무 잘하셔서 45분이 정말 어떻게 지나가는지 모를 정도로 빨리 지나가는 것 같아요.\n제자리 다이빙 하는 날이면 수업내내 정신을 차릴 수가 없고, 오리발 끼고 하는 날이면 사람들이 왜 이렇게 빠른지.. 언젠가 적응이 되지 않을까 생각되지만, 지금은 그렇습니다.\n물속에 들어가면 온전히 나에게 집중되는게 정말 매력적이라 생각합니다. 최근에는 골전도 이어폰을 사서 주말에 자유 수영을 할 때 사용해봤는데 올해 산 물건 줌 정말 만족한 제품 중 하나입니다.\n수영을 조금 더 잘 하게 되면 자격증도 좀 알아보고 도전해보고 싶네요.\n📘 독서 여러 메모장 앱을 써봤지만, 지금은 Notion을 자주 이용하고 있습니다.\n이렇게 읽은 책을 정리해 놓고 해당 책에 대해 좋은 내용이나 오탈자 등을 정리 해 놓으면 나중에 다 읽고 출판사에 오탈자 제보도 할 수 있고 관리하기도 좋습니다.\n최근 넷플릭스 삼체 드라마를 보고 인상 깊어 바로 도서관에 가서 책을 대여해서 보고 있는데 등장 배경과 인물이 조금 다르지만, 전체적인 스토리는 동일한 것 같아 열심히 읽는 중이네요.\n올해에는 전공 서적 이외 다른 분야의 책도 많이 읽고 싶네요.\n마치며 회고를 처음 써 봤는데 너무 개인적인 이야기를 쓰는 거라 작성하고도 올릴지 말지 고민을 많이 했네요. 사실 아무도 관심이 없겠지만 뭔가를 오픈한다는게 뭐랄까 처음이 어려운 걸까 싶기도 하고.. 그렇습니다.\n남은 2024년에는 정리가 조금 더 잘 된 한 해가 되면 좋겠네요. 듣고 있는 인터넷 강의도 모두 다 마무리하고, 읽고 있던 책들도 다 읽고 하나의 마침표를 찍고, 다음을 진행하면 좋겠네요.\n","permalink":"https://haservi.github.io/posts/review/retrospective-2023/","summary":"매년 초가 되면 항상 회고를 작성해야겠다 생각하지만, 시간이 지나가면서 점점 다음으로 미루게 되는 경향이 있네요.\n1분기는 끝나가지만 남은 3분기를 그래도 이전에 무엇을 했고, 올해는 어떻게 할지 적어보려 합니다.\n💼 사내 업무 작년에는 사내 프로젝트로 Node.js로 Backend 서버 구현과 C/C++이 로봇 프로그램 기능 추가 및 유지 보수를 진행했었습니다.\nNode.js를 이용한 backend는 처음 구현해 봤지만, 생각보다다 구현이 쉬웠고, 성능도 괜찮은 것 같다고 생각합니다.\n중간에 코드가 적응된 뒤에 JavaScript의 코드를 TypeScript로 바꾼 점도 이후 유지보수에 더 좋았던 것 같아요.","title":"2023년 회고"},{"content":"개인용 NAS를 충분히 이용하지 못한다는 생각이 문득 들었습니다.\n기본적으로 제공하는 Photos, 파일 저장소 정도만 이용하며, Docker Gitlab 서버 배포 중이긴 하지만.. 그냥 배포중 입니다.\n이 정도도 충분하긴 하지만 조금 더 활용하면 좋지 않을까라는 생각을 하게 됐습니다.\n문득 생각해 보니 NAS에서 Docker를 사용할 수 있다는 것은 개인적으로 운용할 수 있는 장난감 서버로 최적이지 않을까라는 생각이 들었습니다.\n물론 아마도 많은 트래픽은 감당하지 못하더라도 개인적인 용도로 테스트 서버 정도는 만들 수 있지 않을까 생각됩니다.\nNAS를 이용하면 기본적으로 도메인을 받을 수 있으며, DDNS 서비스를 제공하기에 조금 더 외부 접근에 대한 관리가 쉬울 것입니다.\n서비스를 만들 때 AWS를 이용하면 좋긴 합니다. 관리도 쉽고 트래픽의 요청이 많으면 자동화도 할 수 있고, 탄력적이고 확장성 있게 리소스를 조정할 수 있습니다.\n그렇지만 그만큼의 비용을 지불해야 합니다.\nNAS를 이용하면.. 전기세만 내면 개인적인 서비스를 구축할 수 있습니다..! 이후 안정화가 되거나 될 것 같은 서비스라고 판단되면 AWS나 Azure 이것도 아니라면 개인용 서버를 이용하여 환경을 구축하면 되지 않을까 생각합니다.\nNAS 소비 전력 계산 이참에 개인 양산형 NAS(DS220+)의 소비전력을 한번 계산 해보겠습니다.\nNAS가 없다면 NAS 구입 비용과 매달 내는 전기세를 계산해보고, NAS를 사용하지 않고 필요할 때 Cloud를 이용하는 것도 현명한 선택이라 생각됩니다.\nDS220+의 스펙을 확인해보니 전원 소비 값은 아래와 같더군요.\n최대값을 계산해보면 NAS: 15W, NAS용 하드디스크(4T): 4W~5W\n하드디스크가 2개들어가니 총 25W를 사용한다고 가정하면 한달 전기 소비량은\n25W x 24(시간) x 30(일) = 18000Wh = 18kWh 정도 되네요.\n네이버 전력 계산기에서는 18kWh만 넣으니 값이 이상해서 변화가 없을 정도로 미미한가 봅니다..\n한전 전기요금 계산기를 이용해 계산해보니 한달에 얼추 2천원이네요.\n23년 12월 기준 한달에 200kWh 미만을 사용하니 누진세도 없고.. 이 정도면.. NAS를 장난감으로 쓰는 것도 좋다고 생각합니다.\n사실 이러한 전기 요금에 대해 신경 쓰고 있지 않았지만, 궁금해서 계산해 봤습니다. :D..\nSSH 접속과 관련하여 NAS도 SSH로 접속하여 CMD창으로도 도커 이미지 및 컨테이너를 생성할 수 있습니다.\n공식 이미지가 아닌 경우는 위와 같은 방법으로 SSH 접속 포트(22는 위험하니 다른..)를 열고 방화벽(개인 접속 ip 한정으로)을 허용하여 작업할 수 도 있습니다.\n한번은 NAS 설정이 제대로 안돼서 방화벽을 한 5분 정도 열어두니 어디선가 NAS로 접근 요청이 들어와서 아래와 같이 경고 메일이 온 적도 있었습니다.\n그렇기 때문에 NAS SSH 접속 포트는 22번이 아닌 특정 값으로 하는 것이 좋으며, 공유기의 포트포워딩을 할 때에도 꼭 필요한 포트만 오픈하는 것이 안전합니다.\nDocker MariaDB 설치 NAS에서는 패키지 중에 Docker Container를 제공하며, 외부 도메인을 이용할 수 있기 때문에 마음만 먹으면 개인용 웹서버 및 DB 등 다양한 서비스를 구축할 수 있습니다.\n이와 관련하여 예전에 작성한 Synology NAS로 Docker GitLab 설치하기와 유사합니다.\n우선 패키지 센터에서 mariadb의 이미지를 등록합니다. SSH로 접속하여 실제 도커 허브에서도 받을 수 있고, 쉽게 레지스트리에서 이미지를 다운 받을 수도 있습니다.\n정상적으로 받은 경우 아래와 같이 도커의 이미지 항목에 MariaDB가 추가됩니다. 추가로 이미지는 버전은 latest 보다는 특정 버전을 명시하는 것이 좋다 생각합니다.\nlatest로 받게 되면 최신 버전을 사용할 수 있어서 새로운 기능과 보안 업데이트를 빠르게 받을 수 있는 장점이 있습니다. 그렇지만, \u0026ldquo;latest\u0026quot;는 항상 최신 버전을 가리키기 때문에, 언제나 동일한 동작을 보장하지 않을 수 있습니다. 또한, 의존성이나 환경 설정이 변경될 수 있어 예기치 못한 문제가 발생할 수 있습니다.\n레지스트리에서 다운로드를 받은 뒤 아래와 같이 컨테이너를 생성해줍니다.\nDocker 내부의 포트는 기본포트로 3306을 지정하고, 외부에서 Docker로 접속하는 포트는 33306으로 지정했습니다.\n볼륨 설정의 값은 Docker DB에서 설정된 값을 NAS 저장소의 위치로 매핑시켜줍니다.\n데이터가 저장될 디렉터리를 생성(/docker/mariadb/data)하여 도커에 있는 /var/lib/mysql 저장 위치로 매핑하고, 마찬가지로 설정 파일이 저장될 위치도 생성(/docker/mariadb/config)한 뒤 도커에 있는 /etc/mysql/conf.d 로 저장되도록 설정합니다.\n컨테이너 환경은 기본적인 값은 설정돼 있습니다.\n아래와 같이 MYSQL_ROOT_PASSWORD 값을 지정해야 이후 컨테이너를 실행하면 root의 비밀번호로 로그인할 수 있습니다.\n만약 Timezone을 변경하고 싶다면 위와 같은 식으로 Key는 TZ 값은 Asia/Seoul로 지정하면 타임존을 한국시간(UTC-9)로 설정할 수 있습니다.\n이후 NAS를 통해 들어오는 방화벽을 허용해줍니다.\n만약 내부에서 쓰는 경우라면 공유기 포트포워딩이 필요없지만 외부로 사용할 경우에는 공유기도 포트포워딩이 필요합니다. 포트포워딩은 공유기 마다 다르기 때문에 설정이 다를 수 있습니다. 이전에 올린 Synology NAS로 Docker GitLab 설치하기에서 KT 공유기의 포트포워딩 방법도 함께 있으니 참고하시면 좋을 것 같습니다.\n이렇게 하시면 NAS를 이용해서 DB에 접속할 수 있습니다..!\n그런데 위와 같이 DB 설정을 마쳤지만, 간단한 데이터베이스 생성 및 테이블 생성하여 insert 테스트를 하니 생각보다 느린 현상이 있었습니다.\n장비의 문제인지 설정의 문제인지 정확하지 않지만 제 경우는 InnoDB 플러시 매개변수에서 innodb_flush_log_at_trx_commit의 기본값을 1에서 2로 변경했습니다.\n몇몇 답변으로는 innodb_buffer_pull 의 값을 변경하는 것이 좋다는 이야기도 있지만, 제 경우는 중요한 데이터를 저장하는게 아니라 위의 값을 수정하는 것으로 만족했습니다.\ninnodb_flush_log_at_trx_commit 이란 innodb_flush_log_at_trx_commit는 MySQL 데이터베이스의 InnoDB 스토리지 엔진에서 사용되는 설정 중 하나입니다.\n이 설정은 트랜잭션 커밋 시 로그 버퍼를 디스크에 언제 플러시할지를 결정합니다. 이 설정은 MySQL의 성능과 내구성 간의 트레이드오프를 조절하는 데 사용됩니다.\ninnodb_flush_log_at_trx_commit에는 세 가지 옵션이 있습니다\n0: 로그 버퍼는 트랜잭션 커밋 시마다 디스크에 플러시되지 않습니다. 대신 1초마다 한 번만 플러시됩니다. 이는 성능을 향상시킬 수 있지만, 시스템이 갑작스런 장애나 전원 손실로 인한 데이터 손실이 발생할 수 있습니다.\n1: 로그 버퍼는 각 트랜잭션 커밋 시마다 디스크에 플러시됩니다. 이는 데이터의 내구성을 높이지만, 플러시 작업이 성능에 영향을 미칠 수 있습니다.\n2: 로그 버퍼는 트랜잭션 커밋 시 디스크에 플러시되지 않습니다. 대신, 트랜잭션 데이터는 로그 파일 그룹에 쓰여질 때까지 메모리에 보관됩니다. 그 후 로그 파일 그룹은 주기적으로 디스크에 플러시됩니다. 이 옵션은 1과 0의 중간 지점으로 볼 수 있으며, 내구성을 높이면서도 일부 성능 향상을 제공할 수 있습니다.\n기본적으로 이 설정은 1로 설정되어 있습니다. 이 설정을 변경하려면 MySQL 설정 파일(my.cnf 또는 my.ini)에서 innodb_flush_log_at_trx_commit 값을 조정하고, MySQL을 재시작해야 합니다.\n이렇게 설정을 하면 아래와 같이 700ms -\u0026gt; 5ms 로 insert 속도가 향상된 것을 확인할 수 있습니다.\n이렇게 NAS안에서 Docker를 이용해 DB Setting을 하는 방법에 대해 알아봤습니다.\n참고 NAS에서 느린 DB Insert 셋팅 설정 변경 NAS Dokcer MariaDB Insert 느린 이유(Stackoverflow) ","permalink":"https://haservi.github.io/posts/devops/docker/nas-mariadb-setting/","summary":"개인용 NAS를 충분히 이용하지 못한다는 생각이 문득 들었습니다.\n기본적으로 제공하는 Photos, 파일 저장소 정도만 이용하며, Docker Gitlab 서버 배포 중이긴 하지만.. 그냥 배포중 입니다.\n이 정도도 충분하긴 하지만 조금 더 활용하면 좋지 않을까라는 생각을 하게 됐습니다.\n문득 생각해 보니 NAS에서 Docker를 사용할 수 있다는 것은 개인적으로 운용할 수 있는 장난감 서버로 최적이지 않을까라는 생각이 들었습니다.\n물론 아마도 많은 트래픽은 감당하지 못하더라도 개인적인 용도로 테스트 서버 정도는 만들 수 있지 않을까 생각됩니다.","title":"Synology NAS Docker MariaDB 설치하기"},{"content":"LwM2M과 Anjay의 통신이 간헐적으로 끊기는 현상이 발생하여 이와 관련하여 프로토콜의 개념에 대해 알아보고, 와이어샤크를 이용해 DTLS handshake를 확인한 내용입니다.\nLwM2M에 대해 LwM2M (Lightweight M2M)은 경량화된 기기 간 통신 프로토콜로서, IoT (Internet of Things) 기기와 서버 간의 효율적인 통신을 위해 설계되었습니다.\nLwM2M은 경량화된 프로토콜로, 리소스 제약이 있는 IoT 기기에서도 효율적으로 동작합니다. 작은 패킷 크기와 최소한의 대역폭을 사용하여 효율적인 통신을 제공합니다.\nLwM2M은 RESTful 아키텍처를 기반으로 하며, HTTP/CoAP 프로토콜을 사용하여 기기와 서버 간 통신을 지원합니다.\nAnjay에 대해 Anjay는 LwM2M 프로토콜을 구현한 오픈 소스 라이브러리로, C 언어로 작성되었습니다. 주로 임베디드 시스템 및 경량 IoT 장치에서 사용됩니다.\nAnjay는 임베디드 디바이스에서 CoAP(Constrained Application Protocol)을 구현하기 위한 오픈 소스 라이브러리입니다. CoAP는 저전력 비동기 통신 프로토콜 입니다. UDP를 기반으로 비동기 통신을 사용합니다. Anjay는 mbedTLS를 사용하여 보안 기능을 제공합니다.\nmbedTLS를 사용하여 보안 기능을 통합하는 것은 Anjay의 디바이스 측 보안 기능을 강화하는 데 도움이 되며, DTLS (Datagram Transport Layer Security)를 통한 CoAP 통신을 안전하게 구현하는 데 적합합니다.\nmbedTLS 란 mbedTLS는 오픈 소스의 암호 라이브러리로, TLS(Transport Layer Security) 및 SSL(Secure Sockets Layer) 프로토콜을 구현하는 데 사용됩니다.\nTLS 및 SSL은 네트워크 통신을 보안하고 데이터를 암호화하는 데 사용되는 프로토콜로, 주로 웹 서버 및 클라이언트 간의 안전한 통신을 제공하는 데 사용됩니다.\nmbed TLS는 C 언어로 작성된 라이브러리로, 경량이며 임베디드 시스템 및 리소스 제한된 환경에서도 사용할 수 있도록 설계되었습니다. 이 라이브러리를 사용하면 암호화, 디지털 서명, 인증 및 안전한 통신을 구현하는 데 도움을 줍니다.\nmbed TLS안에는 DTLS 1.2 기능이 포함돼 있습니다.\nRFC 9146의 문서에서는 DTLS 1.2에 연결 식별자를 추가하는 방법에 대한 표준이 정의돼 있습니다.\n연결 식별자를 CID라고 하며, 아래와 같이 연결 식별자의 형식과 사용 방법에 대한 예제가 나옵니다.\n예제는 아래와 같습니다.\n구현 과정 중 문제점 문제는 RFC 9146의 예제 문서대로라면 위와 같이 돼야 하는데 와이어 샤크로 확인했을 때는 위의 예제처럼 동작하지 않았습니다.\n공식 문서와 스택오버플로우, 구글링을 통해 확인해보니 결론적으로 LwM2M과 Anjay의 통신 설정을 문서를 참조하여 올바르게 설정 해야합니다.\n이렇게 Server(LwM2M)와 Client(Anjay)가 정상적으로 통신하면 아래와 같이 위의 예제 문서와 동일하게 출력한 걸 확인할 수 있습니다.\n위와 같이 Client에서는 ClientHello의 신호를 Server에 보내고 Server에서는 HelloVerifyRequest로 Client에 요청합니다.\nClient는 위 값을 받고 다시 Server에게 ConnectionID를 요청합니다. Server는 내부적으로 ConnectionId(c89be44b77a2)를 만들어서 Client에게 전달합니다.\n그렇게 ConnectionId(c89be44b77a2)를 받은 Client는 해당 값을 다시 Server에게 ConnectionId(c89be44b77a2)를 확인 받은 뒤에 해당 ConnectionId를 이용하여 통신을 합니다.\n위의 handshake 절차를 통해 정상적으로 연결을 유지할 수 있습니다.\n아래는 와이어 샤크로 통신한 내용의 세부 내용입니다.\nClinet(ClientHello) Server(HelloVerifyRequest) Client(ClientHello - CID 요청) Server(ServerHello - CID 제공) Client(Server에 해당 CID 재확인 요청) Server(인증 완료) Client(CID를 이용해 통신) 와이어 샤크를 실제로 자주 사용한 적은 없지만 네트워크 패킷을 분석하여 여러 상황에서 유용하게 쓸 수 있는 도구라고 생각됩니다.\n참고 DTLS 1.2 RFC 9146 문서 ","permalink":"https://haservi.github.io/posts/tips/wireshark-dtls-handshake/","summary":"LwM2M과 Anjay의 통신이 간헐적으로 끊기는 현상이 발생하여 이와 관련하여 프로토콜의 개념에 대해 알아보고, 와이어샤크를 이용해 DTLS handshake를 확인한 내용입니다.\nLwM2M에 대해 LwM2M (Lightweight M2M)은 경량화된 기기 간 통신 프로토콜로서, IoT (Internet of Things) 기기와 서버 간의 효율적인 통신을 위해 설계되었습니다.\nLwM2M은 경량화된 프로토콜로, 리소스 제약이 있는 IoT 기기에서도 효율적으로 동작합니다. 작은 패킷 크기와 최소한의 대역폭을 사용하여 효율적인 통신을 제공합니다.\nLwM2M은 RESTful 아키텍처를 기반으로 하며, HTTP/CoAP 프로토콜을 사용하여 기기와 서버 간 통신을 지원합니다.","title":"와이어 샤크를 이용해 DTLS1.2 handshake 확인하기"},{"content":"스프링 프로젝트 중 공통적인 처리에 대한 방법 및 코드 개선에 대한 내용에 대한 정리입니다.\n알림\n해당 글은 Spring으로 사내 프로젝트를 하면서 느낀 코드 개선 및 경험에 대한 내용입니다.\n여러 개발 블로그의 경험과 노하우가 담긴 글을 참조하며, 추가한 내용입니다.\n글의 내용이 정답이 아닐 수 있으며, 개인적인 생각으로 가볍게 읽어주세요. :D..\n프로젝트 코드 공통 처리 및 여러 Tips 참조링크 : Spring Guide - Directory\n최근 프로젝트의 구조는 아래와 같습니다.\n위와 같이 패키지를 domain과 global로 나누어 환경을 구축했습니다.\ndomain에서는 front의 화면과 유사하게 package를 설정했습니다.\n하지만 프로젝트의 시나리오가 자주 변경되고 각 시스템에서 공통적인 로직들이 많아지면서 중복 코드가 발생하게 되면서 구조를 조금 변경했습니다.\nbackend의 경우 시스템 저장소가 7개 정도가 되다보니 아무래도 중복 코드가 많이 발생했습니다.\n그래서 global은 모든 프로젝트(각각의 repository)를 동일하게 맞춘 후 multi module 또는 git submodule을 활용하여 관리하고 코드를 수정합니다.\n기존 global에 있는 시스템마다 조금 씩 다른 Spring Security 설정 Swaager 설정은 global에서 domain package로 이동 시켰습니다.\n또한, 하나의 Class 안에 시스템별 Inner Class가 있었던 부분이 있는데 코드를 유지관리하기가 힘들어서 전부 분리했습니다.\ndomain에서는 시스템 별 API 구조 포멧이 동일한 경우 front의 component개념과 동일하게 다른 backend 저장소에서도 해당 package를 복사하여도 import 경로 충돌이 없도록 구조를 맞추어 작업을 하게 되니 조금 더 공수가 줄어드는 효과가 있습니다.\nResponse Template에 대한 처리 참조링크: Response를 객체에 담아 반환하기\n참조링크: Spring Guide - Exception 전략\nFront에 제공하는 API의 통일성을 위하여 API 제공 시에 일관된 구조로 제공하기 위해 처음 의도는 정상적으로 API의 템플릿과 오류 및 유효성 처리에 대한 템플릿을 구분하여 처리합니다.\n정상 템플릿 1 2 3 \u0026#34;success\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;\u0026#34; 에러 템플릿 1 2 3 4 \u0026#34;success\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;error_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;error_list\u0026#34;: \u0026#34;\u0026#34; 위와 같은 템플릿으로 backend에서는 정상인 경우 controller에서 return 해버리고 비정상적인 경우 @valid에서 죽거나, error를 throw합니다.\n이렇게 구현하면 아래와 같이 controller에서 바로 로직을 처리할 수 있습니다.\n1 2 3 4 @PostMapping public SingleResult\u0026lt;TempManageResponse\u0026gt; getTempList(@Valid @RequestBody TempRequest request) { return responseService.getSingleResult(tempManageService.getTempList(request), TEMP_SELECT_SUCCESS); } 에러의 경우 처리는 아래와 같습니다. 이후 ExceptionHandler로 빠진다음 여기서 error template 함수를 통해 에러 메시지를 반환합니다.\n1 2 Temp temp = tempRepository.findBySnoAndUseYn(request.getTempSno(), SEARCH_USE_YN) .orElseThrow(() -\u0026gt; new EntityNotFoundException(TEMP_NOT_FOUND)) 이렇게 하면 에러에 대한 처리를 핸들링 할 수 있으니 필요에 의해 맞출 수 있습니다.\nentity에서 enum을 써야할 경우 참조링크: Legacy DB의 JPA Entity Mapping (Enum Converter 편)\nenum 처리는 약간 고민이 드는 점이 있지만 enum의 경우도 정말 잘 사용한다면 여러 상태를 직관적이고 쉽게 처리하고 화면과 상태를 한번에 처리할 수 있기에 장점이 있습니다.\n단점이라면 조금 학습을 해야하며, 종종 enum을 이용한 entity를 처리를 하면 다른 시스템에서 비슷한 시스템이지만 entity 정의가 달라서 코드 로직이 다른 경우입니다.\n예를 들어 아래의 entity가 있다고 하면,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Convert(converter = AlarmConverter.class) @Comment(\u0026#34;100:알림-일반, 200:알림-정상, 300:알림-경고, 400:알림-심각\u0026#34;) @Column(name = \u0026#34;alarm_code\u0026#34;) private AlarmStatus alarm; ... @Getter public enum AlarmStatus implements EnumType { ALARM(100, \u0026#34;알림\u0026#34;, 0), NORMAL(200, \u0026#34;정상\u0026#34;, 0), WARNING(300, \u0026#34;경고\u0026#34;, 1), FATAL(400, \u0026#34;심각\u0026#34;, 2), ; private final int code; private final String level; private final int levelCode; ... } 1 2 3 @Comment(\u0026#34;100:알림-일반, 200:알림-정상, 300:알림-경고, 400:알림-심각\u0026#34;) @Column(name = \u0026#34;alarm_code\u0026#34;) private int alarm; 이렇게 다른 시스템에서 정의한 entity가 다른 경우 관련된 로직도 달라집니다.\n간단한 예로 해당 entity의 상태값을 조회할 때도 entity에 enum을 정의한 경우 아래와 같이\n1 2 3 4 5 6 7 8 9 10 @QueryProjection public NotificationsData(Long notiSno, NotificationsStatus status, String equip, LocalDateTime dateTime, String value, NotificationsConfirmStatus confirmationStatus) { this.notiSno = notiSno; this.level = status.getLevel(); this.equip = equip; this.dateTime = dateTime; this.value = value; this.confirmationStatus = confirmationStatus.getDesc(); } enum이 상태를 알기에 세부적으로 지정한 정보를 바로 가져올 수 있습니다.\nentity의 단일 타입으로 설정하면 enum에서 정의하지 못한 값을 상수로 정의 후 조건문으로 확인하는 로직이 필요합니다.\n하지만 이것도 정답이 있는 것이 아니라 프로젝트의 복잡도와 어떻게 하는게 더 쉽고 효율적인지에 따라 상황에 맞게 팀내에서 잘 조율해서 해야 된다고 생각합니다.\nDto 및 Optional은 잘 사용하기 관령링크: Optional에 대해\nbackend의 controller의 역할은 frontend에서 들어온 값의 유효성 처리와 service 로직에 필요한 값을 제공하거나, 반대로 frontend에 데이터를 제공하는 경우라 생각합니다.\n여러 블로그를 보면 dto는 controller와 service까지만 관여하는게 좋다고도 하는데 QueryDSL을 이용하므로 dto는 repository 까지 들어가는 경우도 종종 있을 수 있다고 생각합니다.\n이러한 부분은 유연하게 가면 될 것이라 생각됩니다.\n관리할 수 없는 코드는 삭제 처음 Backend를 구성할 때는 swagger2를 적용하고 front 외주 개발자 분과 API에 대한 기능을 명세했었습니다.\nswagger2에서는 실시간으로 backend api를 확인할 수 있지만, 그 때에 이슈 및 요청사항 관리를 어떻게 할지 고민중에\n어떤 API가 변경됐는지를 swagger안에 html을 만들어서 명세 했던적이 있습니다.\n1 2 3 4 5 6 7 8 9 10 private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\u0026#34;title\u0026#34;) .version(\u0026#34;1.01\u0026#34;) .description(\u0026#34;설명\u0026#34;) .license(\u0026#34;변경이력 \u0026#34;) .licenseUrl(\u0026#34;/version-history.html\u0026#34;) .build(); } 위와 같이 설정 후 static에 github style을 적용 후 html에 변경 이력을 관리했습니다.\n문제는 회의 후 수정사항이 증가하면 위의 변경이력 또한 갱신해줘야 하는데 일을 하기 위해 일을 만드는 거라 느껴졌습니다.\n지금은 Gitlab에서 CI/CD와 각 시스템마다 Issue를 처리하고 있지만, 이슈에 대해 이슈 트래킹 도구(Jira or Trello or Gitlab or Notion 등)를 미리 이용했다면 더 좋았을 거라 생각됩니다.\n클래스 역할 코드는 각 클래스의 역할에 맞게 코드를 분리하면 좋다고 생각합니다.\n예를 들어, 회원가입을 하는 경우 controller에서는 입력값에 대한 유효성 처리, service에서는 db와 연계된 예외사항 및 로직 처리, repository는 실제 저장할 쿼리 정도로 기준을 잡아서 처리합니다.\nDto에서 유효성을 처리하는 방법은 아래와 같으며, 컨트롤러에서는 아래와 같이 처리하면 좋습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Controller public CommonResult updateUser(@Valid @RequestBody UserUpdateRequest request) { userManageService.updateUser(request); return responseService.getSuccessResult(CommonMessage.USER_UPDATE_SUCCESS); } Request Dto @Getter @NoArgsConstructor(access = AccessLevel.PRIVATE) @ApiModel(value = \u0026#34;사용자 수정 요청 정보\u0026#34;) public class UserUpdateRequest { @NotBlank(message = \u0026#34;이름을 입력하세요.\u0026#34;) private String name; @Email(message = \u0026#34;유효한 이메일 주소를 입력하세요.\u0026#34;) private String email; } 위와 같이 지정하면 위에서 지정한 Global Exception으로 해당 valid가 빠지면서 에러 템플릿에서 지정한 포맷으로 에러 사유를 볼 수 있습니다.\n이 밖에도 필요에 따라 페이징 처리, 다국어 처리, DB 이중화 등도 잘 설정해 놓으면 쉽게 이용하여 쓸 수 있을 것이라 생각합니다.\n","permalink":"https://haservi.github.io/posts/spring/spring-project-structure-proecess/","summary":"스프링 프로젝트 중 공통적인 처리에 대한 방법 및 코드 개선에 대한 내용에 대한 정리입니다.\n알림\n해당 글은 Spring으로 사내 프로젝트를 하면서 느낀 코드 개선 및 경험에 대한 내용입니다.\n여러 개발 블로그의 경험과 노하우가 담긴 글을 참조하며, 추가한 내용입니다.\n글의 내용이 정답이 아닐 수 있으며, 개인적인 생각으로 가볍게 읽어주세요. :D..\n프로젝트 코드 공통 처리 및 여러 Tips 참조링크 : Spring Guide - Directory\n최근 프로젝트의 구조는 아래와 같습니다.\n위와 같이 패키지를 domain과 global로 나누어 환경을 구축했습니다.","title":"Spring 프로젝트 구조 및 공통 코드 처리 방법"},{"content":"프로젝트를 하다보면 성능 개선을 위해 어느 쿼리가 얼마나 걸리고, 어떻게 쿼리를 호출하는지 확인해야 할 경우가 있습니다.\nJPA QueryDSL을 이용할 때 여러 조인과 entity의 관계를 정의하다 보면 생각하지 못한 부분에서 속도가 매우 느린 경우도 있고, 대용량으로 데이터가 들어오면 잘 되던 쿼리가 느려질 때도 있습니다.\n이럴때 p6spy를 이용하여 쿼리를 보기 좋고, 얼마나 걸리는지 확인할 수 있는 방법에 대해 정리했습니다.\n위의 저장소에서 쿼리를 로그에 출력할 수 있는 간단한 h2 CRUD 예제 코드를 작성했습니다.\n위의 예제를 실행하면 아래와 같이 쿼리를 수행함을 확인할 수 있습니다.\np6Spy는 기존 코드의 변경 없이 SQL 로그를 출력해주는 프레임워크 입니다.\n주요 포인트는 p6Spy에서 제공하는 인터페이스 중 MessageFormattingStrategy 파일을 상속 받아 해당 메서드를 override 하여 사용합니다.\n아래의 사진과 같이 전략 패턴(Strategy Pattern)을 이용하여 프로그램 런타임 시 기존의 @PostConstruct를 사용하여 미리 정의된 formatMessage를 이용합니다.\n공식 문서에서 제공하는 많은 기능 중 필요한 기능만 spy.properties에 정의합니다.\n1 2 3 appender=com.p6spy.engine.spy.appender.Slf4JLogger logMessageFormat=com.p6spy.engine.spy.appender.CustomLineFormat customLogMessageFormat=| %(executionTime) ms | %(sql) 기본적으로 application.yml에서 쿼리 로그를 ON/OFF 할 수 있습니다.\n1 2 3 4 decorator: datasource: p6spy: enable-logging: true 위와 같이 설정을 하고 P6SpySqlFormatterConfig 클래스 파일에서 시간 초과 기준을 정하면 쿼리의 실행 속도 및 수행한 쿼리를 쉽게 확인할 수 있으며, 어디에서 문제가 발생했는지 쉽게 확인할 수 있으니, 쿼리 성능 개선을 조금 더 편하게 할 수 있을 것이라 생각합니다.\n참고 P6Spy 쿼리 로그 출력하기 [Spring Boot JPA] P6Spy 활용해 쿼리 로그 확인하기 p6Spy 공식문서 ","permalink":"https://haservi.github.io/posts/spring/p6-spy-query-log/","summary":"프로젝트를 하다보면 성능 개선을 위해 어느 쿼리가 얼마나 걸리고, 어떻게 쿼리를 호출하는지 확인해야 할 경우가 있습니다.\nJPA QueryDSL을 이용할 때 여러 조인과 entity의 관계를 정의하다 보면 생각하지 못한 부분에서 속도가 매우 느린 경우도 있고, 대용량으로 데이터가 들어오면 잘 되던 쿼리가 느려질 때도 있습니다.\n이럴때 p6spy를 이용하여 쿼리를 보기 좋고, 얼마나 걸리는지 확인할 수 있는 방법에 대해 정리했습니다.\n위의 저장소에서 쿼리를 로그에 출력할 수 있는 간단한 h2 CRUD 예제 코드를 작성했습니다.","title":"P6Spy를 이용하여 로그 출력하기"},{"content":"토비의 스프링 저자로 유명한 토비님이 인프런에 강의를 만드셔서 수강해봤습니다.\n인프런 강의 중 김영한 님의 강의가 실제 실무에 큰 도움이 된 것 같다면, 토비님의 강의는 스프링 부트에 대해 조금 더 깊이 있게 알아보는게 목적이었던 것 같습니다.\n기존 강의에서는 Spring Boot 2.7과 jdk 11로 했지만 학습 코드는 Spring Boot 3.1.1과 jdk 17로 적용해서 클론 코딩을 진행하며 버전이 달라지면서 발생한 문제와 팁을 정리했습니다.\n강의에서 나온 프로그램 추천 sdkman: jdk 및 여러 sdk들의 버전을 쉽게 변경할 수 있도록 해준다.\nWrap: AI가 내장된 터미널(다양한 기능 있음)\nhttpie: 터미널에서 간단한 api 응답 요청이 가능하다.\n1 http -v \u0026#34;:8080/hello?name=Spring Code Style은 intellij-java-google-style.xml로 적용했습니다.\n관련 링크 입니다.\n강의 클론 코딩 중 발생한 이슈 버전이 달라서 발생한 문제\nspring boot 3.1.1을 적용하면서 @RequestMapping이 있어도 스프링 컨트롤러로 인식하지 않는 현상이 있습니다.\n@RestController, @Controller 애노테이션이 있어야 스프링 컨트롤러로 인식합니다.\n스프링 boot 3.0부터는 클래스 레벨의 핸들러 감지 대상이 @Controller만 포함 됨 Github Issue 변경 사항 API를 통한 테스트 중 port가 안맞는 문제\n1 2 org.springframework.web.client.ResourceAccessException: I/O error on GET request for \u0026#34;http://localhost:8080/hello\u0026#34;: Connection refused ... 와 같은 에러 발생하여 테스트 클래스 상단에 @SpringBootTest(webEnvironment = WebEnvironment.DEFINED_PORT) 어노테이션 추가 -\u0026gt; 관련 링크\njetty를 config로 지정할 때 아래와 같은 에러가 발생한 경우\n1 2 3 4 5 ... at tobyspring.helloboot.HelloBootApplication.main(HelloBootApplication.java:15) ~[classes/:na] Caused by: java.lang.NoClassDefFoundError: jakarta/servlet/http/HttpSessionContext at org.eclipse.jetty.servlet.ServletContextHandler.newSessionHandler(ServletContextHandler.java:339) ~[je ... spring-boot-starter-jetty 의존성 관련된 문제로 판단된다. Spring Boot 3에서는 Jakarta Servlet 6.0.0이고, spring-boot-starter-jetty는 Jakarta Servlet 5.0.0이라 발생하는 문제로 판단 일단 해결하기 위해서 build.gradle에 종속성 하나를 더 추가 했었습니다.\n1 implementation group: \u0026#39;org.eclipse.jetty\u0026#39;, name: \u0026#39;jetty-servlet\u0026#39;, version: \u0026#39;11.0.15\u0026#39; 조금 더 찾아보니 스프링부트에 이슈로 있으며, build.gradle에서\n1 ext[\u0026#39;jakarta-servlet.version\u0026#39;] = \u0026#39;5.0.0\u0026#39; 를 명시적으로 써주면 된다고하여 수정했습니다.\n버전이 안맞는 문제 링크\nHikari-cp 설정이 잘안되는 현상\n1 implementation(\u0026#39;com.zaxxer:HikariCP:4.0.3\u0026#39;) // 이렇게 하니 잘됨.. 환경 설정을 통해 env 우선 순위를 정할 수 있다 위와 같이 설정한 경우 기존 application.properties보다 더 높은 우선순위를 지정할 수 있다.\nVM Option \u0026gt; Environment variables \u0026gt; application.properties 순으로 우선순위가 정해진다.\n추가 팁 gradle 라이브러리 디펜더시 확인\n1 ./gradlew dependencies --configuration compileClasspath 스프링 부트 스타터 공식 문서\n코드에서 Comaparator.java 인터페이스를 보면 좋다고 함\n","permalink":"https://haservi.github.io/posts/review/inflearn-toby-spring/","summary":"토비의 스프링 저자로 유명한 토비님이 인프런에 강의를 만드셔서 수강해봤습니다.\n인프런 강의 중 김영한 님의 강의가 실제 실무에 큰 도움이 된 것 같다면, 토비님의 강의는 스프링 부트에 대해 조금 더 깊이 있게 알아보는게 목적이었던 것 같습니다.\n기존 강의에서는 Spring Boot 2.7과 jdk 11로 했지만 학습 코드는 Spring Boot 3.1.1과 jdk 17로 적용해서 클론 코딩을 진행하며 버전이 달라지면서 발생한 문제와 팁을 정리했습니다.\n강의에서 나온 프로그램 추천 sdkman: jdk 및 여러 sdk들의 버전을 쉽게 변경할 수 있도록 해준다.","title":"Inflearn 토비의 스프링 부트 강의 후기"},{"content":"이전에 진행 중인 프로젝트에서는 Code Convention이 지켜지지 않아 코드 정렬이 좋지 않은 경우가 있었습니다.\n이는 여러 담당자를 거치면서 코드의 가독성이 떨어지고 코드 수정 이후 git history를 확인하기 어렵게 만들었습니다.\n이 문제를 해결하기 위해서는 모든 코드를 동일한 Format으로 변경하는 설정을 해야 합니다. 일반적으로 Prettier와 EsLint는 함께 사용됩니다.\nESLint는 코드의 퀄리티를 보장하도록 도와주는 도구입니다. 일관성 있는 방식으로 코드를 구현할 수 있게 됩니다. 예를 들어 함수를 표현할 때 function을 이용할지 arrow를 이용할지 등을 정할 수 있습니다.\nPrettier는 코드 구현과는 관련없이 일관된 방식의 코드 포맷을 정리하게 도와주는 도구입니다. 띄어쓰기 4칸 또는 2칸 등과 같은 것을 일관되게 적용합니다.\n해당 프로젝트 이전 코드의 코드 포맷을 맞추고 이후 코드 수정에서 일관성을 지키기 위해 Prettier만을 이용하여 간단하게 정의하고 추후 변경된 코드는 .prettierrc 설정으로 일관성 있는 코드 작성을 유지하도록 설정하도록 합니다.\n다음은 Prettier만을 이용하여 프로젝트 코드포맷을 변경하는 방법입니다.\nPrettier 설정 방법 우선 VS Code를 기준으로 설정합니다.\n확장관리자에서 Pretiier - Code formatter와 Vue Language Features (Volar)를 설치합니다.\n코드 적용을 하고 싶은 프로젝트 최상단에 아래와 같은 .prettierrc파일을 생성합니다. 아래의 옵션 외에 다양한 옵션이 공식 홈페이지에\n문서화돼 있으므로 참조할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;singleQuote\u0026#34;: true, // 작은 따옴표 사용(문자열) \u0026#34;semi\u0026#34;: true, // 문장 뒤에 세미콜론 추가 \u0026#34;useTabs\u0026#34;: false, // tab 허용 안함 \u0026#34;tabWidth\u0026#34;: 2, // tab 길이 2칸 \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, // 배열, 객체 속성에서 마지막 요소 컴마 사용 \u0026#34;printWidth\u0026#34;: 120, // 코드의 블록 너비 \u0026#34;bracketSpacing\u0026#34;: true, // 객체 리터럴 공백 추가 { foo: bar } \u0026#34;overrides\u0026#34;: [ { \u0026#34;files\u0026#34;: \u0026#34;*.vue\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;parser\u0026#34;: \u0026#34;vue\u0026#34; } ] // vue 파일의 경우 vue parser로 구문 분석기 지정 } command + , 또는 ctrl + ,를 이용해 설정으로 이동 후 json script로 이동하여 아래와 같이 스크립트를 추가해줍니다.\nVue의 경우 prettier의 자동완성이 설정되지 않아 이렇게 명시적으로 넣어줘야 합니다.\n1 2 3 \u0026#34;[vue]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; } 위 설정을 마친 후 기존에 있던 vue와 js파일 또는 ts가 있다면 아래에 ts를 추가하여 명령어를 src위치에서 쓰면 모든 파일이 한번에 수정할 수 있습니다.Title\n1 npx prettier --write **/*.{js,vue} # 이게 안되면 {} 제거 후 각각 실행 VsCode에서 저장 시 자동으로 포맷을 저장하도록 설정합니다. command + , 또는 ctrl + ,을 눌러 설정창에서 Format on Save를 선택합니다.\n이렇게 한번 지정하면 이후에는 코드 포맷에 대한 고민을 조금은 덜 수 있습니다.\n참조 Prettier 문서 ","permalink":"https://haservi.github.io/posts/tips/vue-code-convetion/","summary":"이전에 진행 중인 프로젝트에서는 Code Convention이 지켜지지 않아 코드 정렬이 좋지 않은 경우가 있었습니다.\n이는 여러 담당자를 거치면서 코드의 가독성이 떨어지고 코드 수정 이후 git history를 확인하기 어렵게 만들었습니다.\n이 문제를 해결하기 위해서는 모든 코드를 동일한 Format으로 변경하는 설정을 해야 합니다. 일반적으로 Prettier와 EsLint는 함께 사용됩니다.\nESLint는 코드의 퀄리티를 보장하도록 도와주는 도구입니다. 일관성 있는 방식으로 코드를 구현할 수 있게 됩니다. 예를 들어 함수를 표현할 때 function을 이용할지 arrow를 이용할지 등을 정할 수 있습니다.","title":"Vue Prettier로 코드 정렬하기"},{"content":"Udemy 강의중 Docker \u0026amp; Kubernetes 강의를 수강 후 내용 정리 및 리뷰를 작성합니다.\n우선 Udemy는 외국 강의가 많고, 한달에 여러번 할인을 하기에 괜찮은 강의가 있으면 미리 결재해 놓는게 좋습니다.\n강의 후기 Udemy 강의는 할인 가격이 저렴해서 그런지 외국 강의라 그런지 수강률이 높지 않은데 해당 강의는 제가 Udemy에서 수강했었던 강의 중 만족도는 상위권이라 생각합니다.\n주로 Backend 개발자 입장에서 해당 강의로 얻을 수 있는 점은 Docker와 Docker-compose를 이용해 개발 생산성을 높일 수 있다 생각합니다.\n물론 Kubernetes도 충분히 의미가 있었지만 강의에서 그렇게 깊게 다루진 않은 것 같습니다.\n실무에서도 backend 서버 테트를 위해서 종종 front 코드를 열때도 docker-compose를 이용하면 좋습니다.\n위와 같이 front 프로젝트를 소스코드만 바인드 마운트로 설정 후 Docker로 프로젝트를 정의하고, docker-compose를 볼륨 이용해 여러 front 프로젝트를 관리하면 더 이상 node version과 다양한 설정에 대한 고민을 하지 않아 좋습니다.\n강의 내용 정리 클론 코딩을 하며 강의에서 들었던 내용 중 몇몇 내용을 정리했습니다.\n도커 명령어 관련 정보 -p 포트 설정 ex) 3000:80 -\u0026gt; host port:container port -d `detached mode로 도커 컨테이너를 백그라운드에서 실행 --name 컨테이너 이름 지정 --rm 피드백이 중지 시 자동으로 컨테이너 제거 -v 볼륨 지정 명명된 볼륨은 컨테이너가 제거하지 않음 :ro 읽기 전용 -f: 도커 파일명을 지정할 수 있음 도커 내부에서 나의 로컬 호스트를 아는 방법\n1 localhost:port -\u0026gt; host.docker.internal:port docker 명령어 예제\n1 docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback -v $(pwd):/app -v /app/node_modules feedback-node 바인드 마운트 단축키\n프로젝트 경로에서 /src만 바인드 마운트 후 docker의 /app 폴더에 바인드 마운트\n1 2 macOS/Linux: -v$(pwd)/src:/app/src Windows: -v ${PWD}/src:/app/src 도커 컨테이너 및 이미지 한번에 제거\n1 2 3 4 docker container prune docker image prune # 이게 안되면 아래거로 docker rmi $(docker images -a -q) docker volume prune Docker Compose 도커 컴포즈 실행\n-d: detached 모드 up \u0026ndash;build: 이미지를 리빌드 1 docker-compose up -d 도커 컴포즈 종료\n-v: 볼륨과 함께 제거 1 docker-compose down -v docker.prod 설정 관련 Docker CMD에서 CMD [ \u0026quot;npm\u0026quot;, \u0026quot;start\u0026quot; ]값은 기본적으로 package.json의 스크립트에 있는 start 명령어를 실행한다.\n이외에는 가운데에 CMD [ \u0026quot;npm\u0026quot;, \u0026quot;run\u0026quot;, \u0026quot;start\u0026quot; ]을 추가해서 스크립트 실행해야한다.\nnginx docker menual을 참조하여 빌드된 파일의 위치를 지정해야 한다.\n멀티스테이지 빌드로 하나의 도커파일에 여러 이미지를 빌드할 수 있다.\n-f: 도커 파일명을 지정할 수 있음\n1 docker build -f frontend/Dockerfile.prod ./frontend 기타 명령어 컨테이너 제거\n1 docker rm [mycontainer] 이미지 제거\n1 docker rmi [myimage] 볼륨 확인\n1 docker volume ls 볼륨 제거\n1 docker volume rm [volume name] AWS에 대해 AWS는 Amazon Web Services의 약어로, 아마존닷컴이 제공하는 클라우드 컴퓨팅 서비스 플랫폼입니다. AWS는 컴퓨팅, 스토리지, 데이터베이스, 분석, 인공지능, IoT 및 기타 다양한 서비스를 제공하여 기업이나 개인이 필요로 하는 IT 인프라를 클라우드 기반으로 구축하고 관리할 수 있도록 도와줍니다. 아래 링크는 AWS에 대한 강사분의 영상 설명 링크입니다.\nAWS에 대한 유튜브 영상 링크\n도커 이미지 공식홈페이지 등록/업데이트/가져오기 도커 이미지 등록\n1 2 3 4 docker login # 로그인 docker build -t node-dep-example . # 이미지 생성 docker tag node-dep-example [docker id]/node-dep-example # 태그 지정 docker push [docker id]/node-dep-example # 푸시 도커 이미지 업데이트 방법\n1 2 3 docker build -t node-dep-example . # 동일한 태그로 등록 docker tag node-dep-example [docker id]/node-dep-example:0.1 # 버전 명시 docker push [docker id]/node-dep-example:0.1 # 푸시 도커 이미지 가져오기\n1 docker pull [docker id]/node-dep-example:0.1 팁으로 도커 이미지의 변화없이 같으면 이미지의 이름은 다르지만 이미지ID가 같아서 삭제가 안되는 경우가 있다. 이럴 때는 아래와 같이 태그를 명시해서 제거할 수 있다.\n1 docker rmi [이미지이름:tag] 쿠버네티스 쿠버네티스에서 사용자가 유의해야 할 것은 클러스터와 노드 생성이다.\nmac apple arm 기준 설치\n1 brew install kubectl VitureBox 설치 후 minikube 설치\n1 2 3 brew install minikube minikube start --driver=virtualbox # 이게 안되면 minikube start --driver=docker # 이거 설치 확인\n1 minikube status 대시보드 확인\n1 minikube dashboard 쿠버네티스의 주요 개념 중 하나는 파드(Pod)입니다.\n파드는 쿠버네티스에서 실행되는 가장 작은 배포 단위이며, 일반적으로 파드는 하나 이상의 컨테이너로 구성되며, 이 컨테이너들은 동일한 호스트에서 동작하고 동일한 네트워크 네임스페이스와 IP 주소를 공유합니다.\nkubectl api-resources를 입력하면 kubectl의 명령어를 어느 정도 확인 할 수 있습니다.\nPod란?\nKubernetes(K8s)에서 Pod는 가장 작은 배포 단위이며, Pod는 K8s 클러스터 내에서 실행되는 하나 이상의 컨테이너 그룹입니다. Pod는 논리적인 호스트 또는 노드에서 실행되며, 컨테이너, 저장소, 네트워크 리소스 등을 공유할 수 있습니다.\n각각의 Pod는 고유한 IP 주소를 가지며, 포트 공간을 공유하여 서로 통신할 수 있습니다. Pod는 주로 관련된 서비스를 함께 실행하기 위해 사용되며, 서비스 디스커버리, 로깅, 모니터링 등을 위한 사이드카 컨테이너를 함께 포함할 수도 있습니다.\nPod는 일시적인 존재이며, 언제든지 새로운 Pod로 교체될 수 있으며, 이는 확장성과 견고성을 높이기 위한 K8s의 핵심 개념 중 하나입니다.\n노드(Node)는 K8s 클러스터의 물리적 또는 가상의 서버입니다. 노드는 Pod를 실행하는 호스트로 사용되며, 컨테이너 런타임(예: Docker)과 K8s 에이전트가 설치되어 있습니다. 각 노드는 일련의 리소스(CPU, 메모리, 디스크 등)를 제공하고, Pod를 스케줄링하여 실행합니다. 여러 개의 Pod는 여러 노드에 분산되어 실행될 수 있습니다.\n","permalink":"https://haservi.github.io/posts/review/udemy-k8s-docker/","summary":"Udemy 강의중 Docker \u0026amp; Kubernetes 강의를 수강 후 내용 정리 및 리뷰를 작성합니다.\n우선 Udemy는 외국 강의가 많고, 한달에 여러번 할인을 하기에 괜찮은 강의가 있으면 미리 결재해 놓는게 좋습니다.\n강의 후기 Udemy 강의는 할인 가격이 저렴해서 그런지 외국 강의라 그런지 수강률이 높지 않은데 해당 강의는 제가 Udemy에서 수강했었던 강의 중 만족도는 상위권이라 생각합니다.\n주로 Backend 개발자 입장에서 해당 강의로 얻을 수 있는 점은 Docker와 Docker-compose를 이용해 개발 생산성을 높일 수 있다 생각합니다.","title":"[Udemy] Udemy K8s Docker 강의 후기"},{"content":"6개월 프로젝트로 Node.js를 처음 하면서 만났던 여러 문제들을 처리한 내용을 공유합니다.\n약 4개월 정도는 backend 개발을 했던 것 같고, 이후 다른 시스템과 함께 맞춰서 프로젝트를 마무리 했던 것 같습니다.\nbackend에서는 기본적인 CRUD 기능과 유효성 처리, jwt 인증, 파일 업로드(이어올리기, siging작업 등), FOTA 캠페인 진행 등이 주요 내용입니다.\n프로젝트 기술 선택 Framework: express DB: MySQL 먼저 Node.js에서 유명한 프레임워크로 express와 nest.js가 있습니다.\n먼저 Spring Backend에 대한 경험으로 nest.js에 대해 고민했지만, npm trends 비교 및 express가 개발 속도 및 현재까지 사용한 사용자도 많기에 express로 선택했습니다.\nORM은 어느 정도의 진입장벽이 있다고 판단하여 typeorm의 기본적인 쿼리로 정도만 넣었으며, native query를 이용하여 동작하도록 설정 후 이후 리팩토링을 했습니다.\n개발 돌이켜보면 처음 한달에 삽질을 많이하고 그 뒤로는 어느 정도 프로젝트의 구조가 잡히니 기능 구현에 큰 어려움은 없었습니다.\n이후 다른 시스템 지원이 어려웠던 것 같았습니다. c, c++ 프로젝트 ㅠ..\n1월 1주차\nexpress 프로젝트 생성을 합니다. 음?? 그런데 기존에 찾아봤던 Node.js의 구조와 다르더군요. 무슨 bin폴더에서 www파일을 이용해서 빌드가 되는데 좀 마음에 안든다. VS Code에서 디버깅은 어떻게 해야하지?\n1월 2주차\njavascript는 대충 알겠다. 타입이 없어서 좀 마음에 안들지만 디버깅 주도 개발 하면 금방 개발이 되니 좋은것도 같다. Type ORM과 MySQL을 함께 쓸 때 native 쿼리를 쓸 경우는 어떻게 설정하고 release()는 꼭 해줘야 하네. 기본적인 CRUD는 어느 정도 처리할 수 있겠다.\n1월 3주차\nJavascript에서 Typescript로 코드를 변경했다. tsconfig를 통해 Typescript를 쓸 수 있나 보다. enum을 지양하네? 이유가 뭘까? 관련 링크 이 시기부터 이펙티브 타입스크립트 책을 함께 읽었습니다. any 타입에 대한 이해 및 MVC 스타일로 작성할 때 DTO와 Entity에 대한 처리 방법(class-transformer) 반복적인 API 생성 및 유효성 처리 작업 PM2 및 DB 커넥션 이슈 등을 만나게 됨 대용량 파일 처리 시 동작 방식에 대한 이해(비동기로 많이 쪼개서 작업하는게 빠르다?) busboy 라이브러리의 close와 finish를 같이 쓰면 linux에서 빌드 시 오류가 발생할 수 있다. req.end 관련 문제 같음 프로젝트 진행하면 만난 문제점들 express와 nest.js 중 어떤게 프로젝트에 좋을지\n기간이 짧은 경우 express를 사용하는게 좋지만, 유지보수 측면에서는 nest.js가 더 좋을 것도 같다. 해당 프레임워크 선택은 프로젝트 규모와 기능에 대한 검토가 필요함(빠르게 개발은 express가 좋다고 느낌) 프로젝트 구조는 어떻게 설계하는게 좋을지\n초반에 express-generator를 이용하여 프로젝트 생성(www폴더가 처음엔 뭔지 몰랐는데 이후엔 좀 거부감..) 자바스크립트를 이용해 기능별로 패키지 분리 이후 타입스크립트로 변경하여 전체 구조 변경(기본적인 nodejs backend 처럼 변경) router와 비슷한 개념을 controller로 파일명 변경(controller에서는 request 유효성 처리 및 response 템플릿 처리) service에서 여러 repository와 연동 및 비즈니스로직 데이터 가공(서비스 로직에 비즈니스로직이 들어가면 테스트코드 작성이 어렵다.) repository에서 orm 쿼리 또는 native쿼리로 service처리 DB연동 및 typeorm 적용 여부\nexpress는 mongusdb와 궁합이 좋다고 하지만 현재 프로젝트 기간 및 no-sql보다는 mysql를 선택 typeorm entity와 관련하여 synchronize 기능 제공(스프링은 ddl-auto 같다) 스프링 처럼 repository 로 orm 스럽게도 구현이 가능하지만 일정 및 n+1 및 fetch? 이슈 등이 있을 거라 생각하여 일단 간단한 쿼리는 orm 복잡한 쿼리는 native로 처리 후 orm 스럽게 리팩토링 진행 예정 타입스크립트에서 오버로딩은 안되는건가?\n타입스크립트에서는 타입과 런타임의 동작이 무관하기 때문에, 함수 오버로딩은 불가 swagger 문서화 처리\nexpress로 사용하는 경우 swagger에 관련된 코드를 그냥 다른 파일로 빼는게 가독성 측면에서 좋아보임 초반에 거부감이 많이 많이 들었지만, 좀 하다 보면 그래도 할만한 느낌 nest.js를 쓰면 코드 어노테이션으로 처리 가능 코드 실행 중 잘못된 호출 또는 로직 수행중에 exception 발생하면 서버가 죽음\n추후 PM2로 여러 스레드 작업 및 docker로 분리함 typeorm 사용 방법 및 nativequery와 함께 사용하는 방법\n타입스크립트 적용 방법\nC++ 소스코드를 typescript에 선언하고 사용하는 방법\nnode-addon 대용량 파일을 업로드하고 다운로드 하는 방법 및 문제점\n파일 업로드 시 busboy를 이용해 chunk값으로 이어올리기 기능 구현 request에 대한 유효성 체크 방법\nnpm 중 class-validation과 express-validation이 있다. class-valdaion의 경우 request dto에 어노테이션 을 선언해서 사용하고, express-validation은 라우터에서 처리한다. npm trends를 보면 class-validation을 더 많이 사용함 response 응답값에 대한 template 생성 및 유효성 처리를 공통적으로 하는 방법\n유효성이 실패한 경우 다양한 형태가 존재하며, 이것에 대한 함수를 나눠 처리함 async await의 올바른 사용법과 트랜잭션 처리\n쿼리 또는 함수의 응답값이 필요한 경우 await를 이용해 처리함 미들웨어와 유틸함수의 차이점\n추후 배포할 때 어떻게 하는게 좋을지 고민 필요\n대용량 파일 업로드(10GB 이상) 시 해당 파일 암호화 hash 방법 고민 필요\nfs.createReadStream을 이용하여 처리\ncreateFileSync의 경우 아래와 같은 에러 발생\n1 2 3 4 5 error: [package/file-upload: File size (12884910080) is greater than 2 GB {\u0026#34;code\u0026#34;:\u0026#34;ERR_FS_FILE_TOO_LARGE\u0026#34;,\u0026#34;stack\u0026#34;:\u0026#34;RangeError [ERR_FS_FILE_TOO_LARGE]: File size (12884910080) is greater than 2 GB\\n at new NodeError (node:internal/errors:372:5)\\n at tryCreateBuffer (node:fs:420:13)\\n at Object.readFileSync (node:fs:465:14)\\n at PackageService... 파일 업로드 이후 메타데이터를 추가해야하는데 어떻게 해야 할지 고민 필요\n요청에 따라 KISA SHA 256을 적용(Javascript 예제가 없어서 Java 또는 C++을 이용예정), 다른 암호화 라이브러리로 해도 될 것 같은데 확인 필요 cryto를 이용해서 hash처리(signing과 관련된 내용 확인 필요) createReadStream이 비동기이기 때문에 이를 위해 new Promise로 적용 파일 업로드와 동시에 hash 처리 하는 방법도 고민 필요(이러면 중간에 끊기면 hash를 어떻게 처리할지 고민 필요) Typescript에서 문자열 바이트코드 변환 확인\nTextEncoder() 함수 사용 any 타입에 대해서\nany 타입을 사용하면 타입 체커와 타입스크립트 언어 서비스를 무력화시킨다. any 타입은 진짜 문제점을 감추며, 개발 경험을 나쁘게 하며, 코드의 신뢰도를 떨어뜨린다. Worker Thread\n기존 프로젝트에서 C++ 로 처리해야 하는 로직이 있어 addon된 함수를 worker thread 방식으로 적용 Node는 요청을 받으면 현재 요청에 대한 다른 요청을 받을 수 없다. 이러한 처리를 효율적으로 하기 위해 Node는 이벤트 루프와 콜백 함수를 통해 비동기로 동작한다. console.log는 메인쓰레드에서 동작하므로 얘로 테스트 하면 안됨 파일 대용량 db업로드시\nbody Parser = 기본 허용치 100kb 이거를 늘려주면 된다.\n1 2 app.use(express.json({ limit: \u0026#39;50mb\u0026#39; })); app.use(express.urlencoded({ limit: \u0026#39;50mb\u0026#39;, extended: true })); 쿼리 동작중에 Cannot enqueue Query after fatal error.이런 에러가 발생\ndb의 시간 만료를 늘려주면 해결된다는 경우도 있습니다.링크 위와 같이 늘려줬었는데 종종 발생하여 반대로 시간 만료를 극단적으로 줄여서 에러를 확인할 수 있었습니다. 문제는 typeorm과 nativequery를 쓰기위해 repository 파일을 참조하는게 문제의 원인이었습니다. 조금 더 고민해야 할 것 대용량 파일 다운로드 시 효율적인 방법 header의 값에 Range를 할당하여 클라이언트에서 여러 호출을 하도록 지정할 수 있음참고 ","permalink":"https://haservi.github.io/posts/nodejs/start-nodejs/","summary":"6개월 프로젝트로 Node.js를 처음 하면서 만났던 여러 문제들을 처리한 내용을 공유합니다.\n약 4개월 정도는 backend 개발을 했던 것 같고, 이후 다른 시스템과 함께 맞춰서 프로젝트를 마무리 했던 것 같습니다.\nbackend에서는 기본적인 CRUD 기능과 유효성 처리, jwt 인증, 파일 업로드(이어올리기, siging작업 등), FOTA 캠페인 진행 등이 주요 내용입니다.\n프로젝트 기술 선택 Framework: express DB: MySQL 먼저 Node.js에서 유명한 프레임워크로 express와 nest.js가 있습니다.\n먼저 Spring Backend에 대한 경험으로 nest.js에 대해 고민했지만, npm trends 비교 및 express가 개발 속도 및 현재까지 사용한 사용자도 많기에 express로 선택했습니다.","title":"Nodejs 프로젝트 적응기"},{"content":"WSL에서 대용량 파일 처리(한사이클에 50GB..)를 하면서 안그래도 부족한 C드라이브 용량이 바닥이 났습니다.. ㅠㅠ..\nC드라이브를 늘릴 수는 없으니 급한대로 D드라이브 1TB로 변경 후 WSL Ubuntu를 D드라이브로 옮기기로 정했습니다.\nWLS에 대한 명령어는 wsl -h로 확인할 수 있습니다.\n아래의 사진처럼 wsl name을 확인 후 해당 name으로 우선 ubuntu를 정지합니다.\n1 2 wsl -l -v wsl -t [Name] # 특정 WSL 정지 제 경우는 Ubuntu-20.04 라는 Name이므로 해당 이름을 기준으로 커맨드를 작성했습니다.\nWSL 내보내기\n1 wsl --export Ubuntu-20.04 D:\\WSL\\ubuntu20.04\\ubuntu-20-04.tar 기존 WSL 리눅스 제거하기\n아래와 같이 명령어를 입력합니다.\n1 wsl --unregister Ubuntu-20.04 export한 tar파일 import\n2단계에서 내보냈던 압축파일을 import 합니다.\nwsl \u0026ndash;import [서비스명] [설치경로] [내보낸 파일 경로]\n1 wsl --import Ubuntu-18 D:\\WSL\\ubuntu18.04\\ D:\\WSL\\ubuntu18.04\\ubuntu-18-04.tar 사용자 기본 위치 설정\n위의 사진 처럼 리눅스 실행 시 기본 사용자를 지정하려면 아래와 같이 설정하시면 됩니다.\nwsl conf 파일 생성\n1 touch /etc/wsl.conf 기본 사용자 등록\n1 vim /etc/wsl.conf 파일 수정\n1 2 [user] default=home폴더안의사용자이름 이렇게 설정 기존에 내보내기로 만들었던 tar파일은 삭제하셔도 됩니다.\n급한대로 용량에 대한 압박이 조금은 해소됐네요. :D..\n참고 [Windows] WSL 리눅스 설치 경로 변경 ","permalink":"https://haservi.github.io/posts/tips/window-wsl-drive-change/","summary":"WSL에서 대용량 파일 처리(한사이클에 50GB..)를 하면서 안그래도 부족한 C드라이브 용량이 바닥이 났습니다.. ㅠㅠ..\nC드라이브를 늘릴 수는 없으니 급한대로 D드라이브 1TB로 변경 후 WSL Ubuntu를 D드라이브로 옮기기로 정했습니다.\nWLS에 대한 명령어는 wsl -h로 확인할 수 있습니다.\n아래의 사진처럼 wsl name을 확인 후 해당 name으로 우선 ubuntu를 정지합니다.\n1 2 wsl -l -v wsl -t [Name] # 특정 WSL 정지 제 경우는 Ubuntu-20.04 라는 Name이므로 해당 이름을 기준으로 커맨드를 작성했습니다.\nWSL 내보내기","title":"윈도우 WSL Ubuntu D Drive로 변경"},{"content":"netstat을 사용하기 위해서 우선 net-tools를 설치해야합니다.\n1 sudo apt install net-tools 설치 후 netstat -tulpn 를 입력하면 현재 열린 네트워크 포트와 해당 포트를 열어놓은 프로세스를 보여주는 도구입니다.\n여기서 각 옵션의 의미는 다음과 같습니다.\n-t: TCP 프로토콜 사용 포트 -u: UDP 프로토콜 사용 포트 -l: 포트를 열어놓은 프로세스 출력 -p: 프로세스 ID 출력 -n: 포트와 프로세스를 숫자로 출력 따라서 netstat -tulpn 명령어를 실행하면, 현재 열린 TCP/UDP 포트와 해당 포트를 열어놓은 프로세스의 정보를 확인할 수 있습니다.\n다른 방법으로는 ps -ef|grep [프로그램이름]으로도 찾을 수 있습니다.\n이 후 해당 PID를 제거 하고 싶은 경우 아래와 같이 kill [PID]를 입력하면 됩니다.\n","permalink":"https://haservi.github.io/posts/tips/ubuntu-port-kill/","summary":"netstat을 사용하기 위해서 우선 net-tools를 설치해야합니다.\n1 sudo apt install net-tools 설치 후 netstat -tulpn 를 입력하면 현재 열린 네트워크 포트와 해당 포트를 열어놓은 프로세스를 보여주는 도구입니다.\n여기서 각 옵션의 의미는 다음과 같습니다.\n-t: TCP 프로토콜 사용 포트 -u: UDP 프로토콜 사용 포트 -l: 포트를 열어놓은 프로세스 출력 -p: 프로세스 ID 출력 -n: 포트와 프로세스를 숫자로 출력 따라서 netstat -tulpn 명령어를 실행하면, 현재 열린 TCP/UDP 포트와 해당 포트를 열어놓은 프로세스의 정보를 확인할 수 있습니다.","title":"리눅스에서 활성화된 process 종료 방법"},{"content":"WSL 환경에서 DB 설정 방법에 대해 정리했습니다.\n우선 기본적으로 윈도우 환경이며, WSL을 이용해 우분투 18.04 버전을 설치합니다.\nmariadb-server 설치 및 실행 패키지를 최신으로 업데이트 합니다.\n1 2 sudo apt-get update sudo apt-get upgrade 우선 mariadb-server를 설치합니다.\n1 2 3 sudo apt install mariadb-server sudo mysql -u root -p # 실행 DB 저장소 경로 변경 방법 만약 db의 저장소를 변경하고 싶다면 아래와 같이 진행하면 됩니다.\n우선 db의 경로를 /home/data/mysql으로 가정하겠습니다.\ndb 접속 후 현재 db의 경로를 확인합니다.\n1 SELECT @@ datadir; db 정지\n1 sudo service mysql stop 저장소 위치 변경\n1 2 sudo mkdir -p /home/data/ # 폴더 생성 sudo rsync -av /var/lib/mysql /home/data/ # 기존 db 정보 복사 동기화 db 권한 부여 설정\n1 sudo chown -R mysql:mysql /home/data/mysql db 경로 변경\n아래와 같이 명령어로 진입 후 사진처럼 경로를 변경합니다.\n1 sudo vim /etc/mysql/mariadb.conf.d/50-server.cnf home 보안 해제\n아래의 경로에서 사진과 같이 설정합니다.\n1 sudo vim /lib/systemd/system/mariadb.service WSL에 활성화 돼 있는 DB 로컬에서 접속 방법 WSL에 있는 DB를 Heidi SQL 툴 등을 이용해 접속하려면 아래와 같이 설정하면 됩니다.\n외부 포트 접속 허용\n아래 경로의 mariadb 설정 파일의 포트를 0.0.0.0 으로 변경합니다.\n1 sudo vi /etc/mysql/mariadb.conf.d/50-server.cnf mysql restart\n1 sudo service mysql restart 외부 접속 포트 확인 후 접속\nWSL 환경에서 ip addr명령어를 입력하면 172...* 로 시작하는 포트가 있습니다. 해당 포트를\n로컬에서 접속하면 됩니다.\n만약 계정 권한이 없다면 권장되지는 않지만 아래와 같이 특정 계정에 모든 권한을 부여해 접속할 수 있습니다.\n아래와 같은 경우는 user라는 아이디와 0000패스워드로 권한을 부여했습니다.\n1 2 CREATE USER \u0026#39;user\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;0000\u0026#39;; GRANT ALL PRIVILEGES ON *.* TO \u0026#39;user\u0026#39;@\u0026#39;%\u0026#39; WITH GRANT OPTION; 1 2 3 sudo vim /etc/mysql/mariadb.conf.d/50-server.cnf sudo systemctl restart mysql # 이게 안되면 sudo service mysql restart WSL Maria DB 삭제 방법 mariadb server가 설치 중 잘못돼서 엉키면 아래와 같이 삭제할 수 있습니다.\n설정파일도 모두 삭제하기 위해 purge 사용 후 Remove all MariaDB databases? 문구 나오면 예를 눌러주시면 됩니다.\n1 sudo apt-get purge mariadb-* 남아있는 의존성 패키지 제거\n1 sudo apt autoremove mysql 관련 패키지 설치 확인\n1 dpkg -l | grep mysql 제 경우 위와 같이 mysql-common이 설치돼 있어 제거했습니다.\n데이터베이스 파일도 함께 삭제하고 싶다면, 다음 명령어를 입력하세요. 1 2 3 4 sudo rm -rf /var/lib/mysql sudo rm -rf /etc/mysql sudo rm -rf /var/log/mysql.* sudo rm -rf /var/log/mysql 위 명령어를 실행하면 /var/lib/mysql 디렉토리와 하위 파일들이 모두 삭제됩니다. 이 디렉토리는 mariadb-server의 데이터베이스 파일이 저장되는 디렉토리입니다.\n위와 같이 명령어를 실행하시면 mariadb-server를 삭제할 수 있습니다. 다만, 데이터베이스 파일까지 모두 삭제하시면 해당 데이터베이스 파일에 저장된 모든 데이터가 삭제되므로, 주의하시기 바랍니다.\n경고\nERROR 2002 (HY000): Can\u0026rsquo;t connect to local MySQL server through socket \u0026lsquo;/var/run/mysqld/mysqld.sock\u0026rsquo; (2 \u0026ldquo;No such file or directory\u0026rdquo;)\n만약 위와 같은 에러가 발생하면 아래와 같이 db를 재시작해주시면 됩니다.\n1 sudo service mysql restart ","permalink":"https://haservi.github.io/posts/devops/wsl/mariadb-setting/","summary":"WSL 환경에서 DB 설정 방법에 대해 정리했습니다.\n우선 기본적으로 윈도우 환경이며, WSL을 이용해 우분투 18.04 버전을 설치합니다.\nmariadb-server 설치 및 실행 패키지를 최신으로 업데이트 합니다.\n1 2 sudo apt-get update sudo apt-get upgrade 우선 mariadb-server를 설치합니다.\n1 2 3 sudo apt install mariadb-server sudo mysql -u root -p # 실행 DB 저장소 경로 변경 방법 만약 db의 저장소를 변경하고 싶다면 아래와 같이 진행하면 됩니다.\n우선 db의 경로를 /home/data/mysql으로 가정하겠습니다.\ndb 접속 후 현재 db의 경로를 확인합니다.","title":"WSL 환경에서 내부 MariaDB 설치하기"},{"content":"Gerrit은 오픈 소스 웹 기반 코드 리뷰 도구로, Git 버전 관리 시스템을 사용하는 프로젝트에서 코드 검토 및 협업을 용이하게 해줍니다. Gerrit은 구글에서 개발되었으며, 안드로이드 오픈 소스 프로젝트(AOSP) 등 여러 대규모 프로젝트에서 사용되고 있습니다.\nGerrit을 사용하려면 Gerrit 서버를 설치하고 구성해야 합니다.\n설치 방법은 공식 문서에서 확인할 수 있습니다.\nGerrit은 웹 기반 코드 커밋 및 버전 관리 도구로, 코드 리뷰를 위한 기능을 제공합니다.\n개발자들은 Gerrit을 이용하여 Git 저장소에서 작업한 코드 변경 사항을 리뷰하고, 변경을 승인하거나 거부하고, 수정 요청을 할 수 있습니다.\n아래는 Gerrit에서 지원하는 기능에 대한 정보입니다.\n코드 리뷰: Gerrit은 팀원들이 코드 변경을 검토하고 피드백을 제공할 수 있는 기능을 제공합니다. 리뷰어들은 변경 사항을 확인하고, 의견을 남기거나 수정 요청을 할 수 있습니다. 리뷰 프로세스가 완료되면 리뷰어는 변경 사항을 승인하거나 거부할 수 있습니다.\n패치 세트: Gerrit은 패치 세트라는 개념을 도입하여, 동일한 변경 사항에 대한 여러 버전을 추적할 수 있습니다. 이를 통해 개발자는 피드백을 반영하여 변경 사항을 업데이트하고, 리뷰어가 새로운 패치 세트를 쉽게 검토할 수 있습니다.\n브랜치 관리: Gerrit은 Git의 브랜치 관리 기능과 연동되어, 변경 사항이 리뷰를 통과하면 자동으로 브랜치에 병합됩니다. 이를 통해 코드베이스의 안정성이 유지되며, 팀원들이 협업을 효율적으로 진행할 수 있습니다.\n통합 지원: Gerrit은 다양한 지속적 통합(CI) 도구와 통합할 수 있어, 코드 변경이 병합되기 전에 테스트 및 빌드가 정상적으로 수행되는지 확인할 수 있습니다.\n접근 제어: Gerrit은 사용자 권한을 세분화하여, 프로젝트의 각 부분에 대한 접근 권한을 조절할 수 있습니다. 이를 통해 개발자와 리뷰어가 적절한 권한을 가지고 작업을 진행할 수 있습니다.\nGerrit은 안정적인 코드 리뷰를 보장하며 Git의 다양한 기능과 함께 사용할 수 있습니다.\nGerrit을 통해 코드 리뷰 문화가 제대로 돼 있다면 서로에게 좋은 효과를 줄 것이라 생각합니다.\n혼자 진행하는 프로젝트의 경우, Gerrit과 같은 코드 리뷰 도구의 이점은 크지 않습니다.\n개인 프로젝트에서는 Git의 기본 기능만으로도 충분히 버전 관리와 코드 추적을 할 수 있습니다. 예를 들어, 브랜치를 생성하여 새로운 기능을 개발하고, 완료되면 메인 브랜치에 병합하는 방식으로 작업할 수 있습니다.\n추가 에러 처리 관련 Gerrit을 사용할 때는 반드시 코드 리뷰를 거쳐야만 코드를 변경할 수 있습니다. 먼저 ssh 설정을 완료한 후, commit을 하고 명령어를 입력할 때 change-id가 없으면 에러가 발생할 수 있으니 주의해야 합니다.\n1 git push origin HEAD:refs/for/master 그러면 아래와 같은 에러가 발생합니다.\n경고\nremote: Resolving deltas: 100% (4 / 4)\nremote: Processing changes: refs: 1, done\nremote: ERROR: commit bd76487: missing Change-Id in message footer\nremote:\nremote: Hint: to automatically insert a Change-Id, install the hook:\nremote: gitdir=$(git rev-parse --git-dir); scp -p -P 29418 ~~~\nremote: and then amend the commit:\nremote: git commit --amend --no-edit\nremote: Finally, push your changes again\nremote:\n위의 힌트 2개를 그대로 넣으면 change-id가 설정됩니다.\n1 2 gitdir=$(git rev-parse --git-dir); scp -p -P 29418 ~~~ git commit --amend --no-edit 이 에러 메시지는 Gerrit을 사용하는 git 서버에서 commit message에 Change-Id가 없기 때문에 발생합니다.\nGerrit에서는 Change-Id를 사용하여 각각의 변경 사항에 고유한 ID를 부여하고 이를 사용하여 여러 작업을 관리합니다.\n해결 방법으로는 아래의 명령어를 통해 Gerrit에서 제공하는 commit-msg hook을 설치하고 commit message를 다시 작성하여 commit을 다시 시도하면 됩니다\n","permalink":"https://haservi.github.io/posts/tips/git-gerrit/","summary":"Gerrit은 오픈 소스 웹 기반 코드 리뷰 도구로, Git 버전 관리 시스템을 사용하는 프로젝트에서 코드 검토 및 협업을 용이하게 해줍니다. Gerrit은 구글에서 개발되었으며, 안드로이드 오픈 소스 프로젝트(AOSP) 등 여러 대규모 프로젝트에서 사용되고 있습니다.\nGerrit을 사용하려면 Gerrit 서버를 설치하고 구성해야 합니다.\n설치 방법은 공식 문서에서 확인할 수 있습니다.\nGerrit은 웹 기반 코드 커밋 및 버전 관리 도구로, 코드 리뷰를 위한 기능을 제공합니다.\n개발자들은 Gerrit을 이용하여 Git 저장소에서 작업한 코드 변경 사항을 리뷰하고, 변경을 승인하거나 거부하고, 수정 요청을 할 수 있습니다.","title":"Gerrit 코드 리뷰에 대해"},{"content":"node.js backend 에서 작업 중 테스트 서버에 배포 스크립트를 작성했습니다.\n위와 같이 $'\\r': coomand not found가 발생하면 해결 방법은 아래와 같습니다.\n1 sed -i \u0026#39;s/\\r$//\u0026#39; [스크립트파일.sh] 문제의 원인은 유닉스 기반의 운영체제에서는 줄 바꿈 문자로 줄 바꿈(Line Feed, LF)을 사용하지만, 윈도우 운영체제에서는 줄 바꿈 문자로 CR과 LF를 함께 사용합니다.\n그렇기 때문에 유닉스 기반의 운영체제에서는 Windows에서 생성된 텍스트 파일을 처리할 때 이러한 CR 문자가 문제가 될 수 있습니다.\nsed 유틸리티를 사용하여 스크립트 파일에서 Windows에서 생성된 줄 바꿈 문자(Carriage Return, CR)를 제거할 수 있습니다.\n위 명령어에서 사용된 sed 명령어는 s/패턴/치환/ 형식으로, 파일 내에서 패턴을 찾아 해당 패턴을 치환하는 명령어입니다.\n여기서는 파일 내의 모든 CR 문자를 제거하는 명령어입니다.\n","permalink":"https://haservi.github.io/posts/tips/error-script-to-linux/","summary":"node.js backend 에서 작업 중 테스트 서버에 배포 스크립트를 작성했습니다.\n위와 같이 $'\\r': coomand not found가 발생하면 해결 방법은 아래와 같습니다.\n1 sed -i \u0026#39;s/\\r$//\u0026#39; [스크립트파일.sh] 문제의 원인은 유닉스 기반의 운영체제에서는 줄 바꿈 문자로 줄 바꿈(Line Feed, LF)을 사용하지만, 윈도우 운영체제에서는 줄 바꿈 문자로 CR과 LF를 함께 사용합니다.\n그렇기 때문에 유닉스 기반의 운영체제에서는 Windows에서 생성된 텍스트 파일을 처리할 때 이러한 CR 문자가 문제가 될 수 있습니다.\nsed 유틸리티를 사용하여 스크립트 파일에서 Windows에서 생성된 줄 바꿈 문자(Carriage Return, CR)를 제거할 수 있습니다.","title":"Linux에서 배포 스크립트($'/r') 발생 시 처리 방법"},{"content":"인프라 관련 내용 정리가 필요할 것 같아 중요한 키워드 정도로 정리한 내용입니다.\nAWS EC2 접속 명령어 기본적으로 pem키를 발급받고 네트워크 보안이 올바르면 아래와 같은 명령어로 pem키를 이용해 접속 가능합니다.\n1 2 chmod 400 [pem파일명] ssh -i [pem키 파일명] ubuntu@[퍼블릭 IP 주소] 입력했던 콘솔 보기\n1 history bastion host 설정 bastion host란 내부와 외부 네트워크 사이에서 게이트 역할을 수행하는 호스트입니다.\n내부 서버나 중요 리소스를 보호하기 위해 생성되며, 일반 유저들에게는 공개하지 않습니다.\nbastion host에서 공개키를 생성한 후 접속하려는 서비스 서버에 키를 추가하여 접속할 수 있습니다.\n서비스용 서버에 22번 포트로의 접근은 bastion host만 가능하도록 security group을 설정해야합니다.\n1 2 3 4 5 6 # Bastion Server에서 공개키를 생성 bastion $ ssh-keygen -t rsa bastion $ cat ~/.ssh/id_rsa.pub # 접속하려는 서비스용 서버에 키 추가 $ vi ~/.ssh/authorized_keys 위와 같이 설정한 후 해당 서비스용 ip를 별칭으로 입력합니다.\n1 vim /etc/hosts 해당 파일에서 아래와 같이 입력하면 됩니다.\n1 [ip주소] [별칭] 사용할 때는 아래와 같이 쓰면 됩니다.\n1 ssh [별칭] latency 인증 관련 도메인 생성 사이트에서 도메인을 발급받은 뒤 docker의 certbot을 통해 SSL 인증서를 무료로 발급받을 수 있습니다.\n1 2 3 4 docker run -it --rm --name certbot \\ -v \u0026#39;/etc/letsencrypt:/etc/letsencrypt\u0026#39; \\ -v \u0026#39;/var/lib/letsencrypt:/var/lib/letsencrypt\u0026#39; \\ certbot/certbot certonly -d \u0026#39;[도메인 주소]\u0026#39; --manual --preferred-challenges dns --server https://acme-v02.api.letsencrypt.org/directory 발급받은 뒤 도메인 사이트에 아래와 같이 TXT(SPF)를 추가 해줘야합니다.\n1 2 3 # 인증서 경로 /etc/letsencrypt/live/[도메인주소]/fullchain.pem ./ /etc/letsencrypt/live/[도메인주소]/privkey.pem ./ 이후 nginx나 tomcat에 해당 인증서 키를 추가해야합니다.\ngit submodule 관련 키, 계정 정보, DB IP주소 패스워드 등 공개하고 싶지 않은 정보는 git private 저장소에 저장하고 해당 레포지토리를 submodule로 이용할 수 있습니다.\n1 git submodule add [자신의 private 저장소] ./src/main/resources/config 이후 source code 받을때\n1 2 3 4 5 6 git clone --recurse-submodules [자신의 프로젝트 저장소] # 설정 파일이 변경된 경우 git submodule foreach git pull origin main # 위의 설정이 안되면 아래로..! git submodule update --init --recursive k6 부하테스트 관련 k6는 부하테스트를 위한 라이브러리입니다. apache의 ab나 naver의 nGrinder처럼 부하테스트를 할 수 있는 도구입니다.\n설치 후 실행은 아래처럼 사용하면 됩니다.\n1 k6 run [파일명.js] k6를 gui로 보기 좋게 해주는 grafana도 있습니다.\njar 스크립트 배포 관련 스크립트를 이용해서 배포를 할 수 있습니다. 아래의 코드는 Spring 프로젝트를 정지, 빌드, 배포하는 스크립트 입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 PROJECT_PATH=\u0026#39;프로젝트 경로\u0026#39; JAR_PATH=${PROJECT_PATH}/build/libs JAR=$(cd ${JAR_PATH} \u0026amp;\u0026amp; find ./* -name \u0026#34;*jar\u0026#34; | cut -c 3-) JAR_PID=$(ps -ef | grep $JAR | grep -v grep | awk \u0026#39;{print $2}\u0026#39;) function stop_process() { if [ -z \u0026#34;$JAR_PID\u0026#34; ]; then echo \u0026#34;프로세스가 실행중이지 않습니다.\u0026#34; else echo \u0026#34;$JAR의 프로세스를 종료합니다. (PID = $JAR_PID)\u0026#34; kill $JAR_PID fi } function build() { cd ${PROJECT_PATH} \u0026amp;\u0026amp; ./gradlew clean build } function start_process() { java -jar -Dspring.profiles.active=prod $JAR_PATH/$JAR } echo -e \u0026#34;${txtylw}=======================================${txtrst}\u0026#34; echo -e \u0026#34;${txtgrn} Deploy Start ${txtrst}\u0026#34; echo -e \u0026#34;${txtylw}=======================================${txtrst}\u0026#34; stop_process build start_process 위의 파일은 [파일명].sh로 확장자를 구성해야 하며, 처음에 권한을 추가해준뒤 아래 명령어로 실행하면 됩니다.\n1 2 3 4 # 권한 추가 chmod +x [파일명.sh] # 실행 ./[파일명.sh] 이외에도 AWS 모니터링, 스케일 아웃, AWS Launch Template 등 인프라 설정을 한다면 조금 더 안정적으로 웹 서비스를 운용할 수 있습니다.\n","permalink":"https://haservi.github.io/posts/devops/aws/infra-tips/","summary":"인프라 관련 내용 정리가 필요할 것 같아 중요한 키워드 정도로 정리한 내용입니다.\nAWS EC2 접속 명령어 기본적으로 pem키를 발급받고 네트워크 보안이 올바르면 아래와 같은 명령어로 pem키를 이용해 접속 가능합니다.\n1 2 chmod 400 [pem파일명] ssh -i [pem키 파일명] ubuntu@[퍼블릭 IP 주소] 입력했던 콘솔 보기\n1 history bastion host 설정 bastion host란 내부와 외부 네트워크 사이에서 게이트 역할을 수행하는 호스트입니다.\n내부 서버나 중요 리소스를 보호하기 위해 생성되며, 일반 유저들에게는 공개하지 않습니다.","title":"Infra 설정 관련 정리"},{"content":"종종 프로젝트 중에는 특정 Node.js 버전에서만 동작하는 프로젝트가 있습니다. 이럴 경우 Docker를 이용하여 컨테이너를 만들거나 로컬인 경우 해당 버전에 맞는 Node.js를 설치해야 합니다.\n이번 내용은 전에 작성한 jdk 버전을 변경하듯이 Node.js 버전을 변경하는 방법에 대해 알아볼께요.\n알림\n해당 글은 Window를 기준으로 작성했습니다.\nMac의 경우는 해당 stackoverflow 질문글을 참조해주세요.\n먼저 해당 링크에서 우측의 Release 버튼을 선택합니다. nvm-setup.exe 파일을 다운로드 받습니다. 아래와 같이 파일을 설치하고 버전을 커맨드로 입력해보면 설치된 것을 확인할 수 있습니다. 정상적으로 설치 됐는지 확인하기 위해서는 nvm version의 명령어를 cmd에 입력하면됩니다.\n특정 Node.js를 설치할 때는 nvm install \u0026lt;version\u0026gt; 을 입력하면 됩니다. Node.js 버전은 해당 링크 에서 확인할 수 있습니다.\n경고\n주의할 점은 버전을 변경할 경우 cmd창을 관리자 모드로 실행해야합니다.\n관리자 모드에서 다운로드 받은 Node.js 버전을 nvm use \u0026lt;version\u0026gt; 으로 입력하면 변경됩니다. nvm list 를 입력하면 현재 설치된 Node.js 버전을 확인할 수 있습니다.\n","permalink":"https://haservi.github.io/posts/tips/window-nodejs-version-change/","summary":"종종 프로젝트 중에는 특정 Node.js 버전에서만 동작하는 프로젝트가 있습니다. 이럴 경우 Docker를 이용하여 컨테이너를 만들거나 로컬인 경우 해당 버전에 맞는 Node.js를 설치해야 합니다.\n이번 내용은 전에 작성한 jdk 버전을 변경하듯이 Node.js 버전을 변경하는 방법에 대해 알아볼께요.\n알림\n해당 글은 Window를 기준으로 작성했습니다.\nMac의 경우는 해당 stackoverflow 질문글을 참조해주세요.\n먼저 해당 링크에서 우측의 Release 버튼을 선택합니다. nvm-setup.exe 파일을 다운로드 받습니다. 아래와 같이 파일을 설치하고 버전을 커맨드로 입력해보면 설치된 것을 확인할 수 있습니다.","title":"Windows Nodejs 버전 변경하기"},{"content":"Window에서 JDK 버전 간편하게 변경하기 Java를 사용하여 프로젝트를 진행하다 보면 우선적으로 OS 명령을 내리기 위한 JDK(Java Develop Kit) 설치가 필요합니다.\n그렇지만 특정 Java 버전을 필요로 하는 프로젝트도 있습니다.\n이를 해결하기 위해 도커로 환경을 구성하거나 해당 로컬 컴퓨터의 환경변수를 설정하여 변경하는 것도 가능합니다.\n해당 글은 스크립트를 생성하여 터미널 명령어로 간단하게 자바 버전을 변경하는 방법입니다.\n모든 설정이 끝나면 아래처럼 터미널에서 명령어만 입력하면 스크립트를 변경 할 수 있습니다.\nJDK 설치 및 폴더명 변경 우선 JDK를 다운로드 아무래도 라이선스의 문제가 있을 수 있으니 OpenJDK를 다운받는 것을 추천드립니다.\n우선 해당 링크에서 다운 받을 수 있습니다.\n마이크로소프트에서도 openjdk를 다운로드 받을 수 있는 링크를 제공하고 있습니다. 다운로드 받은 폴더명은 아래와 같은 파일명으로 변경해줍니다.\n스크립트에 해당 폴더이름과 동일하게 맞췄기 때문에 변경을 원하시면 스크립트도 함께 변경해줘야 합니다.\n또한, 해당 스크립트 압축파일도 scripts 폴더에 풀어서 넣어줍니다. 해당 스크립트 명령어를 이용하여 터미널에서 자바 버전을 변경하도록 설정할 예정입니다.\n환경 변수 설정 일반적으로 윈도우에서 설정하는 환경변수 설정과 거의 동일합니다.\n약간의 차이점은 터미널에 스크립트 변수를 실행할 수 있는 변수를 지정 하는 정도에요.\n시스템 환경 변수 편집 화면에서 환경변수 를 선택합니다. 윈도우 버튼을 누르고 검색에 환경 변수만 치면 시스템 환경 변수 편집이 나타납니다. 다른 방법으로는 탐색기에서 내 PC 우 클릭 후 속성 -\u0026gt; 오른쪽에 고급 시스템 설정을 선택해주면 됩니다. 환경변수 선택 후 아래쪽의 새로 만들기를 눌러 줍니다.\n두개 시스템 이름은 JAVA_HOME 경로는 자주 사용하는 JDK 버전의 폴더 경로까지면 설정해줍니다. 제 경우는 OpenJDK11 버전을 주로 이용하기 때문에 C:\\Program Files\\Java\\openjdk11로 경로 설정을 했습니다.\n이제 Path에 위의 경로에 /bin를 추가하는 경로와 스크립트 경로를 지정합니다. 시스템 이름에서 Path를 선택 한 후 편집을 선택합니다. 그 후 아래와 같이 경로를 설정합니다. %JAVA_HOME%\\bin의 경우 3번에서 진행한 jdk 경로에 bin폴더 위치를 추가한 것이며, C:\\Program Files\\Java\\scripts는 기존에 추가한 스크립트 변수를 터미널에서 사용하기 위한 경로입니다.\n이렇게 설정해 주신 뒤 터미널을 실행하여 openjdk8, openjdk11, openjdk17을 명령어로 입력하면 자바 버전을 변경할 수 있습니다.\n추가사항 알림\n위의 방법은 현재의 터미널에서 변경되는 방법입니다.\n한번 설정으로 모든 환경에 영향을 받기위해서는 아래와 같이 설정합니다.\n위의 스크립트를 열어보면 아래와 같습니다.\n1 2 3 4 @echo off set JAVA_HOME=C:\\Program Files\\Java\\openjdk17 set Path=%JAVA_HOME%\\bin;%Path% echo Java 17 activated. 해당 스크립트를 전역으로 사용하고 싶다면 아래와 같이 변경하면 됩니다. 명령어는 관리자 모드의 터미널에서 가능합니다.\n1 2 3 @echo off setx JAVA_HOME \u0026#34;C:\\Program Files\\Java\\openjdk17\u0026#34; /m echo Java 17 activated. Path는 제거해주셔야합니다. 함께 사용하는 경우 환경변수에 강제로 추가됩니다.\n참조 링크 Java Custom Setting OpenJDK vs OracleJDK JDK 전역 변수로 설정 관련 ","permalink":"https://haservi.github.io/posts/tips/window-java-version-change/","summary":"Window에서 JDK 버전 간편하게 변경하기 Java를 사용하여 프로젝트를 진행하다 보면 우선적으로 OS 명령을 내리기 위한 JDK(Java Develop Kit) 설치가 필요합니다.\n그렇지만 특정 Java 버전을 필요로 하는 프로젝트도 있습니다.\n이를 해결하기 위해 도커로 환경을 구성하거나 해당 로컬 컴퓨터의 환경변수를 설정하여 변경하는 것도 가능합니다.\n해당 글은 스크립트를 생성하여 터미널 명령어로 간단하게 자바 버전을 변경하는 방법입니다.\n모든 설정이 끝나면 아래처럼 터미널에서 명령어만 입력하면 스크립트를 변경 할 수 있습니다.\nJDK 설치 및 폴더명 변경 우선 JDK를 다운로드 아무래도 라이선스의 문제가 있을 수 있으니 OpenJDK를 다운받는 것을 추천드립니다.","title":"OpenJDK 버전 간편하게 변경하기"},{"content":"시작하며 DSM 7버전에서는 SVN과 GitLab을 패키지로 지원하지 않습니다.\n그렇기 때문에 Docker를 이용하여 설치해야 합니다.\n제 경우는 KT 공유기와 Synology NAS(220+)에 램 8기가를 추가한 상태입니다.\n공유기 포트포워딩만 조금 다를 뿐 전체적인 방법은 동일할 것이라 생각됩니다.\nGitLab을 쾌적하게 쓰시려면 최소 램 4기가 이상으로 설정하시는게 좋습니다. 해당 설정은 컨테이너 생성 후에도 편집이 가능하니 필요에 따라 조정하시면 됩니다.\n알림\n완성 후 GitLab Repository 주소 경로가 올바르지 않은 이슈가 있지만 아래와 같이 설정하면 사용하는데 이상은 없을 것이라 생각됩니다.\nDocker에 GitLab 설치 패키지 센터에서 도커 설치 먼저 패키지 센터에서 Docker를 설치합니다. 도커를 실행 후 레지스트리에서 gitlab 검색 후 gitlab/gitlab-ce를 설치합니다. 조금 시간이 지난 후 설치가 완료되면 해당 이미지를 실행합니다. 도커 이미지 실행 및 설정하기 도커를 이미지를 실행 하면 다음과 같이 설정을 진행해야 합니다.\n먼저 고급 설정에서 자동 재시작 활성화를 합니다. 이렇게 되면 NAS가 죽었다 살아나도 알아서 실행됩니다. 포트 설정을 해줍니다. 로컬 포트는 임의로 해도 되지만 컨테이너 포트는 꼭 맞춰주셔야 합니다. 그리고 도커의 볼륨을 추가합니다. 공식홈페이지처럼 컨테이너 볼륨에 저장되는 정보를 NAS 로컬 위치로 매핑 시켜줍니다. 이렇게 설정 후 적용을 하면 컨테이너가 만들어 졌습니다. 해당 컨테이너가 결국은 하나의 GitLab을 구동하기 위한 서버라고 보시면 됩니다. 기본적으로 GitLab의 슈퍼관리자 아이디는 root이며, 패스워드는 방금 설정한 config 폴더의 initial_root_paasword파일에 암호가 있습니다.\n해당 암호를 보기 위해선 패키지 센터에서 텍스트 편집기를 설치하신 후 열어주시면 됩니다.\n패스워드를 확인 후 아래와 같이 컨테이너를 실행해주고 GitLab이 빌드(3~5분 정도)가 되면 접속이 가능합니다. 일단 이렇게 설정하시면 도커를 이용한 GitLab 설치는 정상적으로 끝났습니다.\n만약 해당 컴퓨터에서만 쓰실 경우는 NAS가 연결된 상태에서 해당 LAN IP로 접속해도 이용은 가능합니다.\n그렇지만 NAS를 쓰는 목적이 어디에서든 접속 가능하기 위함이니.. 조금 더 진행해주셔야 합니다.\nHTTP 설정을 하지 않고 바로 HTTPS로 넘어가셔도 무방합니다.\nHTTP 설정 및 공유기 포트포워딩 일단 NAS를 쓰시는 분들은 기본적으로 할당받을 수 있는 QuickConnectId가 있습니다. 해당 도메인 주소를 통해 우리는 외부에서 나의 NAS에 접속할 수 있습니다.\n하지만 보안상 아무나 이러한 접근을 허용하면 안되죠. 그렇기에 NAS의 설정에서 방화벽 규칙을 허용해줘야 하며, 공유기에서도 해당 포트로 접근 시 NAS에서 허용한 포트로 포트포워딩을 해줘야 합니다.\nNAS 방화벽 허용하기 제어판에서 방화벽에 들어간 후 규칙편집을 선택합니다. 방화벽 규칙을 생성합니다. 내장된 응용 프로그램 목록에서 선택에서 선택을 눌러주세요. 방금 전 만든 GitLab 컨테이너 포트를 선택합니다. 활성화 여부를 체크하고 확인을 눌러주세요. 여기까지 진행됐다면 NAS에 공유기를 물려서 사용하시는 분은 해당 공유기에서 NAS DNS로 접속하시면 접속이 되는 것을 확인 할 수 있습니다.\n공유기 포트포워딩 적용 제 경우는 KT 홈 허브 공유기가 있기에 해당 설정에 맞춰서 정리 하겠습니다.\n일단 IpTime과 달리 허브 기기의 관리자 페이지에 접속하기 위해선 공유기 와이파이 망 내 또는 랜선을 통해 웹페이지에서 172.30.1.254 로 접속해야 합니다.\n해당 화면에 처음 접속한 경우 기본 아이디와 패스워드는 아래와 같습니다.\n1 2 3 4 5 6 구형 ID: ktuser PW: megaap 신형 ID: ktuser PW: homehub 로그인 후 패스워드는 변경해주시는게 좋습니다. 추후 비밀번호를 잊어버리면 초기화하면 됩니다.\n먼저 UPnP(Universal Plug and Play) 설정을 해제하겠습니다. UPnP가 있으면 한번 포트 연결이 되면 이후에 포트포워딩을 지워도 적용됩니다. 편리한 기술이지만 보안에 취약한 문제가 있습니다.\n포트 포워딩 설정은 장치설정 -\u0026gt; 트래픽 관리 -\u0026gt; 포트 포워딩 설정으로 접근하면 됩니다.\n여기서 중요한 값은 외부포트, 내부 IP 주소, 내부 포트 입니다. 외부에서 들어오는 포트 주소입니다. 해당 포트로 들어오면 허브가 내부 포트로 포트를 변경해줍니다.\n외부포트는 임의로 정해도 되며, 내부 포트는 처음 Docker 컨테이너 포트에서 선택했던 포트 값을 지정해주면 됩니다.\n내부 IP 주소는 NAS에 연결된 내부 IP 주소를 입력해주면 됩니다.\n이렇게 설정하시면 이제 http는 어디서든 접속이 가능합니다.\nHTTPS 적용 및 역방향 프록시 설정 HTTPS를 적용할 예정이면 위으 포트포워딩에 443 포트만 적용하면 됩니다. NAS에서는 역방향 프록시 설정을 할 수 있습니다.\n그렇기 때문에 기존에 할당 받은 도메인에 여러 서브도메인을 설정할 수 있습니다.\n티스토리로 예를 들면 tistory.com은 하나의 도메인이지만 각각의 사용자는 앞에 user.tistory.com 식으로 자신의 도메인을 할당 받을 수 있는 원리와 비슷하다고 보면 됩니다.\n역방향 프록시 설정 역방향 프록시 설정 화면으로 이동합니다. 역방향 프록시 규칙을 설정합니다. 소스는 외부에서 접근하는 도메인 주소로 보시면 됩니다. 호스트이름 앞에 원하는 서브도메인을 입력하고 해당 도메인주소를 연결합니다. 대상은 기존 도메인주소와 도커 HTTP 컨테이너 포트를 입력합니다. 공유기 포트포워딩을 통해 HTTPS 포트인 443 포트를 허용해줍니다. NAS 인증서 발급 이제 외부에서 접속은 가능합니다. 하지만 HTTPS에서는 해당 도메인주소가 인증된 주소인지 확인하기 위해 인증서 발급이 필요합니다.\n일반적으로는 openssl 또는 사설 인증서를 이용하여 인증서를 발급받아야 하지만 NAS에서는 해당 과정 없이 간편하게 인증서를 발급받을 수 있습니다.\n제어판 -\u0026gt; 보안 -\u0026gt; 인증서로 이동후 추가를 눌러줍니다. 새인증서를 추가합니다. 인증서 이름과 Let\u0026rsquo;s Encrypt에서 인증서 얻기를 선택합니다. 역방향 프록시로 지정한 도메인 주소를 적습니다. 이메일은 본인의 이메일을 선택하시면 됩니다. 인증서 화면에서 설정에 들어가서 해당 인증서를 역방향 프록시에서 지정한 도메인과 매칭시킵니다. 모든 설정이 끝났습니다. 이렇게 하면 외부에서도 HTTPS로 접속이 가능합니다.\n기타 GitLab 프로젝트 생성 시 Clone with SSH와 Clone with HTTP의 주소가 프로젝트 레포지토리 주소와 매칭되지 않은 현상이 있습니다.\nGITLAB_HOST설정도 해보고, external_url도 지정해봤는데 제대로 되지 않아서 임시적으로 Clone with HTTP를 커스텀하는 방법(링크)이 있습니다.\n관리자로 로그인 후 좌측 메뉴에서 Admin을 선택합니다. Setting -\u0026gt; General -\u0026gt; Visibility and access controls 로 이동합니다. 해당 항목 중 Custom Git clone URL for HTTP(S) 의 값을 HTTPS로 인증한 도메인 주소로 추가합니다. ","permalink":"https://haservi.github.io/posts/devops/docker/nas-docker-gitlab-setting/","summary":"시작하며 DSM 7버전에서는 SVN과 GitLab을 패키지로 지원하지 않습니다.\n그렇기 때문에 Docker를 이용하여 설치해야 합니다.\n제 경우는 KT 공유기와 Synology NAS(220+)에 램 8기가를 추가한 상태입니다.\n공유기 포트포워딩만 조금 다를 뿐 전체적인 방법은 동일할 것이라 생각됩니다.\nGitLab을 쾌적하게 쓰시려면 최소 램 4기가 이상으로 설정하시는게 좋습니다. 해당 설정은 컨테이너 생성 후에도 편집이 가능하니 필요에 따라 조정하시면 됩니다.\n알림\n완성 후 GitLab Repository 주소 경로가 올바르지 않은 이슈가 있지만 아래와 같이 설정하면 사용하는데 이상은 없을 것이라 생각됩니다.","title":"Synology NAS로 Docker GitLab 설치하기"},{"content":"인텔리J에서 스프링 프로젝트를 생성하면 아래 셋팅은 미리 설정하면 좋습니다.\n1. 어노테이션 프로세싱 활성화 롬복과 같은 외부 라이브러리를 의존성 주입하게 될 경우 해당 사항을 체크해줘야 컴파일 시 문제 없이 동작합니다.\n설정에서 검색창에 annotation을 입력하면 아래와 같은 화면이 나옵니다.\n2. Build and run IntelliJ IDEA로 변경 IntelliJ IDEA 인텔리제이 자체에서 제공하는 빌드 자동화 도구입니다.\n기본은 Gradle로 설정 돼 있습니다. 이걸 IntelliJ IDEA로 변경하면 더 빠른 테스트를 할 수 있습니다.\nGradle빌드와 IntelliJ IDEA 빌드의 차이는 증분 빌드 여부입니다.\nIntelliJ IDEA는 변경된 부분만 빌드를 하는 방식으로 기존에 빌드가 돼 있는 부분은 건너뛰고 새로 변경된 부분만 빌드하는 방식입니다.\n그렇기 때문에 Gradle빌드 보다 더 빠르게 빌드할 수 있습니다. 하지만, IntelliJ IDEA는 기존에 빌드한 파일이 삭제된 경우도 같이 빌드가 될 수 있습니다. 그래서 종종 queryDSL과 mapStruct와 같이 컴파일 후 사용하는 코드가 빌드가 잘 안될 경우가 있을 수 있습니다.(반복적인 클린 -\u0026gt; 빌드 -\u0026gt; 리빌드 재귀..)\n올바르게 빌드를 하고 싶다면 Gradle로 하는 것도 좋은 전략이라 생각합니다.\n3. encoding UTF-8로 변경 인코딩이 encoding x-windows-949로 설정돼 있는 경우 아래와 같이 UTF-8로 변경하는 것이 좋습니다.\nx-windows-949란 한글 인코딩의 한 종류이며 EUC-KR의 확장형입니다. 오래전 마이크로소프트가 개발했던 한글 인코딩입니다.\n이것도 잘못하여 꼬이면 Swagger UI의 글자가 깨지는 경우가 발생할 수 있습니다.\n위 3가지는 프로젝트 생성 후 한번 쯤 확인해보면 좋은 것이라 생각되네요.\n4. 파일 끝에 개행을 자동으로 추가하기 행의 끝은 개행(EOL, end of line)으로 끝나는 것이 POSIX(Portable Operating System Interface) 표준이라고 합니다. 이와 같은 설정을 하지 않은 경우 예기치 않은 동작이 일어날 수 있기에 기본적으로 설정을 하시면 좋습니다.\n설정에서 Ensure every saved file ends with a line break를 체크해주시면 됩니다.\nReference 잘 알려지지 않은 Kotlin에서 빠른 컴파일의 비밀 Gradle \u0026amp; Build 그리고 IntelliJ의 Build 증분 빌드란 https://namu.wiki/w/CP949 ","permalink":"https://haservi.github.io/posts/spring/spring-intellij-start-setting/","summary":"인텔리J에서 스프링 프로젝트를 생성하면 아래 셋팅은 미리 설정하면 좋습니다.\n1. 어노테이션 프로세싱 활성화 롬복과 같은 외부 라이브러리를 의존성 주입하게 될 경우 해당 사항을 체크해줘야 컴파일 시 문제 없이 동작합니다.\n설정에서 검색창에 annotation을 입력하면 아래와 같은 화면이 나옵니다.\n2. Build and run IntelliJ IDEA로 변경 IntelliJ IDEA 인텔리제이 자체에서 제공하는 빌드 자동화 도구입니다.\n기본은 Gradle로 설정 돼 있습니다. 이걸 IntelliJ IDEA로 변경하면 더 빠른 테스트를 할 수 있습니다.\nGradle빌드와 IntelliJ IDEA 빌드의 차이는 증분 빌드 여부입니다.","title":"IntelliJ에서 스프링 프로젝트 관련 설정"},{"content":"Docker 메모리 프로세서 제어 Docker를 사용하다 보면 아래처럼 치솟는 메모리 사용량을 볼 때가 있습니다.\n아래의 방법은 Docker를 테스트 중 메모리 사용량을 Windows에서 제어 하는 방법입니다.\n탐색기의 사용자 위치(C:\\Users\\\u0026lt;사용자\u0026gt;)에 .wslconfig 파일을 생성합니다.\n아래와 같이 해당 파일의 설정을 지정합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 # 설정은 WSL 2에서 실행되는 모든 Linux 배포판에 적용 [wsl2] # VM 메모리를 4GB 이하로 제한. # GB 또는 MB를 사용하여 정수로 설정할 수 있음 memory=4GB # 2개의 가상 프로세서를 사용하도록 VM을 설정 processors=2 # 스왑 저장 공간의 양을 8GB로 설정합니다. 기본값은 사용 가능한 RAM의 25%입니다. swap=8GB 위 설정을 적용 후 Docker를 재실행해야 적용됩니다.\nMac의 경우는 Mac버전의 Docker Desktop 설정에서 간단하게 변경(링크) 할 수 있습니다.\nvmmem 터미널 강제 종료 Docker도 결국은 가상머신에서 돌고 있는 시스템이기에 WSL(Windows Subsystem for Linux)을 강제 종료하면 메모리와 CPU 점유율을 낮출 수 있습니다.\n좋은 방법은 아니지만 즉각적인 효과는 있습니다.\n커맨드 또는 powershell을 이용하여 아래의 명령어를 입력합니다.\n1 wsl --shutdown 위의 명령어로 WSL 강제 종료 후 Docker를 재실행하기 위해서는 Docker Desktop이 실행되어 있다면 우측하단의 트레이 아이콘에서 Troubleshoot을 선택합니다.\n선택 후 아래 사진과 같이 Restart를 선택하면 됩니다.\nReference https://docs.microsoft.com/ko-kr/windows/wsl/wsl-config https://stackoverflow.com/questions/64165192/stopping-vmmem-from-using-ram https://docs.docker.com/desktop/mac/ ","permalink":"https://haservi.github.io/posts/devops/docker/docker-smemory-controll-and-exit/","summary":"Docker 메모리 프로세서 제어 Docker를 사용하다 보면 아래처럼 치솟는 메모리 사용량을 볼 때가 있습니다.\n아래의 방법은 Docker를 테스트 중 메모리 사용량을 Windows에서 제어 하는 방법입니다.\n탐색기의 사용자 위치(C:\\Users\\\u0026lt;사용자\u0026gt;)에 .wslconfig 파일을 생성합니다.\n아래와 같이 해당 파일의 설정을 지정합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 # 설정은 WSL 2에서 실행되는 모든 Linux 배포판에 적용 [wsl2] # VM 메모리를 4GB 이하로 제한. # GB 또는 MB를 사용하여 정수로 설정할 수 있음 memory=4GB # 2개의 가상 프로세서를 사용하도록 VM을 설정 processors=2 # 스왑 저장 공간의 양을 8GB로 설정합니다.","title":"Docker 메모리 제한 설정 및 강제 종료"},{"content":"주로 DB를 관리하는 툴로 HeidiSQL를 많이 사용했습니다.\nSpring Data JPA와 QueryDSL 조합을 이용한 뒤로 어느 정도 익숙해지고 나서는 쿼리를 짜는 일이 많이 없지만, 조금 복잡한 쿼리의 경우는 쿼리를 작성해보고 성능 체크 후 QueryDSL로 변환하여 작업합니다.\n하지만 Mac환경에서는 HeidiSQL이 Mac을 지원하지 않기 때문에 다른 DB 툴을 사용해야 합니다.\nMac을 지원하는 다양한 DB툴 중에 평가가 꽤 괜찮은 DBeaver링크에 대해 알아보겠습니다.\nDbeaver 란? DBeaver는 Windows와 Mac 모두 지원 거의 모든 Database를 지원(MySQL, PostgreSQL, MariaDB, SQLite, Oracle, DB2, SQL Server\u0026hellip;) 오픈 소스 기반으로 다양한 확장 플러그인 지원 Entity Diagarm 지원 DB 내보내기 불러오기 지원 Community 버전을 이용해도 위와 같은 기능을 모두 사용할 수 있습니다.\n바로 다운로드하여 사용해도 되지만 기본적인 테마와 설정을 조금 변경하는 방법입니다.\n테마 뿐만아니라 다양한 확장 플러그인을 지원하기 때문에 필요한 것은 플러그인 검색하면 필요하다고 생각하는 왠만한 것은 나오는 것 같습니다.\n테마 변경 방법 테마 변경은 Mac기준으로 변경 했습니다. Windows도 비슷하긴 하지만 아래처럼 프로그램 재실행 팝업이 뜨면 아니오를 선택하고, 해당 프로그램을 관리자 권한으로 실행해야 합니다.(이후에는 그냥 실행 문제 없음)\n경고\nWindows의 경우 테마 설치 후 아니오를 선택 한 뒤 관리자 권한으로 실행해야합니다.\n그렇지 않으면 무한 재부팅 됩니다. 도움말선택 후 install new software를 선택합니다. 사이트 URL에 https://www.genuitec.com/updates/devstyle/ci/를 입력하고 아래의 그림처럼 선택 후 다음 선택합니다. 정상적으로 설치하면 프로그램 이 다시 실행된 후 아래와 같은 화면이 됩니다. 설정 커스텀 설정 커스텀은 쿼리 입력 방법과 결과 출력화면 단축키 들을 변경합니다.\n이 부분은 개인의 성향 차이가 크기 때문에 그냥 참고용으로 보는 것도 괜찮을 것 같습니다.\n설정은 Commend + ,로 진입하거나 아래처럼 선택하면 됩니다. 문서 편집기 설정 및 표시 설정 변경입니다. 쿼리 실행 시 Blank 구분자 설정 제외(여러 쿼리 실행 시 오류 방지) Select 결과 컬럼 높이 행 맞춤 및 헤더에 코멘트 출력 쿼리 작성 시 자동완성 기능 해제 컬럼 위치 변경 단축키 지정 자주 쓰는 단축키 단축키는 공식 문서에 잘 나와있으며, 자주 쓰는 단축키는 아래와 같습니다.\n기능 Windows Mac 쿼리 자동 완성 Ctrl+Space ⌃Space 쿼리 실행 Ctrl+Enter ⌃↩ 새로고침 Ctrl+F5 ⌘F5 해당스크립트의 다음 쿼리 ALT+Up ⌃⇧↑ 해당스크립트의 이전 쿼리 Alt+Down ⌃⇧↓ 이외에도 많은 단축키가 있습니다.\n그 외 다른 프로그램 추천 해당 프로그램 이외에 mac에서 이용하면 좋은 프로그램은 아래와 같습니다.\nSnipaste(mac, window, linux) 사이트 링크 캡쳐 프로그램으로 가볍게 캡쳐하고 삭제가 가능(윈도우, 맥, 리눅스 모두 가능), 리뷰 Raycast(mac) 사이트 링크 단축키를 활용하여 생산성 향상 프로그램, 리뷰 Karabiner-Elements(mac) 사이트 링크 karabiner 프로그램으로 맥북 키보드 설정, 리뷰 Rectangle(mac) 사이트 링크 프로그램 화면 크기 조절 프로그램, 리뷰 Logitech Options(mac) 사이트 링크 Logitech 제품 마우스 커스텀 프로그램, 리뷰 Dbeaver(mac, window) 사이트 링크 DB 접근 제어 프로그램 일부 커스텀 방법, 리뷰 ScreeToGif(mac, window) 사이트 링크 간단하게 화면을 gif로 만드는 프로그램 소개, 리뷰 ","permalink":"https://haservi.github.io/posts/tools/how-to-dbeaver/","summary":"주로 DB를 관리하는 툴로 HeidiSQL를 많이 사용했습니다.\nSpring Data JPA와 QueryDSL 조합을 이용한 뒤로 어느 정도 익숙해지고 나서는 쿼리를 짜는 일이 많이 없지만, 조금 복잡한 쿼리의 경우는 쿼리를 작성해보고 성능 체크 후 QueryDSL로 변환하여 작업합니다.\n하지만 Mac환경에서는 HeidiSQL이 Mac을 지원하지 않기 때문에 다른 DB 툴을 사용해야 합니다.\nMac을 지원하는 다양한 DB툴 중에 평가가 꽤 괜찮은 DBeaver링크에 대해 알아보겠습니다.\nDbeaver 란? DBeaver는 Windows와 Mac 모두 지원 거의 모든 Database를 지원(MySQL, PostgreSQL, MariaDB, SQLite, Oracle, DB2, SQL Server\u0026hellip;) 오픈 소스 기반으로 다양한 확장 플러그인 지원 Entity Diagarm 지원 DB 내보내기 불러오기 지원 Community 버전을 이용해도 위와 같은 기능을 모두 사용할 수 있습니다.","title":"DBeaver 커스텀 셋팅하기"},{"content":"종종 테스트 중 이전에 실행한 Port가 남아서 충돌나는 경우가 있습니다.\n기존에 존재하는 Port의 PID를 제거하면 삭제할 수 있습니다.\nPort 강제 종료 방법 먼저 windows + R 을 눌러 실행 스크립트를 열어주고 cmd를 입력하여 커맨드 창을 열어줍니다. 명령어로 netstat -a -o를 입력하면 현재 연결된 네트워크 상태를 볼 수 있습니다. 위와 같이 8080포트가 존재하면 우측에 있는 PID의 번호를 기억합니다. 여기서는 49480의 값입니다. taskkill /f /pid 49480을 입력하면 해당 8080포트를 제거할 수 있습니다. ","permalink":"https://haservi.github.io/posts/tips/window-port-taskkill/","summary":"종종 테스트 중 이전에 실행한 Port가 남아서 충돌나는 경우가 있습니다.\n기존에 존재하는 Port의 PID를 제거하면 삭제할 수 있습니다.\nPort 강제 종료 방법 먼저 windows + R 을 눌러 실행 스크립트를 열어주고 cmd를 입력하여 커맨드 창을 열어줍니다. 명령어로 netstat -a -o를 입력하면 현재 연결된 네트워크 상태를 볼 수 있습니다. 위와 같이 8080포트가 존재하면 우측에 있는 PID의 번호를 기억합니다. 여기서는 49480의 값입니다. taskkill /f /pid 49480을 입력하면 해당 8080포트를 제거할 수 있습니다. ","title":"윈도우 Port 강제 종료 방법"},{"content":"Visual Studio Code의 자동완성 기능 해제 방법 프로그램 실행 후 설정(Ctrl + , 또는 Command + ,)으로 들어간 후 검색항목에 intelliSense를 검색하면 여러 체크박스 리스트를 볼 수 있습니다.\n위(Show Classes)에서부터 아래(Show Words)까지 전부 체크 해제를 하면 자동완성 기능이 비활성화 됩니다.\n그렇지만 너무 많은 옵션이 있기 때문에 전부 클릭 해제하기가 귀찮은 경우 아래의 JSON으로 추가할 수 있습니다.\n오른쪽 위의 설정으로 들어가서 아래의 값들을 복사 후 붙여 넣어주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026#34;explorer.compactFolders\u0026#34;: false, \u0026#34;explorer.confirmDragAndDrop\u0026#34;: false, \u0026#34;editor.suggest.showConstants\u0026#34;: false, \u0026#34;editor.suggest.showConstructors\u0026#34;: false, \u0026#34;editor.suggest.showCustomcolors\u0026#34;: false, \u0026#34;editor.suggest.showDeprecated\u0026#34;: false, \u0026#34;editor.suggest.showEnumMembers\u0026#34;: false, \u0026#34;editor.suggest.showEnums\u0026#34;: false, \u0026#34;editor.suggest.showEvents\u0026#34;: false, \u0026#34;editor.suggest.showFields\u0026#34;: false, \u0026#34;editor.suggest.showFiles\u0026#34;: false, \u0026#34;editor.suggest.showFolders\u0026#34;: false, \u0026#34;editor.suggest.showFunctions\u0026#34;: false, \u0026#34;editor.suggest.showInterfaces\u0026#34;: false, \u0026#34;editor.suggest.showIssues\u0026#34;: false, \u0026#34;editor.suggest.showKeywords\u0026#34;: false, \u0026#34;editor.suggest.showMethods\u0026#34;: false, \u0026#34;editor.suggest.showModules\u0026#34;: false, \u0026#34;editor.suggest.showOperators\u0026#34;: false, \u0026#34;editor.suggest.showProperties\u0026#34;: false, \u0026#34;editor.suggest.showReferences\u0026#34;: false, \u0026#34;editor.suggest.showSnippets\u0026#34;: false, \u0026#34;editor.suggest.showStructs\u0026#34;: false, \u0026#34;editor.suggest.showTypeParameters\u0026#34;: false, \u0026#34;editor.suggest.showUnits\u0026#34;: false, \u0026#34;editor.suggest.showUsers\u0026#34;: false, \u0026#34;editor.suggest.showValues\u0026#34;: false, \u0026#34;editor.suggest.showVariables\u0026#34;: false, \u0026#34;editor.suggest.showWords\u0026#34;: false, \u0026#34;editor.suggest.showClasses\u0026#34;: false, \u0026#34;editor.suggest.showColors\u0026#34;: false 아래의 사진처럼 넣어주면 됩니다. 다시 자동완성 기능이 필요하면 위의 값들을 삭제하거나 intelliSense로 접근하여 해당 항목들을 체크하면 됩니다.\n","permalink":"https://haservi.github.io/posts/tips/visual-studio-code-auto-complete/","summary":"Visual Studio Code의 자동완성 기능 해제 방법 프로그램 실행 후 설정(Ctrl + , 또는 Command + ,)으로 들어간 후 검색항목에 intelliSense를 검색하면 여러 체크박스 리스트를 볼 수 있습니다.\n위(Show Classes)에서부터 아래(Show Words)까지 전부 체크 해제를 하면 자동완성 기능이 비활성화 됩니다.\n그렇지만 너무 많은 옵션이 있기 때문에 전부 클릭 해제하기가 귀찮은 경우 아래의 JSON으로 추가할 수 있습니다.\n오른쪽 위의 설정으로 들어가서 아래의 값들을 복사 후 붙여 넣어주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026#34;explorer.","title":"비쥬얼 스튜디오 코드에서 자동완성 해제하기"},{"content":"Git Commit git commit message convetion은 회사 또는 프로젝트 마다 다를 수 있습니다.\nmessage의 형태는 다를 수 있지만 기본적인 목적은 같습니다.\n잘 만들어진 git 커밋 메시지는 해당 프로젝트에서 작업하는 팀원과 미래의 자신에게 변경 사항에 대한 의미를 전달하기 위한 좋은 방법입니다.\n일반적으로 커밋 메시지는 다음과 같은 구조를 권장합니다.\n1 2 3 4 5 type: Subject body footer 보통 위와 같은 형태입니다.\n제목은 새로운 기능 추가인 경우 feat: Subject, Feat: Subject, Feat Subject, Feature Subject 등 조금씩 type의 형태가 다르지만 그건 프로젝트에 따라 일관되게 맞추면 됩니다.\n글자 수는 50자 이내로 작성하는 것이 좋으며, issue와 관련이 있다면 제목 옆에 (#issue nubmer)를 추가하는 것도 어떠한 이슈와 관련된 것인지 알기 쉽게 볼 수 있습니다.\n본문은 commit 내용에 대한 추가 설명입니다. 한 줄당 72자 이내로 작성 하는 것이 좋으며, 본문 내용의 경우 변경 사항에 대한 정보를 기입하는 것이 좋습니다.\n푸터는 이슈 트래커 참조 용도로 사용됩니다.\n보통 푸터에 종료 키워드와 이슈 번호를 함께 작성하면 해당 이슈가 종료 처리도 됩니다.\nType의 종류 Type의 종류도 강제적이지는 않습니다. 다만 아래의 정보면 충분히 설명이 가능합니다.\nFeat 새로운 기능 Fix 버그 수정 Docs 문서와 관련된 추가 수정 삭제 Style 코드의 의미에 영향을 주지 않는 변경 사항(공백, 서식, 세미콜론 누락 등) Refactor 버그를 수정하거나 기능을 추가하지 않는 코드 변경 Perf 성능을 향상시키는 코드 변경 Test 테스트 추가 Chore 빌드 프로세스 또는 라이브러리에 대한 변경 사항 제목 총 글자 수 50자 이내로 작성 마지막에 ., !, ? 같은 특수문자 제외 제목은 동사원형 형태로 추가 본문 간단한 변경 사항의 경우 작성할 필요 없음 한 줄 당 72자 이내로 작성 부연 설명 및 어떻게 보다는 무엇을 왜 변경했는지 기입 푸터 간단한 변경 사항의 경우 작성할 필요 없음 이슈 트래커 id를 작성할 때 사용 Reference 좋은 git 커밋 메시지를 작성하기 위한 7가지 약속 협업을 위한 git 커밋 컨벤션 설정하기 How to Write a Git Commit Message How to Write Good Commit Messages: A Practical Git Guide ","permalink":"https://haservi.github.io/posts/tips/git-commit-message-rule/","summary":"Git Commit git commit message convetion은 회사 또는 프로젝트 마다 다를 수 있습니다.\nmessage의 형태는 다를 수 있지만 기본적인 목적은 같습니다.\n잘 만들어진 git 커밋 메시지는 해당 프로젝트에서 작업하는 팀원과 미래의 자신에게 변경 사항에 대한 의미를 전달하기 위한 좋은 방법입니다.\n일반적으로 커밋 메시지는 다음과 같은 구조를 권장합니다.\n1 2 3 4 5 type: Subject body footer 보통 위와 같은 형태입니다.\n제목은 새로운 기능 추가인 경우 feat: Subject, Feat: Subject, Feat Subject, Feature Subject 등 조금씩 type의 형태가 다르지만 그건 프로젝트에 따라 일관되게 맞추면 됩니다.","title":"Git Commit 메시지 규칙"},{"content":"Windows는 line ending으로 CR(Carriage-Return, \\r)과 LF(Line Feed \\n)을 사용합니다. CRLF는 커서를 다음 라인의 맨앞으로 옮기는 표시이며, ↲ 이러한 표현입니다.\nMac, Linux(Unix 계열)의 경우 LF(Line Feed \\n)를 사용합니다. LF는 현재 위치에서 바로 아래로 이동하는 것을 의미하며, ↓ 와 같은 표현입니다.\n문제는 같은 작업 영역에서 같은 코드를 수정할 경우 windows와 mac의 코드가 일치하더라도 커서의 표현값이 다르기 때문에 충돌이 일어나는 경우가 발생합니다.\n해결 방법으로는 각 운영체제별로 git을 기준으로 LF로 맞춰주는 것입니다.\nWindows는 CRLF를 LF로 변경되도록 git config 설정 중 core.autocrlf를 설정해주면 됩니다. Mac은 기존 개행 형식으로 저장되도록 설정해줍니다.\ncore.autocrlf 는 text file 을 git object database 에 checkin, checkout 할 때 어떻게 처리할지를 설정하는 변수입니다.\nWindows 1 git config --global core.autocrlf true text file을 넣기전 CRLF를 LF로 변경합니다.\nMac 1 git config --global core.autocrlf input Mac, Linux(Unix 계열)의 경우 LF만 사용하기 때문에 input으로 설정하면 됩니다.\n위와 같은 설정은 결국 아래와 같은 그림과 같은 형태로 text 파일이 저장됩니다.\n","permalink":"https://haservi.github.io/posts/tips/git-crlf/","summary":"Windows는 line ending으로 CR(Carriage-Return, \\r)과 LF(Line Feed \\n)을 사용합니다. CRLF는 커서를 다음 라인의 맨앞으로 옮기는 표시이며, ↲ 이러한 표현입니다.\nMac, Linux(Unix 계열)의 경우 LF(Line Feed \\n)를 사용합니다. LF는 현재 위치에서 바로 아래로 이동하는 것을 의미하며, ↓ 와 같은 표현입니다.\n문제는 같은 작업 영역에서 같은 코드를 수정할 경우 windows와 mac의 코드가 일치하더라도 커서의 표현값이 다르기 때문에 충돌이 일어나는 경우가 발생합니다.\n해결 방법으로는 각 운영체제별로 git을 기준으로 LF로 맞춰주는 것입니다.\nWindows는 CRLF를 LF로 변경되도록 git config 설정 중 core.","title":"git CRLF 개행 문자 차이 해결 방법"},{"content":"우선순위 큐(Priority Queue) 란? 우선순위 큐(Priority Queue)는 일반적인 큐의 구조와 달리 들어가는 순서와 상관없이 정의한대로 우선순위를 먼저 결정하고 그 우선순위가 높은 데이터가 먼저 나가는 자료구조 입니다. 그렇기 때문에 dequeue를 하면 이미 정의한 순서에 맞게 가장 위의 값이 나타납니다.\n우선순위 큐는 힙을 기반으로 하는 완전이진트리로 우선순위를 정하게 됩니다.\n사용 방법 우선순위 큐는 우선순위가 꼭 필요한 경우에 사용합니다. 람다식으로 정의해도 되고 Comparable을 이용해서 정의해도 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 낮은 숫자가 우선순위가 높은 방식 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); // 높은 숫자가 우선순위가 높은 방식 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(Collections.reverseOrder()); // 이중 배열에서 0번째 낮은 숫자가 우선순위가 높은 방식(람다식) PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((o1, o2) -\u0026gt; o1[0] - o2[0]); // 이중 배열에서 0번째 낮은 숫자가 우선순위가 높은 방식(Comparator) PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(new Comparator\u0026lt;int[]\u0026gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] - o2[0]; }; }); 위 처럼 다양한 방법으로 우선순위를 정할 수 있습니다.\n간단한 예제 및 원리 간단히 예를 들어 가장 작은 수를 기준으로 우선순위 큐를 만들면\n1 2 3 4 5 6 7 8 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); pq.offer(1); pq.offer(2); pq.offer(3); pq.offer(4); pq.offer(5); pq.offer(6); pq.offer(7); 의 형태로 만들어집니다.\n그렇지만 각각 enqueue할 때는 이진트리의 마지막부분에서 조건에 맞게 값이 들어가는거죠.\n위의 경우는 가장작은 수부터 차례로 들어가기 때문에 swap을 하지 않고 값이 들어가게됩니다.\n그렇지만 만약 큰 수부터 우선순위 큐를 하게 되면\n1 2 3 4 5 6 7 8 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(Collections.reverseOrder()); pq.offer(1); pq.offer(2); pq.offer(3); pq.offer(4); pq.offer(5); pq.offer(6); pq.offer(7); 의 형태로 만들어집니다. 위의 순서를 그림으로 그리면 아래와 같은 순서로 완전 이진트리 형태로 값이 들어갑니다.\n조건에 맞게 우선 가장 마지막 노드에 값이 들어가고 부모와 비교를 해서 자신의 위치를 찾아가는 것이죠.\n반대로 dequeue인 poll()의 경우는 우선 Root를 제거하고 가장 마지막의 노드를 Root로 가져온 뒤 자식노드 중 자신보다 우선순위가 높은 값이 있다면 Swap을 하여 자신의 위치를 찾아가는 식입니다.\n1 2 3 while (!pq.isEmpty()) { pq.poll(); } 실제로 코드 내부로 들어가면 enqueue의 경우는 아래와 같이 Comparable로 정의하고 부모 노드와 현재 노드를 변경하는 코드가 들어가 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public boolean offer(E e) { if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i \u0026gt;= queue.length) grow(i + 1); siftUp(i, e); size = i + 1; return true; } private void siftUp(int k, E x) { if (comparator != null) siftUpUsingComparator(k, x, queue, comparator); else siftUpComparable(k, x, queue); } private static \u0026lt;T\u0026gt; void siftUpComparable(int k, T x, Object[] es) { Comparable\u0026lt;? super T\u0026gt; key = (Comparable\u0026lt;? super T\u0026gt;) x; while (k \u0026gt; 0) { int parent = (k - 1) \u0026gt;\u0026gt;\u0026gt; 1; Object e = es[parent]; if (key.compareTo((T) e) \u0026gt;= 0) break; es[k] = e; k = parent; } es[k] = key; } private static \u0026lt;T\u0026gt; void siftUpUsingComparator( int k, T x, Object[] es, Comparator\u0026lt;? super T\u0026gt; cmp) { while (k \u0026gt; 0) { int parent = (k - 1) \u0026gt;\u0026gt;\u0026gt; 1; Object e = es[parent]; if (cmp.compare(x, (T) e) \u0026gt;= 0) break; es[k] = e; k = parent; } es[k] = x; } 마찬가지로 dequeue의 경우도 Comparable로 정의하고 child 노드와 현재 노드를 변경하는 식의 코드가 들어있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public E poll() { final Object[] es; final E result; if ((result = (E) ((es = queue)[0])) != null) { modCount++; final int n; final E x = (E) es[(n = --size)]; es[n] = null; if (n \u0026gt; 0) { final Comparator\u0026lt;? super E\u0026gt; cmp; if ((cmp = comparator) == null) siftDownComparable(0, x, es, n); else siftDownUsingComparator(0, x, es, n, cmp); } } return result; } private static \u0026lt;T\u0026gt; void siftDownComparable(int k, T x, Object[] es, int n) { // assert n \u0026gt; 0; Comparable\u0026lt;? super T\u0026gt; key = (Comparable\u0026lt;? super T\u0026gt;)x; int half = n \u0026gt;\u0026gt;\u0026gt; 1; // loop while a non-leaf while (k \u0026lt; half) { int child = (k \u0026lt;\u0026lt; 1) + 1; // assume left child is least Object c = es[child]; int right = child + 1; if (right \u0026lt; n \u0026amp;\u0026amp; ((Comparable\u0026lt;? super T\u0026gt;) c).compareTo((T) es[right]) \u0026gt; 0) c = es[child = right]; if (key.compareTo((T) c) \u0026lt;= 0) break; es[k] = c; k = child; } es[k] = key; } private static \u0026lt;T\u0026gt; void siftDownUsingComparator( int k, T x, Object[] es, int n, Comparator\u0026lt;? super T\u0026gt; cmp) { // assert n \u0026gt; 0; int half = n \u0026gt;\u0026gt;\u0026gt; 1; while (k \u0026lt; half) { int child = (k \u0026lt;\u0026lt; 1) + 1; Object c = es[child]; int right = child + 1; if (right \u0026lt; n \u0026amp;\u0026amp; cmp.compare((T) c, (T) es[right]) \u0026gt; 0) c = es[child = right]; if (cmp.compare(x, (T) c) \u0026lt;= 0) break; es[k] = c; k = child; } es[k] = x; } ","permalink":"https://haservi.github.io/posts/algorithms/priority-queue/","summary":"우선순위 큐(Priority Queue) 란? 우선순위 큐(Priority Queue)는 일반적인 큐의 구조와 달리 들어가는 순서와 상관없이 정의한대로 우선순위를 먼저 결정하고 그 우선순위가 높은 데이터가 먼저 나가는 자료구조 입니다. 그렇기 때문에 dequeue를 하면 이미 정의한 순서에 맞게 가장 위의 값이 나타납니다.\n우선순위 큐는 힙을 기반으로 하는 완전이진트리로 우선순위를 정하게 됩니다.\n사용 방법 우선순위 큐는 우선순위가 꼭 필요한 경우에 사용합니다. 람다식으로 정의해도 되고 Comparable을 이용해서 정의해도 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 낮은 숫자가 우선순위가 높은 방식 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); // 높은 숫자가 우선순위가 높은 방식 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(Collections.","title":"Java Priority Queue(우선순위 큐) 원리 및 사용 방법"},{"content":"H2를 최신 버전(2.1.210)으로 업데이트하니 아래와 같은 에러가 발생했습니다.\n1 2 3 4 5 6 7 8 Caused by: org.hibernate.HibernateException: Access to DialectResolutionInfo cannot be null when \u0026#39;hibernate.dialect\u0026#39; not set ... java.lang.IllegalStateException: Failed to load ApplicationContext at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132) at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:124) at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:190) ... 일단 임시방편으로 H2 url을 연결하는 곳에 추가적으로 옵션(;MODE=LEGACY)을 넣으면 해결됩니다.\n1 url: jdbc:h2:tcp://localhost/~/test;MODE=LEGACY MODE=LEGACY를 모드를 사용하면 H2 1.X용으로 작성된 응용 프로그램에 대한 일부 호환성 기능이 활성화됩니다. Hibernate ORM에서 H2에 대해서 유효하지 않은 SQL을 생성하기 때문이라고 합니다.\n그렇다면.. hibernate ORM에서 H2 방언에 대한 문제를 해결해야 합니다.\n현재는 hibernate ORM은 5.6 안정화 버전과 6.0 개발 버전이 있습니다.\nReference Upgrade H2 version 2.0.202 from 1.4.200 h2database document ","permalink":"https://haservi.github.io/posts/spring/h2-version-upgrade-error/","summary":"H2를 최신 버전(2.1.210)으로 업데이트하니 아래와 같은 에러가 발생했습니다.\n1 2 3 4 5 6 7 8 Caused by: org.hibernate.HibernateException: Access to DialectResolutionInfo cannot be null when \u0026#39;hibernate.dialect\u0026#39; not set ... java.lang.IllegalStateException: Failed to load ApplicationContext at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132) at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:124) at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:190) ... 일단 임시방편으로 H2 url을 연결하는 곳에 추가적으로 옵션(;MODE=LEGACY)을 넣으면 해결됩니다.\n1 url: jdbc:h2:tcp://localhost/~/test;MODE=LEGACY MODE=LEGACY를 모드를 사용하면 H2 1.X용으로 작성된 응용 프로그램에 대한 일부 호환성 기능이 활성화됩니다. Hibernate ORM에서 H2에 대해서 유효하지 않은 SQL을 생성하기 때문이라고 합니다.","title":"H2 2.1.210 Upgrade시 JPA 테스트 에러 해결 방법"},{"content":"JPQL 이란? 예전에는 JPQL은 Java Persistence Query Language로 불렸지만 현재의 JPQL은(Jakarta Persistence Query Language) 라고 합니다.(나무위키 링크)\n2019년부터 JPA(Java Persistence API)또한 Jakarta Persistence로 변경됐습니다.\n이름은 달라졌지만 역할은 달라지지 않았습니다. JPQL을 이용하여 관계형 데이터베이스의 엔티티를 정의하고 이를 활용한 쿼리 언어를 자바를 이용하여 구현합니다.\n더 나아가 Querydsl을 이용하면 좀 더 직관적이고 오류 없이 자바를 이용하여 작성할 수 있습니다.\n간단한 예시로 회원 조회를 하는 경우 JPQL과 Querydsl의 차이는 아래와 같습니다.\nJPQL\n1 2 3 4 5 6 public List\u0026lt;Member\u0026gt; findAll() { EntityManager entityManager; return entityManager.createQuery(\u0026#34;select m from Member m \u0026#34;, Member.class) .getResultList(); } Querydsl\n1 2 3 4 5 6 7 public List\u0026lt;Member\u0026gt; findAll() { JPAQueryFactory queryFactory; return queryFactory .selectFrom(QMember.member) .fetch(); } 결국은 같은 결과를 호출하지만 Querydsl을 이용하면 쿼리작성 및 빌드 오류를 컴파일 시점에 방지할 수 있습니다.\n가독성도 Querydsl쪽이 더 좋습니다.\nSpring Data JPA란? CRUD 처리를 위한 공통 인터페이스를 JPA에서 미리 만들어 놓은 것입니다.\n일반적으로 Entity 어노테이션을 선언한 클래스를 매개변수로 JpaRepository 인터페이스를 상속받아 사용합니다.\n이렇게되면 실제로 SQL관련 코드하나 사용하지 않고 간단한 CRUD는 처리가 가능합니다.\n사용자 정의 인터페이스 상속받기 인터페이스는 다중상속이 가능하기 때문에 먼저 CustomRepository를 인터페이스로 생성합니다.\n1 2 3 public interface CustomMemberRepository { void customSave(Member member); } 그리고 구현체에 해당 선언한 함수들을 구현합니다.\n1 2 3 4 5 6 7 8 9 @RequiredArgsConstructor public class CustomMemberRepositoryImpl implements CustomMemberRepository { private final EntityManager em; @Override public void customSave(Member member) { em.persist(member); } } 마지막으로 직접사용할 인터페이스에 위의 인터페이스를 추가합니다.\n1 2 3 public interface MemberRepository extends JpaRepository\u0026lt;Member, Long\u0026gt;, CustomMemberRepository { } 위와 같이 스프링 데이터 JPA에서 제공하는 기능과 필요한 기능이 복잡해짐에 따른 커스텀 쿼리를 인터페이스화 하여 함께 사용할 수 있습니다.\n같은 결과라도 memberRepository.customSave(member)와 memberRepository.save(member)의 방식이 다릅니다.\n아래는 package org.springframework.data.jpa.repository.support;에서 구현된 save(S entity) 구현체 입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Transactional @Override public \u0026lt;S extends T\u0026gt; S save(S entity) { Assert.notNull(entity, \u0026#34;Entity must not be null.\u0026#34;); if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else { return em.merge(entity); } } 스프링 데이터 JPA에서 제공하는 함수 가이드 링크 입니다.\n","permalink":"https://haservi.github.io/posts/spring/springdatajpa-and-customquery/","summary":"JPQL 이란? 예전에는 JPQL은 Java Persistence Query Language로 불렸지만 현재의 JPQL은(Jakarta Persistence Query Language) 라고 합니다.(나무위키 링크)\n2019년부터 JPA(Java Persistence API)또한 Jakarta Persistence로 변경됐습니다.\n이름은 달라졌지만 역할은 달라지지 않았습니다. JPQL을 이용하여 관계형 데이터베이스의 엔티티를 정의하고 이를 활용한 쿼리 언어를 자바를 이용하여 구현합니다.\n더 나아가 Querydsl을 이용하면 좀 더 직관적이고 오류 없이 자바를 이용하여 작성할 수 있습니다.\n간단한 예시로 회원 조회를 하는 경우 JPQL과 Querydsl의 차이는 아래와 같습니다.\nJPQL\n1 2 3 4 5 6 public List\u0026lt;Member\u0026gt; findAll() { EntityManager entityManager; return entityManager.","title":"Spring Data JPA와 JPQL 함께 사용하기"},{"content":"Mybatis란? 자바의 관계형 데이터베이스 프로그래밍을 좀 더 쉽게 할 수 있게 도와 주는 개발 프레임 워크입니다.\nJDBC를 통해 데이터베이스에 엑세스하는 작업을 캡슐화하고 일반 SQL 쿼리, 저장 프로시저 및 고급 매핑을 지원하며 모든 JDBC 코드 및 매개 변수의 중복작업을 제거 합니다.\n또한 Java코드와 SQL코드를 분리하여 서로 다른 역할에 집중할 수 있게 합니다.\nMyBatis는 DAO(Data Access Object)인터페이스를 통해 SQL과 연결 후 VO(Value Object) 또는 DTO(Data Transfer Object)로 바로 데이터를 가져옵니다.\nJPA란? JPA(Java Persistence API)는 ORM(Object-Relational Mapping) 기술 표준으로 JPA가 제공하는 API를 사용하면 직접적으로 SQL을 사용하지 않고도 DB에 접근이 가능합니다.\nJPA는 반복적인 CRUD 작업을 이미 인터페이스에서 제공하고 있습니다. JPA를 제대로 사용하기 위해서는 약간의 러닝커브가 존재하지만 익숙해지면 빠른 개발과 유지보수 측면에서 효율적입니다.\nJPA는 Entity와 DTO(Data Transper Object)를 구분지어서 정의하는 것이 좋습니다. 컨트롤러에서는 DTO를 통해 유효성검사 및 FrontEnd와의 연결을 책임지며, DB와 관련된 것은 Entity로 제어 하는거죠. 이러한 Object Mapping은 직접 함수를 만들거나 라이브러리를 이용해도 됩니다.\n자주 사용하는 라이브러리는 Model Mapper와 Map Struct가 대표적이며, 성능 이슈가 적은 Map Struct 사용을 추천합니다.\n일반적으로 JPA는 Spring Data JPA와 Querydsl 조합을 많이 사용합니다.\nMabatis or JPA 그렇지만 현재의 구글 트렌드를 검색해보면 전세계적으로는 압도적으로 JPA가 우위에 있으며 우리나라의 경우는 비슷한 정도로 나타납니다.\nJPA와 MyBatis와의 차이점이라면 DB를 바라보는 관점이 다른 것 같습니다.\n서로의 장단점이 있기 때문에 프로젝트의 성격과 적합도에 맞게 선택하는 것이 좋을 것 같습니다.\nJPA가 조금 더 공부해야 할 것이 많긴 하지만 잘 이해하고 사용하면 유지보수하기 좋을 것 같다 생각합니다.😓\n","permalink":"https://haservi.github.io/posts/spring/mybatis-and-jpa/","summary":"Mybatis란? 자바의 관계형 데이터베이스 프로그래밍을 좀 더 쉽게 할 수 있게 도와 주는 개발 프레임 워크입니다.\nJDBC를 통해 데이터베이스에 엑세스하는 작업을 캡슐화하고 일반 SQL 쿼리, 저장 프로시저 및 고급 매핑을 지원하며 모든 JDBC 코드 및 매개 변수의 중복작업을 제거 합니다.\n또한 Java코드와 SQL코드를 분리하여 서로 다른 역할에 집중할 수 있게 합니다.\nMyBatis는 DAO(Data Access Object)인터페이스를 통해 SQL과 연결 후 VO(Value Object) 또는 DTO(Data Transfer Object)로 바로 데이터를 가져옵니다.\nJPA란? JPA(Java Persistence API)는 ORM(Object-Relational Mapping) 기술 표준으로 JPA가 제공하는 API를 사용하면 직접적으로 SQL을 사용하지 않고도 DB에 접근이 가능합니다.","title":"Mybatis와 JPA에 대하여"},{"content":"@Autowired는 필드 주입이고, @RequiredArgsConstructor는 생성자 주입(Constructor Injection) 입니다.\n@RequiredArgsConstructor는 Lombok에서 제공하는 어노테이션 입니다.\n결론적으로 생성자 주입을 권장합니다. 인텔리제이에서 코드를 작성하다보면 @Autowired를 사용하면 아래와 같은 경고를 알려줍니다.\n경고\nField injection is not recommended\nInspection info: Spring Team recommends: \u0026ldquo;Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies\u0026rdquo;.\n뭐.. 추천하지 않고 생성자 주입방식을 쓰라고 하는거 같네요.\n생성자 주입으로 코드를 작성하면 아래와 같은 장점이 있습니다.\n순환 참조 방지 테스트 코드 작성 용이 코드 악취 제거 객체 변이 방지 필드 주입방식을 쓰면 아래와 같은 단점이 있습니다.\n단일 책임의 원칙 위반 숨은 의존성 제공 의존성을 가진 클랙스를 곧바로 인스턴스화 할 수 없음 final을 선언할 수 없기 때문에 객체가 변할 수 있음 Lombok를 쓰면 아래와 같이 간단하게 처리 할 수 있습니다.\n1 2 3 4 5 6 7 @Controller @RequiredArgsConstructor public class ItemController { private final ItemService itemService; private final OrderService orderService; } 만약 Lombok을 사용하지 않으면 아래와 같이 처리해야 합니다. 아래와 같이 생성자가 1개인 경우는 @Autowired를 생략해도 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 @Controller public class ItemController { private final ItemService itemService; private final OrderService orderService; @Autowired public ItemController(final ItemService itemService, final OrderService orderService) { this.itemService = itemService; this.orderService = orderService; } } ","permalink":"https://haservi.github.io/posts/spring/diff-requiredargsconstructor-autowired/","summary":"@Autowired는 필드 주입이고, @RequiredArgsConstructor는 생성자 주입(Constructor Injection) 입니다.\n@RequiredArgsConstructor는 Lombok에서 제공하는 어노테이션 입니다.\n결론적으로 생성자 주입을 권장합니다. 인텔리제이에서 코드를 작성하다보면 @Autowired를 사용하면 아래와 같은 경고를 알려줍니다.\n경고\nField injection is not recommended\nInspection info: Spring Team recommends: \u0026ldquo;Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies\u0026rdquo;.\n뭐.. 추천하지 않고 생성자 주입방식을 쓰라고 하는거 같네요.\n생성자 주입으로 코드를 작성하면 아래와 같은 장점이 있습니다.\n순환 참조 방지 테스트 코드 작성 용이 코드 악취 제거 객체 변이 방지 필드 주입방식을 쓰면 아래와 같은 단점이 있습니다.","title":"@Autowired와 @RequiredArgsConstructor 차이점 "},{"content":"logitech options 란? 일부 로지텍 마우스 중에는 특정 소프트웨어를 지원하는 기능이 있습니다.\n그 중 logitech options는 Flow기능으로 기기간 파일전송이나 하나의 마우스로 여러대의 기기를 제어할 수 있습니다.\n이번에 소개해드릴 기능은 Flow기능이 아닌 마우스 제스처 모드에 따른 설정입니다.\n설치 해당 사이트에서 OS에 맞는 프로그램을 설치하면 됩니다.\n설치 후 정상적으로 마우스가 연결되면 아래와 비슷한 사진이 보입니다.\n커스텀 설정하기 프로그램 실행 후 흰색 동그라미가 있는 모든 버튼이 커스텀 가능합니다.\n저의 경우 뒤로가기와 앞으로가기 버튼만 커스텀하여 사용하고 있습니다.\n해당 프로그램은 특정 소프트웨어에서 다르게 커스텀을 적용할 수 있습니다. 아래는 제가 사용하는 입력할 키 지정 모드입니다.\n알림\n모든 이미지는 Windows를 기준으로 작성했으며, 응용 프로그램의 경우 공통 제스처모드이면 각각 설정값을 입력해야합니다.\n뒤로가기 버튼 뒤로가기 버튼의 제스처 모드는 2가지 입니다. 이것만 설정해도 매우 편하게 이용할 수 있습니다.\n공통 설명 제스처 Windows Mac 데스크탑 왼쪽 뒤로가기 버튼 클릭 + 왼쪽 이동 Ctrl + Window + ← control + ← 데스크탑 오른쪽 뒤로가기 버튼 클릭 + 오른쪽 이동 Ctrl + Window + → control + → 뒤로 뒤로가기 버튼 클릭 뒤로가기 뒤로가기 아래와 같이 설정했습니다.\n앞으로가기 버튼 앞으로가기 버튼의 경우 우측 상단의 프로그램마다 설정을 할 수 있습니다.\n코딩 시 디버깅을 할 때 IDE마다 조금씩 디버깅 버튼이 다를 수 있습니다. 그렇기 때문에 자주 사용하는 프로그램의 경우 디버깅 버튼을 단축키로 지정합니다.\n다음과 같이 모든 방향 제스처를 통일하였습니다.\n앞으로가기 버튼 클릭 + 위 : Step Out 앞으로가기 버튼 클릭 + 아래 : Step Into 앞으로가기 버튼 클릭 + 왼쪽 : Continue 앞으로가기 버튼 클릭 + 오른쪽 : Step Over 거의 대다수 프로그램이 위와 같은 디버깅 로직입니다. 그렇기 때문에 응용프로그램을 선택 후 입력할 키 지정만 올바르게 하면 IDE마다 동일한 제스처로 디버깅이 가능합니다.\n간단하게 Visual Studio Code와 Eclipse IntelliJ 정도만 설정하면 다음과 같습니다.\nSTS(Spring Tools) 설명 제스처 Windows Mac Step Out 앞으로가기 버튼 클릭 + 위 F7 F7 Step Into 앞으로가기 버튼 클릭 + 아래 F5 F5 Continue 앞으로가기 버튼 클릭 + 왼쪽 F8 F8 Step Over 앞으로가기 버튼 클릭 + 오른쪽 F6 F6 Visual Studio Code 설명 제스처 Windows Mac Step Out 앞으로가기 버튼 클릭 + 위 Shift + F11 Shift + F11 Step Into 앞으로가기 버튼 클릭 + 아래 F11 F11 Continue 앞으로가기 버튼 클릭 + 왼쪽 F5 F5 Step Over 앞으로가기 버튼 클릭 + 오른쪽 F10 F10 IntelliJ 설명 제스처 Windows Mac Step Out 앞으로가기 버튼 클릭 + 위 Shift + F8 Shift + F8 Step Into 앞으로가기 버튼 클릭 + 아래 F7 F7 Continue 앞으로가기 버튼 클릭 + 왼쪽 F9 F9 Step Over 앞으로가기 버튼 클릭 + 오른쪽 F8 F8 이외에도 마우스를 이용하여 다양한 옵션과 제스처를 설정할 수 있습니다.\n그 외 다른 프로그램 추천 해당 프로그램 이외에 mac에서 이용하면 좋은 프로그램은 아래와 같습니다.\nSnipaste(mac, window, linux) 사이트 링크 캡쳐 프로그램으로 가볍게 캡쳐하고 삭제가 가능(윈도우, 맥, 리눅스 모두 가능), 리뷰 Raycast(mac) 사이트 링크 단축키를 활용하여 생산성 향상 프로그램, 리뷰 Karabiner-Elements(mac) 사이트 링크 karabiner 프로그램으로 맥북 키보드 설정, 리뷰 Rectangle(mac) 사이트 링크 프로그램 화면 크기 조절 프로그램, 리뷰 Logitech Options(mac) 사이트 링크 Logitech 제품 마우스 커스텀 프로그램, 리뷰 Dbeaver(mac, window) 사이트 링크 DB 접근 제어 프로그램 일부 커스텀 방법, 리뷰 ScreeToGif(mac, window) 사이트 링크 간단하게 화면을 gif로 만드는 프로그램 소개, 리뷰 ","permalink":"https://haservi.github.io/posts/tools/how-to-logitech-option/","summary":"logitech options 란? 일부 로지텍 마우스 중에는 특정 소프트웨어를 지원하는 기능이 있습니다.\n그 중 logitech options는 Flow기능으로 기기간 파일전송이나 하나의 마우스로 여러대의 기기를 제어할 수 있습니다.\n이번에 소개해드릴 기능은 Flow기능이 아닌 마우스 제스처 모드에 따른 설정입니다.\n설치 해당 사이트에서 OS에 맞는 프로그램을 설치하면 됩니다.\n설치 후 정상적으로 마우스가 연결되면 아래와 비슷한 사진이 보입니다.\n커스텀 설정하기 프로그램 실행 후 흰색 동그라미가 있는 모든 버튼이 커스텀 가능합니다.\n저의 경우 뒤로가기와 앞으로가기 버튼만 커스텀하여 사용하고 있습니다.","title":"Logitech Options를 이용한 마우스 커스텀하기"},{"content":"Git Command를 사용하면서 자주 사용하는 명령어를 정리했습니다.\n이외에도 수많은 명령어가 존재하지만 작업과 관련된 명령어는 아래의 경우로 충분하다고 생각합니다.\n해당 명령어 이외에 더 참고하고 싶다면 https://git-scm.com/book/ko/v2 해당 사이트에서 무료로 책을 다운로드 받아서 볼 수 있습니다.\n또한, 요즘은 소스트리(https://www.sourcetreeapp.com/)에서 GUI로 편하게 작업할 수 도 있습니다.\n기본적인 명령어는 숙지하는 것이 좋지만 history나 간단한 업무용으로는 충분하다고 생각합니다.\n기본 명령어 git 설정 보기\n1 git config --list 사용자 이름 입력\n1 git config --global user.name \u0026#34;이름\u0026#34; 사용자 이메일 입력\n1 git config --global user.email \u0026#34;이메일\u0026#34; 자주쓰는 명령어 작업과 관련된 명령어 git branch 정보보기\n1 git branch -a git branch 변경하기\n1 git checkout 브랜치명 stash에 작업 코드 넣어두기\n1 2 3 git stash # 코드 넣기 git stash pop # 코드 빼기 git 코드 수정 관련 명령어 수정하거나 추가한 파일 모두 스테이지에 올리기\n1 2 3 4 5 // 전체 작업 한번에 올리기 git add -A // 특정 파일만 올리기 git add README.md(파일명) 스테이지에 올라간 코드 나의 작업에 Commit 하기\n1 git commit -m \u0026#34;작업한 코멘트\u0026#34; Git 작업 내역 확인하기\n1 git status Commit한 작업 내역 push 하기\n1 git push 자주는 안쓰지만 종종 써야하는 명령어 Git 삭제\n1 sudo apt-get remove git 이미 push한 최종 커밋 메시지 변경\n1 2 git commit --amend -m \u0026#34;변경할 메시지\u0026#34; git push origin 브랜치명 -f 가장 최근 push 제거\n1 2 3 git reset HEAD^ git commit -m \u0026#34;commit delete\u0026#34; git push origin 브랜치명 -f workspace작업 정보 stash에 저장\n1 git stash stash 목록 확인\n1 git stash list 가장 최근 stash 적용\n1 git stash apply 특정 stash 적용\n1 git stash apply [stash 이름] 가장 최근 stash 삭제\n1 git stash drop 특정 stash 삭제\n1 git stash drop [stash 이름] 설정과 관련된 명령어 한글 깨짐 현상 수정\n1 git config --global core.quotepath false Git 대소문자 인식(특정 git 폴더 내에서)\n1 git config core.ignorecase false ","permalink":"https://haservi.github.io/posts/tips/git-frequently-used-commands/","summary":"Git Command를 사용하면서 자주 사용하는 명령어를 정리했습니다.\n이외에도 수많은 명령어가 존재하지만 작업과 관련된 명령어는 아래의 경우로 충분하다고 생각합니다.\n해당 명령어 이외에 더 참고하고 싶다면 https://git-scm.com/book/ko/v2 해당 사이트에서 무료로 책을 다운로드 받아서 볼 수 있습니다.\n또한, 요즘은 소스트리(https://www.sourcetreeapp.com/)에서 GUI로 편하게 작업할 수 도 있습니다.\n기본적인 명령어는 숙지하는 것이 좋지만 history나 간단한 업무용으로는 충분하다고 생각합니다.\n기본 명령어 git 설정 보기\n1 git config --list 사용자 이름 입력\n1 git config --global user.name \u0026#34;이름\u0026#34; 사용자 이메일 입력","title":"자주 사용하는 Git Command 정리"},{"content":"Service, ServiceImpl Spring 프로젝트를 하면 종종 관례적으로 Service를 interface로 기능 명세를 한 뒤 ServiceImpl에 기능을 구현하게 되는 Factory Pattern을 사용하게 됩니다.\ninterface는 기능을 추상화하여 클래스간 결합도를 낮추어 주고, 협업 시 업무분담도 용이합니다.\n게임으로 예를 들면 스타크래프트에서 모든 유닛의 기본적인 특성 HP, 이동하기를 interface로 기능만 명시하고 각각 분업하여 유닛에 대한 HP나 이동속도를 구현할 수 있습니다.\n하지만 일반적인 Spring 웹프로젝트에서는 Service interface는 1:1 구조인 경우가 많습니다. 만약 확장성을 고려한 1:N의 경우에는 interface로 가는 것이 좋지만 너무 막연한 경우에는 그냥 class로 생성 후 추후 시나리오 변경 또는 로직상 확장성이 필요한 경우 interface로 변경하는 것이 좋다고 생각합니다.\n그렇다면 interface를 사용하는 경우는 어떤 경우에 사용해야할까요??\n보통 하나의 기능에서 여러 곳으로 파생되는 것을 interface로 나누는게 좋을 것 같습니다.\n예를 들어 소셜로그인, 패스워드 변경(개인정보수정, 패스워드찾기), 아이디 찾기(휴대폰 인증, 이메일 인증, 기타 등등), 카드 결제(카드사 별 결제 취소), 게임(게임별 플레이, 종료)등이 있습니다.\n공통적으로 쓰이는 기능을하나의 기능에서 충분히 확장될 수 있는 경우 interface를 사용하는 것이 좋습니다.\n로그인의 기능을 만들 때 Spring Security의 OAuth2를 이용하여 보통 기능 구현을 합니다.\n그렇지만 oauth2를 사용하지 않고 기능을 구현하는 경우를 샘플 코드를 이용하여 설명해보겠습니다.\n먼저 로그인 유형에 대한 정의를 합니다.\n1 2 3 4 5 6 7 public enum AuthProvider { local, google, kakao, github, naver } 그런 뒤 LoginService로 인터페이스를 생성합니다.\n1 2 3 public interface LoginService { LoginDto.Response login(LoginDto.Request dto); } 그리고 소셜에 따라 로그인 서비스에 맞게 구현 로직을 추가합니다. 이제 로그인 요청이 들어오면 해당 소셜 로그인이 동작하도록 LoginFactory 클래스를 생성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public LoginService getLoginType(LoginDto.Request dto) { if (dto == null) { return null; } if (dto.getAuthProvider().equals(AuthProvider.github)) { return new LoginGithubService(); } else if (dto.getAuthProvider().equals(AuthProvider.google)) { return new LoginGoogleService(); } else if (dto.getAuthProvider().equals(AuthProvider.kakao)) { return new LoginKakaoService(); } else if (dto.getAuthProvider().equals(AuthProvider.naver)) { return new LoginGoogleService(); } else if (dto.getAuthProvider().equals(AuthProvider.local)) { return new LoginLocalService(); } return null; } 안의 내용들은 구현하지 않고 해당 로직을 타는지 print만 했습니다.\n위와 같이 구현하면 dto 요청에서 소셜 로그인 정보와 일치하는 Service의 로직이 동작합니다.\nTest코드로 확인하기 위해 정상적으로 하는지 확인해봅니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Test void 로그인_타입_테스트() { LoginFactory loginFactory = new LoginFactory(); LoginDto.Request request = new LoginDto.Request(); LoginService loginService = new LoginLocalService(); request.setAuthProvider(AuthProvider.github); loginService = loginFactory.getLoginType(request); loginService.login(request); request.setAuthProvider(AuthProvider.google); loginService = loginFactory.getLoginType(request); loginService.login(request); request.setAuthProvider(AuthProvider.kakao); loginService = loginFactory.getLoginType(request); loginService.login(request); request.setAuthProvider(AuthProvider.naver); loginService = loginFactory.getLoginType(request); loginService.login(request); request.setAuthProvider(AuthProvider.local); loginService = loginFactory.getLoginType(request); loginService.login(request); } 테스트 코드를 통해 service가 정상적으로 동작하는지 확인 할 수 있습니다.\nReference https://www.manty.co.kr/bbs/detail/develop?id=13 https://itzjamie96.github.io/2021/01/24/spring-service-and-serviceimpl/ https://cheese10yun.github.io/spring-oop-04/ https://blog.jiniworld.me/55 https://www.tutorialspoint.com/design_pattern/factory_pattern.htm ","permalink":"https://haservi.github.io/posts/spring/service-and-serviceimp/","summary":"Service, ServiceImpl Spring 프로젝트를 하면 종종 관례적으로 Service를 interface로 기능 명세를 한 뒤 ServiceImpl에 기능을 구현하게 되는 Factory Pattern을 사용하게 됩니다.\ninterface는 기능을 추상화하여 클래스간 결합도를 낮추어 주고, 협업 시 업무분담도 용이합니다.\n게임으로 예를 들면 스타크래프트에서 모든 유닛의 기본적인 특성 HP, 이동하기를 interface로 기능만 명시하고 각각 분업하여 유닛에 대한 HP나 이동속도를 구현할 수 있습니다.\n하지만 일반적인 Spring 웹프로젝트에서는 Service interface는 1:1 구조인 경우가 많습니다. 만약 확장성을 고려한 1:N의 경우에는 interface로 가는 것이 좋지만 너무 막연한 경우에는 그냥 class로 생성 후 추후 시나리오 변경 또는 로직상 확장성이 필요한 경우 interface로 변경하는 것이 좋다고 생각합니다.","title":"[Spring] Service와 ServiceImpl에 대해"},{"content":"기본적으로 웹상에서는 Git 저장소 안의 폴더를 다운받으려면 해당 저장소 전부를 다운 받은 후에 특정 폴더의 정보를 봐야 합니다.\n간단한 방법은 아래의 링크에서 다운로드 받는게 제일 쉬운방법이지만 터미널에서 다운로드 방법도 한번 다루어보겠습니다. 터미널로 다운 받은 경우 이후 해당 소스가 변경이 있다면 당겨올 수 있는 이점도 있습니다.\n해결방법 웹 다운로드 https://downgit.github.io/#/home 해당 사이트에 github 저장소 특정 폴더의 링크를 복사 한 후 붙여넣고 Download 버튼 클릭\n터미널 다운로드 기본적으로 git이 설치돼 있어야합니다.\n예제로 https://github.com/android/architecture-components-samples/tree/main/NavigationAdvancedSample 해당 저장소를 다운받는다고 가정하겠습니다.\n폴더 생성 후 이동\n1 2 mkdir sample-code1 cd sample-code1 git 초기화\n1 git init git checkout 설정 변경\n1 git config core.sparseCheckout true 원하는 git 저장소 추가\n1 git remote add -f origin https://github.com/android/architecture-components-samples.git 원하는 특정 폴더 저장소 선택(window)\n1 echo NavigationAdvancedSample/* \u0026gt; .git/info/sparse-checkout 원하는 특정 폴더 저장소 선택(ubuntu)\n1 echo \u0026#34;NavigationAdvancedSample/*\u0026#34; \u0026gt; .git/info/sparse-checkout git 당기기(특정 브렌치 정보)\n1 git pull origin main 사소한 이슈이지만 Windows에서는 경로를 인용해서는 안된다고 하네요. 그렇기 때문에 \u0026ldquo;\u0026ldquo;을 붙이면 안됩니다(참고)\n","permalink":"https://haservi.github.io/posts/tips/git-inner-folder-download/","summary":"기본적으로 웹상에서는 Git 저장소 안의 폴더를 다운받으려면 해당 저장소 전부를 다운 받은 후에 특정 폴더의 정보를 봐야 합니다.\n간단한 방법은 아래의 링크에서 다운로드 받는게 제일 쉬운방법이지만 터미널에서 다운로드 방법도 한번 다루어보겠습니다. 터미널로 다운 받은 경우 이후 해당 소스가 변경이 있다면 당겨올 수 있는 이점도 있습니다.\n해결방법 웹 다운로드 https://downgit.github.io/#/home 해당 사이트에 github 저장소 특정 폴더의 링크를 복사 한 후 붙여넣고 Download 버튼 클릭\n터미널 다운로드 기본적으로 git이 설치돼 있어야합니다.\n예제로 https://github.","title":"Github 저장소 안의 폴더 다운로드 받는 방법"},{"content":"작업의 효율을 높이기 위해 기존 화면에서 필요한 정보를 잠시 동안 캡쳐하는 방법이 있습니다.\n캡쳐프로그램은 정말 다양하게 존재하는데요. 예를 들어 알캡쳐, picpic, 윈도우 기본 내장 캡쳐, pureRef, snipaste 등 많이 있습니다.\n저 같은 경우 포스팅 할 때 화면캡쳐 용도로는 picpick을 자주 이용하며, 업무 중 필요한 정보를 캡쳐 할 때는 snipaste를 사용합니다.\npicpick의 경우는 워낙 잘 알려져 있기 때문에 snipaste에 대해 알아보겠습니다.\nSnipaste (download link) Snipaste는 특정 화면을 지정하여 캡쳐하여 화면에 띄워놓을 수 있습니다.\nWindows는 지원하고 있으며, Mac의 경우 Beta테스트를 하는 것 같네요.\n기본적인 기능으로는 특정 화면 캡쳐, 캡쳐 화면 Color Picker, 캡쳐 화면 확대 축소, 캡쳐 화면 투명도 조절, 캡쳐 화면 저장, 캡쳐 화면 Annotation 지정 등이 있습니다.\n기본 버전으로도 충분히 이용할 수 있지만, pro버전 도 지원을 하는 것 같습니다.\n설치 방법 해당 사이트에서 다운로드 후 설치하시면 됩니다.\n사용방법 기본적인 사용방법은 설치 후 F1로 화면 선택 또는 영역 지정 후 화면에서 더블 클릭 후 F3을 눌러 출력하면 됩니다.\n단축키를 변경 할 수도 있으며, 위를 이용하면 다양한 용도로 사용 할 수 있을 것이라 생각됩니다.\n제 경우 자주 사용하는 용도로는 변수 참조용 또는 퍼블리싱 디자인 또는 유용한 디자인을 참조할 때 자주 쓰는 것 같습니다.\n이외에도 잘 활용하면 여러모로 쾌적한 이용할 수 있습니다. 그 중 자주 사용하는 기본 단축키입니다.\n화면 캡쳐: F1 후 영역 더블클릭 또는 클릭 후 드레그 하여 화면 지정 후 더블클릭 화면 불러오기: F1 저장 후 F3 캡쳐 화면 이동: F3으로 불러오 화면에서 마우스 좌클릭 후 이동 캡쳐 화면 이동: F3으로 불러오 화면에서 마우스 휠 조정 캡쳐 화면 색상 확인: F3으로 불러온 화면에서 Alt키를 누른 후 원하는 색상에서 C버튼 클릭(복사됨) 캡쳐 화면 투명도 조절: F3으로 불러온 화면에서 Ctrl키를 누른 후 마우스 휠 조정 캡쳐 화면 주석 추가: F3으로 불러온 화면에서 Annotation 선택 후 그림도구 사용 그 외 다른 프로그램 추천 해당 프로그램 이외에 mac에서 이용하면 좋은 프로그램은 아래와 같습니다.\nSnipaste(mac, window, linux) 사이트 링크 캡쳐 프로그램으로 가볍게 캡쳐하고 삭제가 가능(윈도우, 맥, 리눅스 모두 가능), 리뷰 Raycast(mac) 사이트 링크 단축키를 활용하여 생산성 향상 프로그램, 리뷰 Karabiner-Elements(mac) 사이트 링크 karabiner 프로그램으로 맥북 키보드 설정, 리뷰 Rectangle(mac) 사이트 링크 프로그램 화면 크기 조절 프로그램, 리뷰 Logitech Options(mac) 사이트 링크 Logitech 제품 마우스 커스텀 프로그램, 리뷰 Dbeaver(mac, window) 사이트 링크 DB 접근 제어 프로그램 일부 커스텀 방법, 리뷰 ScreeToGif(mac, window) 사이트 링크 간단하게 화면을 gif로 만드는 프로그램 소개, 리뷰 ","permalink":"https://haservi.github.io/posts/tools/how-to-capture/","summary":"작업의 효율을 높이기 위해 기존 화면에서 필요한 정보를 잠시 동안 캡쳐하는 방법이 있습니다.\n캡쳐프로그램은 정말 다양하게 존재하는데요. 예를 들어 알캡쳐, picpic, 윈도우 기본 내장 캡쳐, pureRef, snipaste 등 많이 있습니다.\n저 같은 경우 포스팅 할 때 화면캡쳐 용도로는 picpick을 자주 이용하며, 업무 중 필요한 정보를 캡쳐 할 때는 snipaste를 사용합니다.\npicpick의 경우는 워낙 잘 알려져 있기 때문에 snipaste에 대해 알아보겠습니다.\nSnipaste (download link) Snipaste는 특정 화면을 지정하여 캡쳐하여 화면에 띄워놓을 수 있습니다.","title":"화면 캡쳐 프로그램 추천"},{"content":"Windows WSL Ubuntu 커스텀 하기 Window에서는 WSL(Windows Subsystem for Linux)를 제공합니다.\n예전엔 가상환경(VM)에 리눅스를 올렸다면 지금은 손쉽게 리눅스 커널을 WSL로 접근할 수 있게 됐습니다.\n그렇기 때문에 웹개발을 한다면 Window에서 개발하여 WSL에 배포 테스트를 손쉽게? 할 수 있는 환경을 구축 할 수 있습니다. 예를 들어 웹의 경우 Backend, Frontend, DB 같은 환경을 Docker로 설정하여 WSL에 올린 뒤 바로 배포가 성공했다면 이러한 설정을 그대로 AWS나 Azure에 적용할 수 있습니다.\n해당 글은 단지 커스텀에 대한 이야기이지만 추후 위와 같은 방법으로 배포테스트도 한 번 다뤄볼 생각입니다.\n먼저 이 글대로 설정을 마칠 경우 아래와 같은 터미널을 얻을 수 있습니다. 😮\n설치 방법 1. Ubuntu 설치 Window Store에서 Ubuntu를 설치합니다. 2. zsh 설치 먼저 ubuntu 업데이트를 진행합니다. 1 2 sudo apt-get install sudo apt-get update zsh를 기본 셸로 설정합니다. 1 sudo chsh -s $(which zsh) 실행 시 zsh를 실행되도록 지정합니다. 1 sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 3. Meslo Nerd Font 설치 해당 폰트를 사용하지 않으면 powerlevel10k 테마의 아이콘이 표시되지 않습니다.\n아래 링크를 통해 MesloLGS NF 폰트를 다운로드 받아주세요.\nromkatv/powerlevel10k 다운받은 폰트를 Ubuntu에서 폰트를 변경합니다. 상단에서 마우스 우클릭 후 속성을 누른 뒤 폰트를 변경 할 수 있습니다. 4. powerlever10k 설치 zsh를 설치하면 oh-my-zsh라는 폴더가 생깁니다. 해당 폴더에 아래의 테마를 설치합니다. 1 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 설치 후 편집기를 이용하여 테마를 변경합니다. 1 vim ~/.zshrc 기존 테마인 ZSH_THEME=\u0026ldquo;robbyrussell\u0026quot;를 ZSH_THEME=\u0026ldquo;powerlevel10k/powerlevel10k\u0026rdquo; 로 변경합니다.(i를 누르면 편집이 가능하며, 수정이 완료된 뒤 ESC를 누르고 :wq 입력) 1 ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; 적용을 하셨다면 해당 창을 종료 후 다시 시작하면 아래와 같이 나오게 됩니다.\n(만약 나오지 않은 경우 명령어 source ~/.zshrc 입력) 여기서 본인의 스타일에 맞게 ()안의 답을 선택하면 됩니다. 만약 설정을 잘못하셨거나 바꾸고 싶다면 아래의 커맨드를 입력하시면 됩니다.\n1 p10k configure 5. 폴더 아이콘 테마 변경 해당 테마를 변경하기 위해서는 ruby를 설치하여 colorls를 설치해야 합니다. 1 sudo apt-get install ruby-full colorls를 설치합니다.(만약 아래의 명령어가 안되거나 우분투 20.04 이상 버전인 경우는 sudo apt install gcc make 커맨드 입력 후 다시 설치하시면 됩니다.) 1 sudo gem install colorls 설치가 완료됐으면 ~/.zshrc 가장 하단에 아래 코드를 추가합니다. 1 2 source $(dirname $(gem which colorls))/tab_complete.sh alias ls=colorls 6. fzf 설치 fzf는 zsh의 확장팩? 같은 느낌입니다. 일단 속도가 매우 빠릅니다.(golang??)\n터미널에서 파일검색, 명령 기록, 프로세스, 호스트 이름, 책갈피 등 다양한 기능이 있습니다.\n몇가지 자주쓰는 명령어로\nctrl + r 커맨드에서 사용한 명령어 history 리스트 출력 ctrl + t 해당 폴더의 디렉토리 또는 파일 검색 vim $(fzf) 해당 폴더 안의 검색된 파일 열기 cd 스페이스 ctrl + t 검색 후 폴더 이동 이것 외에도 fzf내에서 플러그인을 설치하여 탐색기처럼 이용할 수도 있고, 프로세스 kill 등 다양한 방법이 있는데 저도 아직 제대로 활용은 못하는 것 같습니다\u0026hellip;\n이와 관련된 링크로 대체하겠습니다. 😓\n윈도우 터미널 테마 변경 WSL를 설치하면 store에 있는 윈도우 터미널도 WSL을 선택할 수 있습니다. 이와 관련하여 테마를 설정할 수 있습니다.\n1. 터미널 색상 변경 기본적으로 터미널의 색을 바꾸고 싶다면 위와 같이 설정에 들어가서 json 파일 선택 후 defaults 제이슨 값에\n1 2 3 4 \u0026#34;defaults\u0026#34;: { // color theme \u0026#34;colorScheme\u0026#34;: \u0026#34;Campbell\u0026#34; }, 해당 테마이름을 지정하고, profiles제이슨 항목 안에\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026#34;schemes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Campbell\u0026#34;, \u0026#34;cursorColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;selectionBackground\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#0C0C0C\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#CCCCCC\u0026#34;, \u0026#34;black\u0026#34;: \u0026#34;#0C0C0C\u0026#34;, \u0026#34;blue\u0026#34;: \u0026#34;#4b6ed6\u0026#34;, \u0026#34;cyan\u0026#34;: \u0026#34;#3A96DD\u0026#34;, \u0026#34;green\u0026#34;: \u0026#34;#C50F1F\u0026#34;, \u0026#34;purple\u0026#34;: \u0026#34;#881798\u0026#34;, \u0026#34;red\u0026#34;: \u0026#34;#C50F1F\u0026#34;, \u0026#34;white\u0026#34;: \u0026#34;#CCCCCC\u0026#34;, \u0026#34;yellow\u0026#34;: \u0026#34;#C19C00\u0026#34;, \u0026#34;brightBlack\u0026#34;: \u0026#34;#767676\u0026#34;, \u0026#34;brightBlue\u0026#34;: \u0026#34;#3B78FF\u0026#34;, \u0026#34;brightCyan\u0026#34;: \u0026#34;#61D6D6\u0026#34;, \u0026#34;brightGreen\u0026#34;: \u0026#34;#16C60C\u0026#34;, \u0026#34;brightPurple\u0026#34;: \u0026#34;#B4009E\u0026#34;, \u0026#34;brightRed\u0026#34;: \u0026#34;#E74856\u0026#34;, \u0026#34;brightWhite\u0026#34;: \u0026#34;#F2F2F2\u0026#34;, \u0026#34;brightYellow\u0026#34;: \u0026#34;#F9F1A5\u0026#34; } ], 이렇게 지정해주면 됩니다. 공식 사이트(링크) 에서도 참조하면 좋을 것 같습니다.\n위와 같은 방법으로 다른 테마를 적용하고 싶다면, https://windowsterminalthemes.dev/ 에서 원하는 테마를 복사하셔도 됩니다.\n2. 터미널 배경 변경 터미널 배경을 변경하고 싶으면 아래와 같이 설정해주시면 됩니다.\n1 2 3 4 5 \u0026#34;defaults\u0026#34;: { \u0026#34;acrylicOpacity\u0026#34; : 0.4, \u0026#34;backgroundImage\u0026#34;: \u0026#34;D:/ProgramFiles/Images/cool-wallpaper-preview-1.jpg\u0026#34;, \u0026#34;backgroundImageOpacity\u0026#34;: 0.4 }, 3. 글꼴 변경 해당 글꼴을 넣어줘야 powerlink10k에서 아이콘을 볼 수 있습니다.\n1 2 3 4 \u0026#34;defaults\u0026#34;: { \u0026#34;fontFace\u0026#34; : \u0026#34;MesloLGS NF\u0026#34;, \u0026#34;fontSize\u0026#34; : 13 }, 탐색기에 WSL 연결하기 탐색기 주소창에 아래의 주소값을 입력합니다. 1 \\\\wsl$ Unbutu 폴더에서 우측마우스 클릭 후 네트워크 드라이브 연결을 선택한다. 연결 후 원하는 이름으로 변경하면 탐색기에서 WSL에 접근이 가능합니다. 에러 관련 아래와 같은 에러가 발생하면 1 bash: ll: command not found 이렇게 명령어를 입력하면 해결됩니다. 1 2 echo \u0026#34;alias ll=\u0026#39;ls -lGaf\u0026#39;\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile 이상으로 윈도우에서 WSL 우분투 터미널 꾸미는 방법에 대해 알아보았습니다.\nReference Setting up Windows Terminal, WSL and Oh-my-Zsh - Ivo\u0026rsquo;s Blog! https://snowdeer.github.io/mac-os/2018/11/04/how-to-use-fzf/ fzf Github WSL 동작 원리 FZF 터미널 사용 방법 ","permalink":"https://haservi.github.io/posts/linux/used-zsh-powerline10/","summary":"Windows WSL Ubuntu 커스텀 하기 Window에서는 WSL(Windows Subsystem for Linux)를 제공합니다.\n예전엔 가상환경(VM)에 리눅스를 올렸다면 지금은 손쉽게 리눅스 커널을 WSL로 접근할 수 있게 됐습니다.\n그렇기 때문에 웹개발을 한다면 Window에서 개발하여 WSL에 배포 테스트를 손쉽게? 할 수 있는 환경을 구축 할 수 있습니다. 예를 들어 웹의 경우 Backend, Frontend, DB 같은 환경을 Docker로 설정하여 WSL에 올린 뒤 바로 배포가 성공했다면 이러한 설정을 그대로 AWS나 Azure에 적용할 수 있습니다.\n해당 글은 단지 커스텀에 대한 이야기이지만 추후 위와 같은 방법으로 배포테스트도 한 번 다뤄볼 생각입니다.","title":"윈도우 WSL2 Ubuntu 터미널 꾸미기"},{"content":"ddl-auto 란 JPA에서는 기본적으로 Entity에 테이블을 매핑하면 쿼리를 사용하지 않고 값을 가져올 수 있습니다.\n설정 옵션으로\n1 2 3 jpa: hibernate: ddl-auto: create #create-drop, update, validate, none 각각의 옵션을 봐보면 아래와 같습니다.\ncreate : SessionFactory 시작시 스키마를 삭제하고 다시 생성 create-drop : SessionFactory 종료 시 스키마를 삭제 update : SessionFactory 연결된 DB와 비교하여 추가된 항목은 추가 만약 같은 변수명이면 오류발생 validate : SessionFactory 시작시 객체구성과 스키마가 다르다면 예외 발생 none: 아무것도 안함 실제 서비스 배포시에는 create, create-drop, update 와 같은 옵션을 사용하면 안되지만 개발 초기 테스트시에는 유용하게 사용할 수 있습니다.\n샘플데이터 추가 방법 그렇지만 데이터 테이블만 생기고 데이터가 없으니 오히려 테스트하기 불편한 점이 있습니다.\n그렇기에 찾아보니 역시 당연하게도.. resources 폴더에 import.sql 파일을 추가하면 hibernate에서 알아서 해당 더미데이터 쿼리를 찾아 실해시켜줍니다.\n만약 특정 파일을 지정하고 싶다면 아래와 같이\n1 2 3 4 5 6 7 8 jpa: properties: hibernate: hbm2ddl: import_files: classpath:db/data.sql # DB 파일 명시적으로 선택 import_files_sql_extractor: org.hibernate.tool.hbm2ddl.MultipleLinesSqlCommandExtractor # 멀티 라인 입력 가능하도록 connection: charSet: UTF-8 # 인코딩 설정 파일명을 명시주면 create에 자동으로 해당 데이터를 insert 할 수 있습니다.\n예제 만약 아래와 같이 user 테이블이 있다면..\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import java.time.LocalDateTime; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; import lombok.AccessLevel; import lombok.Builder; import lombok.Getter; import lombok.NoArgsConstructor; import org.hibernate.annotations.ColumnDefault; import org.hibernate.annotations.DynamicUpdate; @NoArgsConstructor(access = AccessLevel.PROTECTED) @Getter @Entity @DynamicUpdate @Table(name = \u0026#34;user\u0026#34;) public class UserEntity { @Id @GeneratedValue(strategy= GenerationType.IDENTITY) @Column(nullable = false, updatable = false) private Long userSno; @Column(length = 20, nullable = false, unique = true) private String userId; @Column(length = 20) private String userName; @Column(length = 20, nullable = false) private String password; @Column(length = 30) private String email; @Column(nullable = false, updatable = false, insertable = false, columnDefinition = \u0026#34;TIMESTAMP DEFAULT CURRENT_TIMESTAMP\u0026#34;) private LocalDateTime createDt; @Column(nullable = false, updatable = false, insertable = false) @ColumnDefault(\u0026#34;0\u0026#34;) private int useYn; @Builder public UserEntity(Long userSno, String userId, String userName, String password, String email) { this.userSno = userSno; this.userId = userId; this.userName = userName; this.password = password; this.email = email; } } import.sql파일 또는 지정한 sql파일에 아래와 같이 코드를 추가해주면 빌드 시 자동적으로 데이터를 넣을 수 있습니다.\n1 2 insert into `user` (`email`, `password`, `user_id`, `user_name`) values (\u0026#39;admin@admin.com\u0026#39;, \u0026#39;$2a$10$dyiw3YfbmBkHlUdbgWhsYesqniOsXo71KBzF75le5.YtS/rsrsM22\u0026#39;, \u0026#39;admin\u0026#39;, \u0026#39;관리자\u0026#39;); insert into `user` (`email`, `password`, `user_id`, `user_name`) values (\u0026#39;test@test.com\u0026#39;, \u0026#39;$2a$10$PMc5QFOUViVsGmsNMQqUzOuQG2rZ2wUJjSTRGFkBo9jZR/CSnQ03K\u0026#39;, \u0026#39;test\u0026#39;, \u0026#39;테스트\u0026#39;); 주의할 점은 실제 배포시에는 꼭 ddl-auto를 none으로 해야 합니다.\nddl-auto의 경우 초기 DB 설정 및 간단한 테스트에서만 쓰는게 좋습니다.\n","permalink":"https://haservi.github.io/posts/spring/hibernate-ddl-auto/","summary":"ddl-auto 란 JPA에서는 기본적으로 Entity에 테이블을 매핑하면 쿼리를 사용하지 않고 값을 가져올 수 있습니다.\n설정 옵션으로\n1 2 3 jpa: hibernate: ddl-auto: create #create-drop, update, validate, none 각각의 옵션을 봐보면 아래와 같습니다.\ncreate : SessionFactory 시작시 스키마를 삭제하고 다시 생성 create-drop : SessionFactory 종료 시 스키마를 삭제 update : SessionFactory 연결된 DB와 비교하여 추가된 항목은 추가 만약 같은 변수명이면 오류발생 validate : SessionFactory 시작시 객체구성과 스키마가 다르다면 예외 발생 none: 아무것도 안함 실제 서비스 배포시에는 create, create-drop, update 와 같은 옵션을 사용하면 안되지만 개발 초기 테스트시에는 유용하게 사용할 수 있습니다.","title":"JPA ddl-auto 설정과 더미데이터 생성 방법"},{"content":"간단하게 무거운 프로그램을 이용하지 않고 영상을 gif로 만드는 방법입니다.\n위 프로그램을 다운로드 받아서 설치하면 됩니다.\n설치 방법(Window) https://www.screentogif.com/ 사이트에 접속하셔서 다운로드 합니다.\n다운로드 후 설치 합니다.\n설치가 완료되면 실행합니다.\n위와 같은 화면에서 선택 영역을 지정(예시: 메모장)하고 녹화를 누르면 아래와 같이 나타납니다.\n여기서 그냥 녹화를 누른뒤 진행하면 됩니다.\n녹화를 마치고 정지를 누르시면 아래와 같은 화면이 나타납니다.\n저 같은 경우 초당 30프레임으로 설정하여서 5초짜리 영상에 대략 150프레임의 스크린샷이 찍혔습니다. 많약 더 부드럽게 만드시고 싶다면 프레임을 올리면 됩니다.\n그리고 각각의 프레임들은 모두 제거가 가능하기 때문에 쓸모없는 동작들의 프레임을 제거 할 수 있습니다.\n편집 작업이 끝나고 상단의 파일의 저장 버튼을 누르시면 됩니다.\n최종적으로 아래와 같이 애니메이션 화면을 볼 수 있습니다.\n간단하게 gif를 만들 일이 있으면 위 프로그램을 이용하면 쉽게 만들 수 있습니다.\n그 외 다른 프로그램 추천 해당 프로그램 이외에 mac에서 이용하면 좋은 프로그램은 아래와 같습니다.\nSnipaste(mac, window, linux) 사이트 링크 캡쳐 프로그램으로 가볍게 캡쳐하고 삭제가 가능(윈도우, 맥, 리눅스 모두 가능), 리뷰 Raycast(mac) 사이트 링크 단축키를 활용하여 생산성 향상 프로그램, 리뷰 Karabiner-Elements(mac) 사이트 링크 karabiner 프로그램으로 맥북 키보드 설정, 리뷰 Rectangle(mac) 사이트 링크 프로그램 화면 크기 조절 프로그램, 리뷰 Logitech Options(mac) 사이트 링크 Logitech 제품 마우스 커스텀 프로그램, 리뷰 Dbeaver(mac, window) 사이트 링크 DB 접근 제어 프로그램 일부 커스텀 방법, 리뷰 ScreeToGif(mac, window) 사이트 링크 간단하게 화면을 gif로 만드는 프로그램 소개, 리뷰 ","permalink":"https://haservi.github.io/posts/tools/how-to-create-gif/","summary":"간단하게 무거운 프로그램을 이용하지 않고 영상을 gif로 만드는 방법입니다.\n위 프로그램을 다운로드 받아서 설치하면 됩니다.\n설치 방법(Window) https://www.screentogif.com/ 사이트에 접속하셔서 다운로드 합니다.\n다운로드 후 설치 합니다.\n설치가 완료되면 실행합니다.\n위와 같은 화면에서 선택 영역을 지정(예시: 메모장)하고 녹화를 누르면 아래와 같이 나타납니다.\n여기서 그냥 녹화를 누른뒤 진행하면 됩니다.\n녹화를 마치고 정지를 누르시면 아래와 같은 화면이 나타납니다.\n저 같은 경우 초당 30프레임으로 설정하여서 5초짜리 영상에 대략 150프레임의 스크린샷이 찍혔습니다. 많약 더 부드럽게 만드시고 싶다면 프레임을 올리면 됩니다.","title":"영상을 gif로 만드는 방법"},{"content":"조이스틱 문제 설명 조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.\nex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA\n조이스틱을 각 방향으로 움직이면 아래와 같습니다.\n1 2 3 4 ▲ - 다음 알파벳 ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로) ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서) ▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 \u0026ldquo;JAZ\u0026quot;를 만들 수 있습니다.\n1 2 3 4 - 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다. - 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다. - 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다. 따라서 11번 이동시켜 \u0026#34;JAZ\u0026#34;를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.\n제한 사항 name은 알파벳 대문자로만 이루어져 있습니다. name의 길이는 1 이상 20 이하입니다. 입출력 예 name return \u0026ldquo;JEROEN\u0026rdquo; 56 \u0026ldquo;JAN\u0026rdquo; 23 출처 ※ 공지 - 2019년 2월 28일 테스트케이스가 추가되었습니다.\n문제 풀이 리뷰 기본적으로 모든 알파벳 위치에서의 최소거리를 구하고, 바로앞의 A가 있다면 해당 값을 제외한 뒤에 거리를 정의해야한다.\n또한, 해당 인덱스의 위치에서 정방향과 역방향에서 둘 중의 거리가 짧은 곳을 구한 뒤 바로앞의 A를 제외한 총이동거리를 더하는 부분이 중요하다.\n그렇게 모든 알파벳의 좌우 이동 최소거리 중 가장작은 값을 상하 알파벳 이동값과 더하여 주면된다.\nSource code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public int solution(String name) { int answer = 0; int nameLength = name.length(); int changeAlpabatCount = 0; for (int i = 0; i \u0026lt; nameLength; i++) { // 알파벳 변경 시 최소값 선정 후 화살표 위아래 변경 횟수 추가 changeAlpabatCount += Math.min(name.charAt(i) - \u0026#39;A\u0026#39;, \u0026#39;Z\u0026#39; - name.charAt(i) + 1); } // 알파벳의 정방향 최대 이동거리를 최소거리로 지정 int minMove = nameLength - 1; for (int i = 0; i \u0026lt; nameLength; i++) { int next = i + 1; int nextCountA = 0; while (next \u0026lt; nameLength \u0026amp;\u0026amp; name.charAt(next) == \u0026#39;A\u0026#39;) { next++; nextCountA++; } // 0번쨰 인덱스에서 앞의 A를 제외하고 이동한 거리 int moveWithoutA = name.length() - nextCountA - 1; // System.out.println(\u0026#34;movewithA:\u0026#34; + moveWithoutA); // 처음부터 i번째 까지 왔다가 돌아가는 방식과 뒤에서 출발하여 i번째 까지 오는 방식중 작은 값 선택 int min = Math.min(i, name.length() - next); // 알파벳을 순회하며 작은 값을 선택 minMove = Math.min(minMove, moveWithoutA + min); // System.out.println(i + \u0026#34;번째값의 평균 이동 거리는 \u0026#34; + (moveWithoutA + min) + \u0026#34;이다.\u0026#34;); } // System.out.println(\u0026#34;총 알파벳 변경 회수는 \u0026#34; + changeAlpabatCount + \u0026#34;이며, 최소이동 거리는 \u0026#34; + minMove + \u0026#34;이다.\u0026#34;); answer = (changeAlpabatCount + minMove); return answer; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level2/03-joystick/","summary":"조이스틱 문제 설명 조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.\nex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA\n조이스틱을 각 방향으로 움직이면 아래와 같습니다.\n1 2 3 4 ▲ - 다음 알파벳 ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로) ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서) ▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 \u0026ldquo;JAZ\u0026quot;를 만들 수 있습니다.","title":"[프로그래머스]조이스틱"},{"content":"다리를 지나는 트럭 문제 설명 트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다.\n모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다.\n다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다.\n단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다.\n예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.\n경과 시간 다리를 지난 트럭 다리를 건너는 트럭 대기 트럭 0 [] [] [7,4,5,6] 1~2 [] [7] [4,5,6] 3 [7] [4] [5,6] 4 [7] [4,5] [6] 5 [7,4] [5] [6] 6~7 [7,4,5] [6] [] 8 [7,4,5,6] [] [] 따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다.\nsolution 함수의 매개변수로 다리에 올라갈 수 있는 트럭 수 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭 별 무게 truck_weights가 주어집니다.\n이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요.\n제한 조건 bridge_length는 1 이상 10,000 이하입니다. weight는 1 이상 10,000 이하입니다. truck_weights의 길이는 1 이상 10,000 이하입니다. 모든 트럭의 무게는 1 이상 weight 이하입니다. 입출력 예 bridge_length weight truck_weights return 2 10 [7,4,5,6] 8 100 100 [10] 101 100 100 [10,10,10,10,10,10,10,10,10,10] 110 문제 풀이 리뷰 Java Source Code 트럭이 모두 다리를 건너가야 하기 때문에 트럭의 횟수만큼 순회한다. 다리를 지날 때는 트럭큐를 이용하며, 시간을 계속 추가한다. 마지막 트럭의 경우 지나갈 때 다리의 길이만큼 시간을 소모하기 때문에 처음에 다리의 길이만큼 값을 더해주었다. ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level2/02-truck-crossing-the-bridge/","summary":"다리를 지나는 트럭 문제 설명 트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다.\n모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다.\n다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다.\n단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다.\n예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.","title":"[프로그래머스]다리를 지나는 트럭"},{"content":"위장 문제 설명 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.\n예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.\n종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.\n제한사항 clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 \u0026lsquo;_\u0026rsquo; 로만 이루어져 있습니다. 스파이는 하루에 최소 한 개의 의상은 입습니다. 입출력 예 clothes return [[\u0026ldquo;yellowhat\u0026rdquo;, \u0026ldquo;headgear\u0026rdquo;], [\u0026ldquo;bluesunglasses\u0026rdquo;, \u0026ldquo;eyewear\u0026rdquo;], [\u0026ldquo;green_turban\u0026rdquo;, \u0026ldquo;headgear\u0026rdquo;]] 5 [[\u0026ldquo;crowmask\u0026rdquo;, \u0026ldquo;face\u0026rdquo;], [\u0026ldquo;bluesunglasses\u0026rdquo;, \u0026ldquo;face\u0026rdquo;], [\u0026ldquo;smoky_makeup\u0026rdquo;, \u0026ldquo;face\u0026rdquo;]] 3 입출력 예 설명 예제 #1\nheadgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다.\n1 2 3 4 5 1. yellow_hat 2. blue_sunglasses 3. green_turban 4. yellow_hat + blue_sunglasses 5. green_turban + blue_sunglasses 예제 #2 face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다.\n1 2 3 1. crow_mask 2. blue_sunglasses 3. smoky_makeup 문제 풀이 문제 풀이 리뷰 확률 문제이다. 예를 들어 정육각형 주사위A 주사위B 2개로 나오는 경우의 수는 6 * 6으로 36개이다. 그렇지만 주사위 객체 1개도 경우의 수로 인정하게 되면 (7 x 7) - 1로 48개 이다. 여기서 -1은 주사위가 없는 경우라고 생각할 수 있다. 해당 문제도 같은 방식으로 이해하면 각 옷들은 주사위이고 옷의 개수는 주사위의 번호 개수이다. 예를 들어 옷의 종류가 3개이며, 각각 2벌씩이면 ((2 + 1) * (2 + 1) * (2 + 1)) - 1 = 26 이다. 해당 문제의 풀이 방법은 어느 정도 알았지만, hashMap의 확장함수로 getOrDefault가 있다는 것을 알게됐다. getOrDefault의 두 번째 매개변수인 defaultValue는 지정된 키로 매핑된 값이 없으면 반환되는 값이다. Source code Java (Source code) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public int solution(String[][] clothes) { int answer = 1; int clothCount = clothes.length; HashMap\u0026lt;String, Integer\u0026gt; hashMap = new HashMap\u0026lt;String, Integer\u0026gt;(); for (int i = 0; i \u0026lt; clothCount; i++) { int clothSum = hashMap.getOrDefault(clothes[i][1], 0) + 1; hashMap.put(clothes[i][1], clothSum); } for (int count : hashMap.values()) { answer = answer * (count + 1); } answer = answer - 1; return answer; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level2/01-camouflage/","summary":"위장 문제 설명 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.\n예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.\n종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.","title":"[프로그래머스]위장"},{"content":"하샤드 수 문제 설명 양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다.\n예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다.\n자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.\n제한 조건 x는 1 이상, 10000 이하인 정수입니다. 입출력 예 arr return 10 true 12 true 11 false 13 false 입출력 예 설명 입출력 예 #1\n10의 모든 자릿수의 합은 1입니다. 10은 1로 나누어 떨어지므로 10은 하샤드 수입니다.\n입출력 예 #2\n12의 모든 자릿수의 합은 3입니다. 12는 3으로 나누어 떨어지므로 12는 하샤드 수입니다.\n입출력 예 #3\n11의 모든 자릿수의 합은 2입니다. 11은 2로 나누어 떨어지지 않으므로 11는 하샤드 수가 아닙니다.\n입출력 예 #4\n13의 모든 자릿수의 합은 4입니다. 13은 4로 나누어 떨어지지 않으므로 13은 하샤드 수가 아닙니다.\n문제 풀이 리뷰 [Java](https://github.com/haservi/study-algorithm/blob/main/programmers/Level1/lv1_47_%ED%95%98%EC%83%A4%EB%93%9C_%EC%88%98/Solution.java 각 자리수의 합을 구한 뒤 나머지가 0인 경우 true를 반환한다. 나의 풀이(Source code) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public boolean solution(int x) { int sum = 0; int num = x; // 자릿수의 합 while (num != 0) { sum += num % 10; num /= 10; } // 나머지가 0이면 하샤드 수라고 판단 if (x % sum == 0) return true; else return false; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/04-algo-hasshadsu/","summary":"하샤드 수 문제 설명 양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다.\n예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다.\n자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.\n제한 조건 x는 1 이상, 10000 이하인 정수입니다. 입출력 예 arr return 10 true 12 true 11 false 13 false 입출력 예 설명 입출력 예 #1\n10의 모든 자릿수의 합은 1입니다. 10은 1로 나누어 떨어지므로 10은 하샤드 수입니다.","title":"[프로그래머스]하샤드 수"},{"content":"콜라츠 추측 문제 설명 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.\n1 2 3 1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다. 2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다.\n위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요.\n단, 작업을 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요.\n제한 사항 입력된 수, num은 1 이상 8000000 미만인 정수입니다. 입출력 예 n result 6 8 16 4 626331 -1 입출력 예 설명 입출력 예 #1\n문제의 설명과 같습니다.\n입출력 예 #2\n16 -\u0026gt; 8 -\u0026gt; 4 -\u0026gt; 2 -\u0026gt; 1 이되어 총 4번만에 1이 됩니다.\n입출력 예 #3\n626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야합니다.\n문제 풀이 문제 풀이 리뷰 반복적으로 돌면서 짝수이면 2로 나누고 홀수이면 해당값에 3을 곱한 후 1을 더해준다. 해당 반복이 500회가 되면 -1을 리턴한다. Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public int solution(long num) { int answer = 0; while (num != 1) { if (num % 2 == 0) { num = num / 2; } else { num = (num * 3) + 1; } answer++; if (answer == 500) { return -1; } } return answer; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/03-algo-colatz-guess/","summary":"콜라츠 추측 문제 설명 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.\n1 2 3 1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다. 2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다.\n위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요.","title":"[프로그래머스]콜라츠 추측"},{"content":"직업군 추천하기 문제 설명 개발자가 사용하는 언어와 언어 선호도를 입력하면 그에 맞는 직업군을 추천해주는 알고리즘을 개발하려고 합니다.\n아래 표는 5개 직업군 별로 많이 사용하는 5개 언어에 직업군 언어 점수를 부여한 표입니다.\n점수 SI CONTENTS HARDWARE PORTAL GAME 5 JAVA JAVASCRIPT C JAVA C++ 4 JAVASCRIPT JAVA C++ JAVASCRIPT C# 3 SQL PYTHON PYTHON PYTHON JAVASCRIPT 2 PYTHON SQL JAVA KOTLIN C 1 C# C++ JAVASCRIPT PHP JAVA 예를 들면, SQL의 SI 직업군 언어 점수는 3점이지만 CONTENTS 직업군 언어 점수는 2점입니다.\nSQL의 HARDWARE, PORTAL, GAME 직업군 언어 점수는 0점입니다.\n직업군 언어 점수를 정리한 문자열 배열 table, 개발자가 사용하는 언어를 담은 문자열 배열 languages, 언어 선호도를 담은 정수 배열 preference가 매개변수로 주어집니다.\n개발자가 사용하는 언어의 언어 선호도 x 직업군 언어 점수의 총합이 가장 높은 직업군을 return 하도록 solution 함수를 완성해주세요.\n총합이 같은 직업군이 여러 개일 경우, 이름이 사전 순으로 가장 빠른 직업군을 return 해주세요.\n제한사항 table의 길이 = 5 table의 원소는 \u0026ldquo;직업군 5점언어 4점언어 3점언어 2점언어 1점언어\u0026quot;형식의 문자열입니다. 직업군, 5점언어, 4언어, 3점언어, 2점언어, 1점언어는 하나의 공백으로 구분되어 있습니다. table은 모든 테스트케이스에서 동일합니다. 1 ≤ languages의 길이 ≤ 9 languages의 원소는 \u0026ldquo;JAVA\u0026rdquo;, \u0026ldquo;JAVASCRIPT\u0026rdquo;, \u0026ldquo;C\u0026rdquo;, \u0026ldquo;C++\u0026rdquo; ,\u0026ldquo;C#\u0026rdquo; , \u0026ldquo;SQL\u0026rdquo;, \u0026ldquo;PYTHON\u0026rdquo;, \u0026ldquo;KOTLIN\u0026rdquo;, \u0026ldquo;PHP\u0026rdquo; 중 한 개 이상으로 이루어져 있습니다. languages의 원소는 중복되지 않습니다. preference의 길이 = languages의 길이 1 ≤ preference의 원소 ≤ 10 preference의 i번째 원소는 languages의 i번째 원소의 언어 선호도입니다. return 할 문자열은 \u0026ldquo;SI\u0026rdquo;, \u0026ldquo;CONTENTS\u0026rdquo;, \u0026ldquo;HARDWARE\u0026rdquo;, \u0026ldquo;PORTAL\u0026rdquo;, \u0026ldquo;GAME\u0026rdquo; 중 하나입니다. 입출력 예 table languages preference result [\u0026ldquo;SI JAVA JAVASCRIPT SQL PYTHON C#\u0026rdquo;, \u0026ldquo;CONTENTS JAVASCRIPT JAVA PYTHON SQL C++\u0026rdquo;, \u0026ldquo;HARDWARE C C++ PYTHON JAVA JAVASCRIPT\u0026rdquo;, \u0026ldquo;PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP\u0026rdquo;, \u0026ldquo;GAME C++ C# JAVASCRIPT C JAVA\u0026rdquo;] [\u0026ldquo;PYTHON\u0026rdquo;, \u0026ldquo;C++\u0026rdquo;, \u0026ldquo;SQL\u0026rdquo;] [7, 5, 5] \u0026ldquo;HARDWARE\u0026rdquo; [\u0026ldquo;SI JAVA JAVASCRIPT SQL PYTHON C#\u0026rdquo;, \u0026ldquo;CONTENTS JAVASCRIPT JAVA PYTHON SQL C++\u0026rdquo;, \u0026ldquo;HARDWARE C C++ PYTHON JAVA JAVASCRIPT\u0026rdquo;, \u0026ldquo;PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP\u0026rdquo;, \u0026ldquo;GAME C++ C# JAVASCRIPT C JAVA\u0026rdquo;] [\u0026ldquo;JAVA\u0026rdquo;, \u0026ldquo;JAVASCRIPT\u0026rdquo;] [7, 5] \u0026ldquo;PORTAL\u0026rdquo; 입출력 예 설명 입출력 예 #1\n각 직업군 별로 점수를 계산해보면 아래와 같습니다.\n아래 사진은 개발자 언어 선호도 나타낸 표입니다.\nPython C++ SQL 선호도 7 5 5 아래 사진은 개발자가 선호하는 언어의 직업군 언어 점수를 나타낸 표입니다.\nSI CONTENTS HARDWARE PORTAL GAME PYTHON 2 3 3 3 0 c++ 0 1 4 0 5 SQL 3 2 0 0 0 직업군별 점수 식 $72 + 50 + 5*3$ $73 + 51 + 5*2$ $73 + 54 + 5*0$ $73 + 50 + 5*0$ $70 + 55 + 5*0$ 점수 총합 29 36 41 21 25 따라서 점수 총합이 41로 가장 높은 \u0026quot;HARDWARE\u0026quot;를 return 해야 합니다.\n입출력 예 #2 각 직업군 별로 점수를 계산해보면 아래와 같습니다.\n아래 사진은 개발자 언어 선호도 나타낸 표입니다.\nJAVA JAVASCRIPT 선호도 7 5 아래 사진은 개발자가 선호하는 언어의 직업군 언어 점수를 나타낸 표입니다.\nSI CONTENTS HARDWARE PORTAL GAME JAVA 5 4 2 5 1 JAVASCRIPT 4 5 1 4 3 직업군별 점수 식 $75 + 54$ $74 + 55$ $72 + 51$ $75 + 54$ $71 + 53$ 점수 총합 55 53 19 55 22 점수 총합이 55로 가장 높은 직업군은 \u0026ldquo;SI\u0026rdquo; 와 \u0026ldquo;PORTAL\u0026quot;입니다. 따라서 사전 순으로 먼저 오는 \u0026quot;PORTAL\u0026quot;을 return 해야 합니다.\n문제 풀이 리뷰 Java TreeMap에 language 값에 맞는 table의 배열을 맞춘 후 preference 값을 더하였다. 이렇게 하면 자동적으로 언어 별 점수의 합이 정렬된다. 이 후 점수 가 큰 순서로 내림차순 한 뒤 첫번째 값을 리턴하였다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import java.util.*; class Solution { public static void main(String[] args) { Solution solution = new Solution(); String[] table = { \u0026#34;BI JAVA JAVASCRIPT SQL PYTHON C#\u0026#34;, \u0026#34;AONTENTS JAVASCRIPT JAVA PYTHON SQL C++\u0026#34;, \u0026#34;HARDWARE C C++ PYTHON JAVA JAVASCRIPT\u0026#34;, \u0026#34;AORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP\u0026#34;, \u0026#34;GAME C++ C# JAVASCRIPT C JAVA\u0026#34; }; String[] languages = { \u0026#34;JAVA\u0026#34;, \u0026#34;JAVASCRIPT\u0026#34; }; int[] preference = { 7, 5 }; String result = solution.solution(table, languages, preference); System.out.println(\u0026#34;결과 : \u0026#34; + result); } public String solution(String[] table, String[] languages, int[] preference) { Map\u0026lt;String, Integer\u0026gt; jobResultMap = new TreeMap\u0026lt;String, Integer\u0026gt;(); // ValueComparator bvc = new ValueComparator(jobResultMap); // TreeMap\u0026lt;String, Integer\u0026gt; sortedMap = new TreeMap\u0026lt;String, Integer\u0026gt;(bvc); int tableCount = table.length; for (int i = 0; i \u0026lt; tableCount; i++) { String[] splitTable = table[i].split(\u0026#34; \u0026#34;); // 해당 점수별로 값 넣기 jobResultMap.put(splitTable[0], 0); for (int j = 1; j \u0026lt; splitTable.length; j++) { for (int k = 0; k \u0026lt; languages.length; k++) { if (splitTable[j].equals(languages[k])) { jobResultMap.put(splitTable[0], jobResultMap.get(splitTable[0]) + (splitTable.length - j) * preference[k]); } } } } List\u0026lt;String\u0026gt; listKeySet = new ArrayList\u0026lt;\u0026gt;(jobResultMap.keySet()); Collections.sort(listKeySet, (value1, value2) -\u0026gt; (jobResultMap.get(value2).compareTo(jobResultMap.get(value1)))); String answer = listKeySet.get(0); System.out.println(jobResultMap.toString()); System.out.println(listKeySet.toString()); return answer; } } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/02-algo-recommend-job/","summary":"직업군 추천하기 문제 설명 개발자가 사용하는 언어와 언어 선호도를 입력하면 그에 맞는 직업군을 추천해주는 알고리즘을 개발하려고 합니다.\n아래 표는 5개 직업군 별로 많이 사용하는 5개 언어에 직업군 언어 점수를 부여한 표입니다.\n점수 SI CONTENTS HARDWARE PORTAL GAME 5 JAVA JAVASCRIPT C JAVA C++ 4 JAVASCRIPT JAVA C++ JAVASCRIPT C# 3 SQL PYTHON PYTHON PYTHON JAVASCRIPT 2 PYTHON SQL JAVA KOTLIN C 1 C# C++ JAVASCRIPT PHP JAVA 예를 들면, SQL의 SI 직업군 언어 점수는 3점이지만 CONTENTS 직업군 언어 점수는 2점입니다.","title":"[프로그래머스]직업군 추천하기"},{"content":"비밀지도 문제 설명 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다.\n그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다.\n다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.\n지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 \u0026ldquo;공백\u0026rdquo;(\u0026quot; \u0026ldquo;) 또는 \u0026ldquo;벽\u0026rdquo;(\u0026rdquo;#\u0026quot;) 두 종류로 이루어져 있다. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;라고 하자.\n지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다.\n지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다. \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;는 각각 정수 배열로 암호화되어 있다. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다. 네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.\n입력 형식 입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.\n1 ≦ n ≦ 16 arr1, arr2는 길이 n인 정수 배열로 주어진다. 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다. 출력 형식 원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라.\n입출력 예제 매개변수 값 n 5 arr1 [9, 20, 28, 18, 11] arr2 [30, 1, 21, 17, 28] 출력 [\u0026rdquo;#####\u0026rdquo;,\u0026rdquo;# # #\u0026rdquo;, \u0026ldquo;### #\u0026rdquo;, \u0026ldquo;# ##\u0026rdquo;, \u0026ldquo;#####\u0026rdquo;] 매개변수 값 n 6 arr1 [46, 33, 33 ,22, 31, 50] arr2 [27 ,56, 19, 14, 14, 10] 출력 [\u0026quot;######\u0026quot;, \u0026ldquo;### #\u0026rdquo;, \u0026ldquo;## ##\u0026rdquo;, \u0026quot; #### \u0026ldquo;, \u0026quot; #####\u0026rdquo;, \u0026ldquo;### # \u0026ldquo;] 문제 풀이 리뷰 각각의 미로의 길을 이진화 한다. 만약 이진수의 값의 앞 공백이 있는 경우 \u0026ldquo;0\u0026quot;을 추가해준다. 서로 비교하여 0인 경우는 \u0026quot; \u0026ldquo;, 그렇지 않은 경우 \u0026ldquo;#\u0026ldquo;을 추가해준다. 해결 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import java.util.*; class Solution { public static void main(String[] args) { Solution solution = new Solution(); int n = 5; int[] arr1 = { 9, 20, 28, 18, 11 }; int[] arr2 = { 30, 1, 21, 17, 28 }; String[] result = solution.solution(n, arr1, arr2); System.out.println(\u0026#34;결과 : \u0026#34; + Arrays.toString(result)); } public String[] solution(int n, int[] arr1, int[] arr2) { String[] answer = new String[n]; // 경로를 십진수를 이진수로 변경 및 이진수 앞 공백 추가 int count = n; for (int i = 0; i \u0026lt; count; i++) { String firstKeyMap = makeZero(Integer.toBinaryString(arr1[i]), count); String secondKeyMap = makeZero(Integer.toBinaryString(arr2[i]), count); String rowKey = \u0026#34;\u0026#34;; // System.out.println(firstKeyMap); for (int j = 0; j \u0026lt; count; j++) { if ((firstKeyMap.charAt(j) == \u0026#39;0\u0026#39;) \u0026amp;\u0026amp; (secondKeyMap.charAt(j) == \u0026#39;0\u0026#39;)) { rowKey += \u0026#34; \u0026#34;; } else { rowKey += \u0026#34;#\u0026#34;; } } // System.out.println(rowKey); answer[i] = rowKey; } return answer; } private String makeZero(String binaryString, int length) { int binaryLength = binaryString.length(); while (binaryLength != length) { binaryString = \u0026#34;0\u0026#34; + binaryString; binaryLength++; } return binaryString; } } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/01-algo-secret-map/","summary":"비밀지도 문제 설명 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다.\n그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다.\n다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.\n지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 \u0026ldquo;공백\u0026rdquo;(\u0026quot; \u0026ldquo;) 또는 \u0026ldquo;벽\u0026rdquo;(\u0026rdquo;#\u0026quot;) 두 종류로 이루어져 있다. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;라고 하자.\n지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다.","title":"[프로그래머스]비밀지도"},{"content":"대규모 시스템 설계를 해본적이 없으니.. 궁금해서 해당 책을 읽어봤습니다.\n책의 전반적인 내용은 어렵지 않습니다. 왜냐하면 내용이 깊게 들어가지 않고 말그대로 설계를 하기 때문에 생각보다 읽는데는 쉽다고 느껴졌습니다.\n깊게 들어가면 어렵겠지만 책에서는 아주 깊게 들어가지는 않은 것 같아요.\n책의 챕터는 12장 정도로 돼어 있으며, 챕터마다 설계해야 하는 서비스가 다릅니다.\n책의 내용은 가상 면접을 하는 것처럼 면접관이 프로젝트에 대해 설계를 요청하면, 면접자는 해당 프로젝트의 서비스의 목적과 규모 등에 맞게 질문과 답변을 하는 방식입니다.\n책을 읽으면서 인상적인 몇몇 키워드 및 조금 더 알아봐야 겠다고 정리한 것은 아래의 항목입니다.\nDB 데이터 다중화와 샤딩(안정 해시를 통한 키 재배치 방법) API 처리율 제한(Dos 공격 및 자원 방지, 비용 절감, 서버 과부하 방지) Redis 효율적으로 사용하기(선착순 이벤트, SNS 좋아요, 방문자 수 count 등) AWS S3 업로드 시 이어올리기 및 데이터 압축 등으로 비용 감소 메시지 큐를 이용하여 컴포넌트 사이의 결합도 낮추기 검색어 자동완성 구조 및 원리 트라이 자료구조에 대해서 서비스될 프로젝트의 사용자 유입량 계산 서비스될 프로젝트의 하드웨어 스팩 계산 이중 몇가지는 실제로 구현(API 처리율 제한, AWS S3, 메시지 큐 등) 해봤지만.. 어디선가 한번쯤 들어봤는데 제대로 모르는 샤딩에 대해 정리했습니다.\n실제로 써보진 않았지만 써야할 때가 되면 그래도 도움이 되지 않을까라는 생각으로 찾아보다보니 쓸 일이 있을까라는 생각도 드네요.. 그래도 알아두면 좋을 것 같아 정리했습니다.\n데이터 다중화와 샤딩 서비스가 점점 커지면 데이터베이스를 증설이 필요할 때가 있습니다. 이럴 때 데이터 다중화와 샤딩은 대규모 데이터베이스 시스템에서 성능 및 확장성을 향상시킬 수 있습니다.\n데이터 다중화는 동일한 데이터를 여러 위치에 중복 저장하는 것을 의미합니다. 이는 데이터의 가용성을 향상시키고 장애 시 복구를 용이하게 합니다.\n데이터 다중화(Data Replication)\n장점\n고가용성(High Availability): 복제된 데이터는 여러 노드에 분산되어 있기 때문에 하나의 노드가 다운되더라도 다른 노드에서 데이터를 제공할 수 있습니다. 읽기 성능 향상: 복제된 노드 중 하나를 읽기 전용으로 사용하여 읽기 성능을 향상시킬 수 있습니다. 단점\n쓰기 지연성(Write Latency): 모든 복제본을 일관되게 유지하려면 쓰기 작업이 모든 복제본에 반영되어야 하므로 쓰기 지연이 발생할 수 있습니다. 일관성 유지 어려움: 여러 복제본 간의 일관성을 유지하기 위해 복잡한 동기화 및 복제 알고리즘이 필요합니다. 샤딩(Sharding)\n샤딩은 대량의 데이터를 분할하여 샤드(shard)라고 불리는 작은 단위로 분할하는 기술을 의미합니다. 각 샤드는 고유한 데이터 서브셋을 관리하며, 모든 샤드의 조합이 전체 데이터 세트를 형성합니다. 샤딩 전략을 쓸 때는 샤딩 키를 어떻게 분산할지가 중요하다고 합니다.\n여러 데이터베이스에 골고루 데이터를 분산하기 위해 안정 해시 기법을 이용하여 해당 문제를 해결할 수 있습니다.\n이외에도 유명인사(celebrity) 문제로 여러 유명인사가 특정 샤드에 집중되어 있으면 해당 샤드에서만 데이터의 과부하가 걸릴 수 있습니다.\n장점\n수평 확장성(Horizontal Scalability): 데이터베이스의 용량을 늘리려면 단순히 더 많은 샤드를 추가하면 됩니다. 높은 읽기 및 쓰기 처리량: 각 샤드는 독립적으로 작동하므로 동시에 여러 샤드에서 읽기 및 쓰기 작업이 가능합니다. 단점\n쿼리 복잡성: 데이터가 여러 샤드에 분산되어 있기 때문에 쿼리가 여러 샤드에서 실행되어야 하는 경우 데이터를 조합하는 추가적인 작업이 필요할 수 있습니다. 일부 샤드 다운 영향: 특정 샤드에 장애가 발생하면 해당 샤드에 속한 데이터에 액세스하는 부분에서 문제가 발생할 수 있습니다. 참조\n내가 만든 서비스는 얼마나 많은 사용자가 이용할 수 있을까?(시리즈) 샤딩(Sharding) / 샤드(Shard) - DB의 수평적 규모 확장 DB 분산 저장 기법(파티셔닝,샤딩,레플리케이션)의 개념 ","permalink":"https://haservi.github.io/posts/books/large-scale-system-design-learned-from-virtual-interviews/","summary":"대규모 시스템 설계를 해본적이 없으니.. 궁금해서 해당 책을 읽어봤습니다.\n책의 전반적인 내용은 어렵지 않습니다. 왜냐하면 내용이 깊게 들어가지 않고 말그대로 설계를 하기 때문에 생각보다 읽는데는 쉽다고 느껴졌습니다.\n깊게 들어가면 어렵겠지만 책에서는 아주 깊게 들어가지는 않은 것 같아요.\n책의 챕터는 12장 정도로 돼어 있으며, 챕터마다 설계해야 하는 서비스가 다릅니다.\n책의 내용은 가상 면접을 하는 것처럼 면접관이 프로젝트에 대해 설계를 요청하면, 면접자는 해당 프로젝트의 서비스의 목적과 규모 등에 맞게 질문과 답변을 하는 방식입니다.","title":"[도서] 가상 면접 사례로 배우는 대규모 시스템 설계 기초를 읽고"},{"content":"","permalink":"https://haservi.github.io/projects/","summary":"projects","title":"Projects"}]