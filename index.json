[{"content":"Window에서 JDK 버전 간편하게 변경하기 Java를 사용하여 프로젝트를 진행하다 보면 우선적으로 OS 명령을 내리기 위한 JDK(Java Develop Kit) 설치가 필요합니다.\n그렇지만 특정 Java 버전을 필요로 하는 프로젝트도 있습니다.\n이를 해결하기 위해 도커로 환경을 구성하거나 해당 로컬 컴퓨터의 환경변수를 설정하여 변경하는 것도 가능합니다.\n해당 글은 스크립트를 생성하여 터미널 명령어로 간단하게 자바 버전을 변경하는 방법입니다.\n모든 설정이 끝나면 아래처럼 터미널에서 명령어만 입력하면 스크립트를 변경 할 수 있습니다.\nJDK 설치 및 폴더명 변경 우선 JDK를 다운로드 아무래도 라이선스의 문제가 있을 수 있으니 OpenJDK를 다운받는 것을 추천드립니다.\n우선 해당 링크에서 다운 받을 수 있습니다.\n마이크로소프트에서도 openjdk를 다운로드 받을 수 있는 링크를 제공하고 있습니다. 다운로드 받은 폴더명은 아래와 같은 파일명으로 변경해줍니다.\n스크립트에 해당 폴더이름과 동일하게 맞췄기 때문에 변경을 원하시면 스크립트도 함께 변경해줘야 합니다.\n또한, 해당 스크립트 압축파일도 scripts 폴더에 풀어서 넣어줍니다. 해당 스크립트 명령어를 이용하여 터미널에서 자바 버전을 변경하도록 설정할 예정입니다.\n환경 변수 설정 일반적으로 윈도우에서 설정하는 환경변수 설정과 거의 동일합니다.\n약간의 차이점은 터미널에 스크립트 변수를 실행할 수 있는 변수를 지정 하는 정도에요.\n  시스템 환경 변수 편집 화면에서 환경변수 를 선택합니다. 윈도우 버튼을 누르고 검색에 환경 변수만 치면 시스템 환경 변수 편집이 나타납니다. 다른 방법으로는 탐색기에서 내 PC 우 클릭 후 속성 -\u0026gt; 오른쪽에 고급 시스템 설정을 선택해주면 됩니다.   환경변수 선택 후 아래쪽의 새로 만들기를 눌러 줍니다.\n  두개 시스템 이름은 JAVA_HOME 경로는 자주 사용하는 JDK 버전의 폴더 경로까지면 설정해줍니다. 제 경우는 OpenJDK11 버전을 주로 이용하기 때문에 C:\\Program Files\\Java\\openjdk11로 경로 설정을 했습니다.\n  이제 Path에 위의 경로에 /bin를 추가하는 경로와 스크립트 경로를 지정합니다. 시스템 이름에서 Path를 선택 한 후 편집을 선택합니다.   그 후 아래와 같이 경로를 설정합니다.   %JAVA_HOME%\\bin의 경우 3번에서 진행한 jdk 경로에 bin폴더 위치를 추가한 것이며, C:\\Program Files\\Java\\scripts는 기존에 추가한 스크립트 변수를 터미널에서 사용하기 위한 경로입니다.\n이렇게 설정해 주신 뒤 터미널을 실행하여 openjdk8, openjdk11, openjdk17을 명령어로 입력하면 자바 버전을 변경할 수 있습니다.\n추가사항 .notice{--root-color: #000; --root-background: #e7f2fa; --title-color: #fff; --title-background: #6ab0de; --warning-title: rgba(217, 83, 79, 0.9); --warning-content: #fae2e2; --info-title: #f0b37e; --info-content: #fff2db; --note-title: #6ab0de; --note-content: #e7f2fa; --tip-title: rgba(92, 184, 92, 0.8); --tip-content: #e6f9e6;}body.dark .notice{--root-color: #fff; --root-background: #e7f2fa; --title-color: #fff; --title-background: #6ab0de; --warning-title: rgba(130, 49, 47, 0.9); --warning-content: #341312; --info-title: #906B4B; --info-content: #392A1E; --note-title: #3f6985; --note-content: #192A35; --tip-title: rgba(46, 92, 46, 0.8); --tip-content: #122412;}.notice{padding: 18px; line-height: 24px; margin-bottom: 24px; border-radius: 4px; color: var(--root-color); background: var(--root-background);}.notice p:last-child{margin-bottom: 0;}.notice-title{margin: -18px -18px 12px; padding: 4px 18px; border-radius: 4px 4px 0 0; font-weight: 700; color: var(--title-color); background: var(--title-background);}.notice.warning .notice-title{background: var(--warning-title);}.notice.warning{background: var(--warning-content);}.notice.info .notice-title{background: var(--info-title);}.notice.info{background: var(--info-content);}.notice.note .notice-title{background: var(--note-title);}.notice.note{background: var(--note-content);}.notice.tip .notice-title{background: var(--tip-title);}.notice.tip{background: var(--tip-content);}.icon-notice{display: inline-flex; align-self: center; margin-right: 8px;}.icon-notice img, .icon-notice svg{height: 1em; width: 1em; fill: currentColor;}.icon-notice img, .icon-notice.baseline svg{top: 0.125em; position: relative;} 알림\n위의 방법은 현재의 터미널에서 변경되는 방법입니다.\n한번 설정으로 모든 환경에 영향을 받기위해서는 아래와 같이 설정합니다.\n 위의 스크립트를 열어보면 아래와 같습니다.\n@echo off set JAVA_HOME=C:\\Program Files\\Java\\openjdk17 set Path=%JAVA_HOME%\\bin;%Path% echo Java 17 activated. 해당 스크립트를 전역으로 사용하고 싶다면 아래와 같이 변경하면 됩니다. 명령어는 관리자 모드의 터미널에서 가능합니다.\n@echo off setx JAVA_HOME \u0026#34;C:\\Program Files\\Java\\openjdk17\u0026#34; /m echo Java 17 activated. Path는 제거해주셔야합니다. 함께 사용하는 경우 환경변수에 강제로 추가됩니다.\n참조 링크  Java Custom Setting OpenJDK vs OracleJDK JDK 전역 변수로 설정 관련  ","permalink":"https://haservi.github.io/posts/tips/window-java-version-change/","summary":"Window에서 JDK 버전 간편하게 변경하기 Java를 사용하여 프로젝트를 진행하다 보면 우선적으로 OS 명령을 내리기 위한 JDK(Java Develop Kit) 설치가 필요합니다.\n그렇지만 특정 Java 버전을 필요로 하는 프로젝트도 있습니다.\n이를 해결하기 위해 도커로 환경을 구성하거나 해당 로컬 컴퓨터의 환경변수를 설정하여 변경하는 것도 가능합니다.\n해당 글은 스크립트를 생성하여 터미널 명령어로 간단하게 자바 버전을 변경하는 방법입니다.\n모든 설정이 끝나면 아래처럼 터미널에서 명령어만 입력하면 스크립트를 변경 할 수 있습니다.\nJDK 설치 및 폴더명 변경 우선 JDK를 다운로드 아무래도 라이선스의 문제가 있을 수 있으니 OpenJDK를 다운받는 것을 추천드립니다.","title":"OpenJDK 버전 간편하게 변경하기"},{"content":"시작하며 DSM 7버전에서는 SVN과 GitLab을 패키지로 지원하지 않습니다.\n그렇기 때문에 Docker를 이용하여 설치해야 합니다.\n제 경우는 KT 공유기와 Synology NAS(220+)에 램 8기가를 추가한 상태입니다.\n공유기 포트포워딩만 조금 다를 뿐 전체적인 방법은 동일할 것이라 생각됩니다.\nGitLab을 쾌적하게 쓰시려면 최소 램 4기가 이상으로 설정하시는게 좋습니다. 해당 설정은 컨테이너 생성 후에도 편집이 가능하니 필요에 따라 조정하시면 됩니다.\n.notice{--root-color: #000; --root-background: #e7f2fa; --title-color: #fff; --title-background: #6ab0de; --warning-title: rgba(217, 83, 79, 0.9); --warning-content: #fae2e2; --info-title: #f0b37e; --info-content: #fff2db; --note-title: #6ab0de; --note-content: #e7f2fa; --tip-title: rgba(92, 184, 92, 0.8); --tip-content: #e6f9e6;}body.dark .notice{--root-color: #fff; --root-background: #e7f2fa; --title-color: #fff; --title-background: #6ab0de; --warning-title: rgba(130, 49, 47, 0.9); --warning-content: #341312; --info-title: #906B4B; --info-content: #392A1E; --note-title: #3f6985; --note-content: #192A35; --tip-title: rgba(46, 92, 46, 0.8); --tip-content: #122412;}.notice{padding: 18px; line-height: 24px; margin-bottom: 24px; border-radius: 4px; color: var(--root-color); background: var(--root-background);}.notice p:last-child{margin-bottom: 0;}.notice-title{margin: -18px -18px 12px; padding: 4px 18px; border-radius: 4px 4px 0 0; font-weight: 700; color: var(--title-color); background: var(--title-background);}.notice.warning .notice-title{background: var(--warning-title);}.notice.warning{background: var(--warning-content);}.notice.info .notice-title{background: var(--info-title);}.notice.info{background: var(--info-content);}.notice.note .notice-title{background: var(--note-title);}.notice.note{background: var(--note-content);}.notice.tip .notice-title{background: var(--tip-title);}.notice.tip{background: var(--tip-content);}.icon-notice{display: inline-flex; align-self: center; margin-right: 8px;}.icon-notice img, .icon-notice svg{height: 1em; width: 1em; fill: currentColor;}.icon-notice img, .icon-notice.baseline svg{top: 0.125em; position: relative;} 알림\n완성 후 GitLab Repository 주소 경로가 올바르지 않은 이슈가 있지만 아래와 같이 설정하면 사용하는데 이상은 없을 것이라 생각됩니다.\n Docker에 GitLab 설치 패키지 센터에서 도커 설치  먼저 패키지 센터에서 Docker를 설치합니다. 도커를 실행 후 레지스트리에서 gitlab 검색 후 gitlab/gitlab-ce를 설치합니다.  조금 시간이 지난 후 설치가 완료되면 해당 이미지를 실행합니다.   도커 이미지 실행 및 설정하기 도커를 이미지를 실행 하면 다음과 같이 설정을 진행해야 합니다.\n 먼저 고급 설정에서 자동 재시작 활성화를 합니다. 이렇게 되면 NAS가 죽었다 살아나도 알아서 실행됩니다.  포트 설정을 해줍니다. 로컬 포트는 임의로 해도 되지만 컨테이너 포트는 꼭 맞춰주셔야 합니다.  그리고 도커의 볼륨을 추가합니다. 공식홈페이지처럼 컨테이너 볼륨에 저장되는 정보를 NAS 로컬 위치로 매핑 시켜줍니다.  이렇게 설정 후 적용을 하면 컨테이너가 만들어 졌습니다. 해당 컨테이너가 결국은 하나의 GitLab을 구동하기 위한 서버라고 보시면 됩니다.   기본적으로 GitLab의 슈퍼관리자 아이디는 root이며, 패스워드는 방금 설정한 config 폴더의 initial_root_paasword파일에 암호가 있습니다.\n해당 암호를 보기 위해선 패키지 센터에서 텍스트 편집기를 설치하신 후 열어주시면 됩니다.\n패스워드를 확인 후 아래와 같이 컨테이너를 실행해주고 GitLab이 빌드(3~5분 정도)가 되면 접속이 가능합니다. 일단 이렇게 설정하시면 도커를 이용한 GitLab 설치는 정상적으로 끝났습니다.\n만약 해당 컴퓨터에서만 쓰실 경우는 NAS가 연결된 상태에서 해당 LAN IP로 접속해도 이용은 가능합니다.\n그렇지만 NAS를 쓰는 목적이 어디에서든 접속 가능하기 위함이니.. 조금 더 진행해주셔야 합니다.\nHTTP 설정을 하지 않고 바로 HTTPS로 넘어가셔도 무방합니다.\nHTTP 설정 및 공유기 포트포워딩 일단 NAS를 쓰시는 분들은 기본적으로 할당받을 수 있는 QuickConnectId가 있습니다. 해당 도메인 주소를 통해 우리는 외부에서 나의 NAS에 접속할 수 있습니다.\n하지만 보안상 아무나 이러한 접근을 허용하면 안되죠. 그렇기에 NAS의 설정에서 방화벽 규칙을 허용해줘야 하며, 공유기에서도 해당 포트로 접근 시 NAS에서 허용한 포트로 포트포워딩을 해줘야 합니다.\nNAS 방화벽 허용하기  제어판에서 방화벽에 들어간 후 규칙편집을 선택합니다.  방화벽 규칙을 생성합니다.  내장된 응용 프로그램 목록에서 선택에서 선택을 눌러주세요.  방금 전 만든 GitLab 컨테이너 포트를 선택합니다.  활성화 여부를 체크하고 확인을 눌러주세요.   여기까지 진행됐다면 NAS에 공유기를 물려서 사용하시는 분은 해당 공유기에서 NAS DNS로 접속하시면 접속이 되는 것을 확인 할 수 있습니다.\n공유기 포트포워딩 적용 제 경우는 KT 홈 허브 공유기가 있기에 해당 설정에 맞춰서 정리 하겠습니다.\n일단 IpTime과 달리 허브 기기의 관리자 페이지에 접속하기 위해선 공유기 와이파이 망 내 또는 랜선을 통해 웹페이지에서 172.30.1.254 로 접속해야 합니다.\n해당 화면에 처음 접속한 경우 기본 아이디와 패스워드는 아래와 같습니다.\n구형 ID: ktuser PW: megaap 신형 ID: ktuser PW: homehub 로그인 후 패스워드는 변경해주시는게 좋습니다. 추후 비밀번호를 잊어버리면 초기화하면 됩니다.\n먼저 UPnP(Universal Plug and Play) 설정을 해제하겠습니다. UPnP가 있으면 한번 포트 연결이 되면 이후에 포트포워딩을 지워도 적용됩니다. 편리한 기술이지만 보안에 취약한 문제가 있습니다.\n포트 포워딩 설정은 장치설정 -\u0026gt; 트래픽 관리 -\u0026gt; 포트 포워딩 설정으로 접근하면 됩니다.\n여기서 중요한 값은 외부포트, 내부 IP 주소, 내부 포트 입니다. 외부에서 들어오는 포트 주소입니다. 해당 포트로 들어오면 허브가 내부 포트로 포트를 변경해줍니다.\n외부포트는 임의로 정해도 되며, 내부 포트는 처음 Docker 컨테이너 포트에서 선택했던 포트 값을 지정해주면 됩니다.\n내부 IP 주소는 NAS에 연결된 내부 IP 주소를 입력해주면 됩니다.\n이렇게 설정하시면 이제 http는 어디서든 접속이 가능합니다.\nHTTPS 적용 및 역방향 프록시 설정 HTTPS를 적용할 예정이면 위으 포트포워딩에 443 포트만 적용하면 됩니다. NAS에서는 역방향 프록시 설정을 할 수 있습니다.\n그렇기 때문에 기존에 할당 받은 도메인에 여러 서브도메인을 설정할 수 있습니다.\n티스토리로 예를 들면 tistory.com은 하나의 도메인이지만 각각의 사용자는 앞에 user.tistory.com 식으로 자신의 도메인을 할당 받을 수 있는 원리와 비슷하다고 보면 됩니다.\n역방향 프록시 설정  역방향 프록시 설정 화면으로 이동합니다.  역방향 프록시 규칙을 설정합니다. 소스는 외부에서 접근하는 도메인 주소로 보시면 됩니다. 호스트이름 앞에 원하는 서브도메인을 입력하고 해당 도메인주소를 연결합니다. 대상은 기존 도메인주소와 도커 HTTP 컨테이너 포트를 입력합니다.  공유기 포트포워딩을 통해 HTTPS 포트인 443 포트를 허용해줍니다.   NAS 인증서 발급 이제 외부에서 접속은 가능합니다. 하지만 HTTPS에서는 해당 도메인주소가 인증된 주소인지 확인하기 위해 인증서 발급이 필요합니다.\n일반적으로는 openssl 또는 사설 인증서를 이용하여 인증서를 발급받아야 하지만 NAS에서는 해당 과정 없이 간편하게 인증서를 발급받을 수 있습니다.\n 제어판 -\u0026gt; 보안 -\u0026gt; 인증서로 이동후 추가를 눌러줍니다.  새인증서를 추가합니다.  인증서 이름과 Let\u0026rsquo;s Encrypt에서 인증서 얻기를 선택합니다.  역방향 프록시로 지정한 도메인 주소를 적습니다. 이메일은 본인의 이메일을 선택하시면 됩니다.  인증서 화면에서 설정에 들어가서 해당 인증서를 역방향 프록시에서 지정한 도메인과 매칭시킵니다.   모든 설정이 끝났습니다. 이렇게 하면 외부에서도 HTTPS로 접속이 가능합니다.\n기타 GitLab 프로젝트 생성 시 Clone with SSH와 Clone with HTTP의 주소가 프로젝트 레포지토리 주소와 매칭되지 않은 현상이 있습니다.\nGITLAB_HOST설정도 해보고, external_url도 지정해봤는데 제대로 되지 않아서 임시적으로 Clone with HTTP를 커스텀하는 방법(링크)이 있습니다.\n 관리자로 로그인 후 좌측 메뉴에서 Admin을 선택합니다. Setting -\u0026gt; General -\u0026gt; Visibility and access controls 로 이동합니다. 해당 항목 중 Custom Git clone URL for HTTP(S) 의 값을 HTTPS로 인증한 도메인 주소로 추가합니다.   ","permalink":"https://haservi.github.io/posts/devops/docker/nas-docker-gitlab-setting/","summary":"시작하며 DSM 7버전에서는 SVN과 GitLab을 패키지로 지원하지 않습니다.\n그렇기 때문에 Docker를 이용하여 설치해야 합니다.\n제 경우는 KT 공유기와 Synology NAS(220+)에 램 8기가를 추가한 상태입니다.\n공유기 포트포워딩만 조금 다를 뿐 전체적인 방법은 동일할 것이라 생각됩니다.\nGitLab을 쾌적하게 쓰시려면 최소 램 4기가 이상으로 설정하시는게 좋습니다. 해당 설정은 컨테이너 생성 후에도 편집이 가능하니 필요에 따라 조정하시면 됩니다.\n.notice{--root-color: #000; --root-background: #e7f2fa; --title-color: #fff; --title-background: #6ab0de; --warning-title: rgba(217, 83, 79, 0.9); --warning-content: #fae2e2; --info-title: #f0b37e; --info-content: #fff2db; --note-title: #6ab0de; --note-content: #e7f2fa; --tip-title: rgba(92, 184, 92, 0.","title":"Synology NAS로 Docker GitLab 설치하기"},{"content":"인텔리J에서 스프링 프로젝트를 생성하면 아래 셋팅은 미리 설정하면 좋습니다.\n1. 어노테이션 프로세싱 활성화 롬복과 같은 외부 라이브러리를 의존성 주입하게 될 경우 해당 사항을 체크해줘야 컴파일 시 문제 없이 동작합니다.\n설정에서 검색창에 annotation을 입력하면 아래와 같은 화면이 나옵니다.\n2. Build and run IntelliJ IDEA로 변경 IntelliJ IDEA 인텔리제이 자체에서 제공하는 빌드 자동화 도구입니다.\n기본은 Gradle로 설정 돼 있습니다. 이걸 IntelliJ IDEA로 변경하면 더 빠른 테스트를 할 수 있습니다.\nGradle빌드와 IntelliJ IDEA 빌드의 차이는 증분 빌드 여부입니다.\nIntelliJ IDEA는 변경된 부분만 빌드를 하는 방식으로 기존에 빌드가 돼 있는 부분은 건너뛰고 새로 변경된 부분만 빌드하는 방식입니다.\n그렇기 때문에 Gradle빌드 보다 더 빠르게 빌드할 수 있습니다. 하지만, IntelliJ IDEA는 기존에 빌드한 파일이 삭제된 경우도 같이 빌드가 될 수 있습니다. 그래서 종종 queryDSL과 mapStruct와 같이 컴파일 후 사용하는 코드가 빌드가 잘 안될 경우가 있을 수 있습니다.(반복적인 클린 -\u0026gt; 빌드 -\u0026gt; 리빌드 재귀..)\n올바르게 빌드를 하고 싶다면 Gradle로 하는 것도 좋은 전략이라 생각합니다.\n3. encoding UTF-8로 변경 인코딩이 encoding x-windows-949로 설정돼 있는 경우 아래와 같이 UTF-8로 변경하는 것이 좋습니다.\nx-windows-949란 한글 인코딩의 한 종류이며 EUC-KR의 확장형입니다. 오래전 마이크로소프트가 개발했던 한글 인코딩입니다.\n이것도 잘못하여 꼬이면 Swagger UI의 글자가 깨지는 경우가 발생할 수 있습니다.\n위 3가지는 프로젝트 생성 후 한번 쯤 확인해보면 좋은 것이라 생각되네요.\nReference  잘 알려지지 않은 Kotlin에서 빠른 컴파일의 비밀 Gradle \u0026amp; Build 그리고 IntelliJ의 Build 증분 빌드란 https://namu.wiki/w/CP949  ","permalink":"https://haservi.github.io/posts/spring/spring-intellij-start-setting/","summary":"인텔리J에서 스프링 프로젝트를 생성하면 아래 셋팅은 미리 설정하면 좋습니다.\n1. 어노테이션 프로세싱 활성화 롬복과 같은 외부 라이브러리를 의존성 주입하게 될 경우 해당 사항을 체크해줘야 컴파일 시 문제 없이 동작합니다.\n설정에서 검색창에 annotation을 입력하면 아래와 같은 화면이 나옵니다.\n2. Build and run IntelliJ IDEA로 변경 IntelliJ IDEA 인텔리제이 자체에서 제공하는 빌드 자동화 도구입니다.\n기본은 Gradle로 설정 돼 있습니다. 이걸 IntelliJ IDEA로 변경하면 더 빠른 테스트를 할 수 있습니다.\nGradle빌드와 IntelliJ IDEA 빌드의 차이는 증분 빌드 여부입니다.","title":"IntelliJ에서 스프링 프로젝트 관련 설정"},{"content":"Docker 메모리 프로세서 제어 Docker를 사용하다 보면 아래처럼 치솟는 메모리 사용량을 볼 때가 있습니다.\n아래의 방법은 Docker를 테스트 중 메모리 사용량을 Windows에서 제어 하는 방법입니다.\n  탐색기의 사용자 위치(C:\\Users\\\u0026lt;사용자\u0026gt;)에 .wslconfig 파일을 생성합니다.\n  아래와 같이 해당 파일의 설정을 지정합니다.\n# 설정은 WSL 2에서 실행되는 모든 Linux 배포판에 적용 [wsl2] # VM 메모리를 4GB 이하로 제한. # GB 또는 MB를 사용하여 정수로 설정할 수 있음 memory=4GB # 2개의 가상 프로세서를 사용하도록 VM을 설정 processors=2 # 스왑 저장 공간의 양을 8GB로 설정합니다. 기본값은 사용 가능한 RAM의 25%입니다. swap=8GB   위 설정을 적용 후 Docker를 재실행해야 적용됩니다.\n  Mac의 경우는 Mac버전의 Docker Desktop 설정에서 간단하게 변경(링크) 할 수 있습니다.\nvmmem 터미널 강제 종료 Docker도 결국은 가상머신에서 돌고 있는 시스템이기에 WSL(Windows Subsystem for Linux)을 강제 종료하면 메모리와 CPU 점유율을 낮출 수 있습니다.\n좋은 방법은 아니지만 즉각적인 효과는 있습니다.\n커맨드 또는 powershell을 이용하여 아래의 명령어를 입력합니다.\nwsl --shutdown 위의 명령어로 WSL 강제 종료 후 Docker를 재실행하기 위해서는 Docker Desktop이 실행되어 있다면 우측하단의 트레이 아이콘에서 Troubleshoot을 선택합니다.\n선택 후 아래 사진과 같이 Restart를 선택하면 됩니다.\nReference  https://docs.microsoft.com/ko-kr/windows/wsl/wsl-config https://stackoverflow.com/questions/64165192/stopping-vmmem-from-using-ram https://docs.docker.com/desktop/mac/  ","permalink":"https://haservi.github.io/posts/devops/docker/docker-smemory-controll-and-exit/","summary":"Docker 메모리 프로세서 제어 Docker를 사용하다 보면 아래처럼 치솟는 메모리 사용량을 볼 때가 있습니다.\n아래의 방법은 Docker를 테스트 중 메모리 사용량을 Windows에서 제어 하는 방법입니다.\n  탐색기의 사용자 위치(C:\\Users\\\u0026lt;사용자\u0026gt;)에 .wslconfig 파일을 생성합니다.\n  아래와 같이 해당 파일의 설정을 지정합니다.\n# 설정은 WSL 2에서 실행되는 모든 Linux 배포판에 적용 [wsl2] # VM 메모리를 4GB 이하로 제한. # GB 또는 MB를 사용하여 정수로 설정할 수 있음 memory=4GB # 2개의 가상 프로세서를 사용하도록 VM을 설정 processors=2 # 스왑 저장 공간의 양을 8GB로 설정합니다.","title":"Docker 메모리 제한 설정 및 강제 종료"},{"content":"주로 DB를 관리하는 툴로 HeidiSQL를 많이 사용했습니다.\nSpring Data JPA와 QueryDSL 조합을 이용한 뒤로 어느 정도 익숙해지고 나서는 쿼리를 짜는 일이 많이 없지만, 조금 복잡한 쿼리의 경우는 쿼리를 작성해보고 성능 체크 후 QueryDSL로 변환하여 작업합니다.\n하지만 Mac환경에서는 HeidiSQL이 Mac을 지원하지 않기 때문에 다른 DB 툴을 사용해야 합니다.\nMac을 지원하는 다양한 DB툴 중에 평가가 꽤 괜찮은 DBeaver링크에 대해 알아보겠습니다.\nDbeaver 란?  DBeaver는 Windows와 Mac 모두 지원 거의 모든 Database를 지원(MySQL, PostgreSQL, MariaDB, SQLite, Oracle, DB2, SQL Server\u0026hellip;) 오픈 소스 기반으로 다양한 확장 플러그인 지원 Entity Diagarm 지원 DB 내보내기 불러오기 지원  Community 버전을 이용해도 위와 같은 기능을 모두 사용할 수 있습니다.\n바로 다운로드하여 사용해도 되지만 기본적인 테마와 설정을 조금 변경하는 방법입니다.\n테마 뿐만아니라 다양한 확장 플러그인을 지원하기 때문에 필요한 것은 플러그인 검색하면 필요하다고 생각하는 왠만한 것은 나오는 것 같습니다.\n테마 변경 방법 테마 변경은 Mac기준으로 변경 했습니다. Windows도 비슷하긴 하지만 아래처럼 프로그램 재실행 팝업이 뜨면 아니오를 선택하고, 해당 프로그램을 관리자 권한으로 실행해야 합니다.(이후에는 그냥 실행 문제 없음)\n.notice{--root-color: #000; --root-background: #e7f2fa; --title-color: #fff; --title-background: #6ab0de; --warning-title: rgba(217, 83, 79, 0.9); --warning-content: #fae2e2; --info-title: #f0b37e; --info-content: #fff2db; --note-title: #6ab0de; --note-content: #e7f2fa; --tip-title: rgba(92, 184, 92, 0.8); --tip-content: #e6f9e6;}body.dark .notice{--root-color: #fff; --root-background: #e7f2fa; --title-color: #fff; --title-background: #6ab0de; --warning-title: rgba(130, 49, 47, 0.9); --warning-content: #341312; --info-title: #906B4B; --info-content: #392A1E; --note-title: #3f6985; --note-content: #192A35; --tip-title: rgba(46, 92, 46, 0.8); --tip-content: #122412;}.notice{padding: 18px; line-height: 24px; margin-bottom: 24px; border-radius: 4px; color: var(--root-color); background: var(--root-background);}.notice p:last-child{margin-bottom: 0;}.notice-title{margin: -18px -18px 12px; padding: 4px 18px; border-radius: 4px 4px 0 0; font-weight: 700; color: var(--title-color); background: var(--title-background);}.notice.warning .notice-title{background: var(--warning-title);}.notice.warning{background: var(--warning-content);}.notice.info .notice-title{background: var(--info-title);}.notice.info{background: var(--info-content);}.notice.note .notice-title{background: var(--note-title);}.notice.note{background: var(--note-content);}.notice.tip .notice-title{background: var(--tip-title);}.notice.tip{background: var(--tip-content);}.icon-notice{display: inline-flex; align-self: center; margin-right: 8px;}.icon-notice img, .icon-notice svg{height: 1em; width: 1em; fill: currentColor;}.icon-notice img, .icon-notice.baseline svg{top: 0.125em; position: relative;} 경고\nWindows의 경우 테마 설치 후 아니오를 선택 한 뒤 관리자 권한으로 실행해야합니다.\n그렇지 않으면 무한 재부팅 됩니다.    도움말선택 후 install new software를 선택합니다.   사이트 URL에 https://www.genuitec.com/updates/devstyle/ci/를 입력하고 아래의 그림처럼 선택 후 다음 선택합니다.   정상적으로 설치하면 프로그램 이 다시 실행된 후 아래와 같은 화면이 됩니다.   설정 커스텀 설정 커스텀은 쿼리 입력 방법과 결과 출력화면 단축키 들을 변경합니다.\n이 부분은 개인의 성향 차이가 크기 때문에 그냥 참고용으로 보는 것도 괜찮을 것 같습니다.\n  설정은 Commend + ,로 진입하거나 아래처럼 선택하면 됩니다.   문서 편집기 설정 및 표시 설정 변경입니다.   쿼리 실행 시 Blank 구분자 설정 제외(여러 쿼리 실행 시 오류 방지)   Select 결과 컬럼 높이 행 맞춤 및 헤더에 코멘트 출력   쿼리 작성 시 자동완성 기능 해제   컬럼 위치 변경 단축키 지정   자주 쓰는 단축키 단축키는 공식 문서에 잘 나와있으며, 자주 쓰는 단축키는 아래와 같습니다.\n   기능 Windows Mac     쿼리 자동 완성 Ctrl+Space ⌃Space   쿼리 실행 Ctrl+Enter ⌃↩   새로고침 Ctrl+F5 ⌘F5   해당스크립트의 다음 쿼리 ALT+Up ⌃⇧↑   해당스크립트의 이전 쿼리 Alt+Down ⌃⇧↓    이외에도 많은 단축키가 있습니다.\n","permalink":"https://haservi.github.io/posts/tools/how-to-dbeaver/","summary":"주로 DB를 관리하는 툴로 HeidiSQL를 많이 사용했습니다.\nSpring Data JPA와 QueryDSL 조합을 이용한 뒤로 어느 정도 익숙해지고 나서는 쿼리를 짜는 일이 많이 없지만, 조금 복잡한 쿼리의 경우는 쿼리를 작성해보고 성능 체크 후 QueryDSL로 변환하여 작업합니다.\n하지만 Mac환경에서는 HeidiSQL이 Mac을 지원하지 않기 때문에 다른 DB 툴을 사용해야 합니다.\nMac을 지원하는 다양한 DB툴 중에 평가가 꽤 괜찮은 DBeaver링크에 대해 알아보겠습니다.\nDbeaver 란?  DBeaver는 Windows와 Mac 모두 지원 거의 모든 Database를 지원(MySQL, PostgreSQL, MariaDB, SQLite, Oracle, DB2, SQL Server\u0026hellip;) 오픈 소스 기반으로 다양한 확장 플러그인 지원 Entity Diagarm 지원 DB 내보내기 불러오기 지원  Community 버전을 이용해도 위와 같은 기능을 모두 사용할 수 있습니다.","title":"DBeaver 커스텀 셋팅하기"},{"content":"종종 테스트 중 이전에 실행한 Port가 남아서 충돌나는 경우가 있습니다.\n기존에 존재하는 Port의 PID를 제거하면 삭제할 수 있습니다.\nPort 강제 종료 방법  먼저 windows + R 을 눌러 실행 스크립트를 열어주고 cmd를 입력하여 커맨드 창을 열어줍니다. 명령어로 netstat -a -o를 입력하면 현재 연결된 네트워크 상태를 볼 수 있습니다.  위와 같이 8080포트가 존재하면 우측에 있는 PID의 번호를 기억합니다. 여기서는 49480의 값입니다. taskkill /f /pid 49480을 입력하면 해당 8080포트를 제거할 수 있습니다.  ","permalink":"https://haservi.github.io/posts/tips/window-port-taskkill/","summary":"종종 테스트 중 이전에 실행한 Port가 남아서 충돌나는 경우가 있습니다.\n기존에 존재하는 Port의 PID를 제거하면 삭제할 수 있습니다.\nPort 강제 종료 방법  먼저 windows + R 을 눌러 실행 스크립트를 열어주고 cmd를 입력하여 커맨드 창을 열어줍니다. 명령어로 netstat -a -o를 입력하면 현재 연결된 네트워크 상태를 볼 수 있습니다.  위와 같이 8080포트가 존재하면 우측에 있는 PID의 번호를 기억합니다. 여기서는 49480의 값입니다. taskkill /f /pid 49480을 입력하면 해당 8080포트를 제거할 수 있습니다.","title":"윈도우 Port 강제 종료 방법"},{"content":"Visual Studio Code의 자동완성 기능 해제 방법 프로그램 실행 후 설정(Ctrl + , 또는 Command + ,)으로 들어간 후 검색항목에 intelliSense를 검색하면 여러 체크박스 리스트를 볼 수 있습니다.\n위(Show Classes)에서부터 아래(Show Words)까지 전부 체크 해제를 하면 자동완성 기능이 비활성화 됩니다.\n그렇지만 너무 많은 옵션이 있기 때문에 전부 클릭 해제하기가 귀찮은 경우 아래의 JSON으로 추가할 수 있습니다.\n오른쪽 위의 설정으로 들어가서 아래의 값들을 복사 후 붙여 넣어주면 됩니다.\n\u0026#34;explorer.compactFolders\u0026#34;: false, \u0026#34;explorer.confirmDragAndDrop\u0026#34;: false, \u0026#34;editor.suggest.showConstants\u0026#34;: false, \u0026#34;editor.suggest.showConstructors\u0026#34;: false, \u0026#34;editor.suggest.showCustomcolors\u0026#34;: false, \u0026#34;editor.suggest.showDeprecated\u0026#34;: false, \u0026#34;editor.suggest.showEnumMembers\u0026#34;: false, \u0026#34;editor.suggest.showEnums\u0026#34;: false, \u0026#34;editor.suggest.showEvents\u0026#34;: false, \u0026#34;editor.suggest.showFields\u0026#34;: false, \u0026#34;editor.suggest.showFiles\u0026#34;: false, \u0026#34;editor.suggest.showFolders\u0026#34;: false, \u0026#34;editor.suggest.showFunctions\u0026#34;: false, \u0026#34;editor.suggest.showInterfaces\u0026#34;: false, \u0026#34;editor.suggest.showIssues\u0026#34;: false, \u0026#34;editor.suggest.showKeywords\u0026#34;: false, \u0026#34;editor.suggest.showMethods\u0026#34;: false, \u0026#34;editor.suggest.showModules\u0026#34;: false, \u0026#34;editor.suggest.showOperators\u0026#34;: false, \u0026#34;editor.suggest.showProperties\u0026#34;: false, \u0026#34;editor.suggest.showReferences\u0026#34;: false, \u0026#34;editor.suggest.showSnippets\u0026#34;: false, \u0026#34;editor.suggest.showStructs\u0026#34;: false, \u0026#34;editor.suggest.showTypeParameters\u0026#34;: false, \u0026#34;editor.suggest.showUnits\u0026#34;: false, \u0026#34;editor.suggest.showUsers\u0026#34;: false, \u0026#34;editor.suggest.showValues\u0026#34;: false, \u0026#34;editor.suggest.showVariables\u0026#34;: false, \u0026#34;editor.suggest.showWords\u0026#34;: false, \u0026#34;editor.suggest.showClasses\u0026#34;: false, \u0026#34;editor.suggest.showColors\u0026#34;: false 아래의 사진처럼 넣어주면 됩니다. 다시 자동완성 기능이 필요하면 위의 값들을 삭제하거나 intelliSense로 접근하여 해당 항목들을 체크하면 됩니다.\n","permalink":"https://haservi.github.io/posts/tips/visual-studio-code-auto-complete/","summary":"Visual Studio Code의 자동완성 기능 해제 방법 프로그램 실행 후 설정(Ctrl + , 또는 Command + ,)으로 들어간 후 검색항목에 intelliSense를 검색하면 여러 체크박스 리스트를 볼 수 있습니다.\n위(Show Classes)에서부터 아래(Show Words)까지 전부 체크 해제를 하면 자동완성 기능이 비활성화 됩니다.\n그렇지만 너무 많은 옵션이 있기 때문에 전부 클릭 해제하기가 귀찮은 경우 아래의 JSON으로 추가할 수 있습니다.\n오른쪽 위의 설정으로 들어가서 아래의 값들을 복사 후 붙여 넣어주면 됩니다.\n\u0026#34;explorer.compactFolders\u0026#34;: false, \u0026#34;explorer.confirmDragAndDrop\u0026#34;: false, \u0026#34;editor.","title":"비쥬얼 스튜디오 코드에서 자동완성 해제하기"},{"content":"Git Commit git commit message convetion은 회사 또는 프로젝트 마다 다를 수 있습니다.\nmessage의 형태는 다를 수 있지만 기본적인 목적은 같습니다.\n잘 만들어진 git 커밋 메시지는 해당 프로젝트에서 작업하는 팀원과 미래의 자신에게 변경 사항에 대한 의미를 전달하기 위한 좋은 방법입니다.\n일반적으로 커밋 메시지는 다음과 같은 구조를 권장합니다.\ntype: Subject body footer 보통 위와 같은 형태입니다.\n제목은 새로운 기능 추가인 경우 feat: Subject, Feat: Subject, Feat Subject, Feature Subject 등 조금씩 type의 형태가 다르지만 그건 프로젝트에 따라 일관되게 맞추면 됩니다.\n글자 수는 50자 이내로 작성하는 것이 좋으며, issue와 관련이 있다면 제목 옆에 (#issue nubmer)를 추가하는 것도 어떠한 이슈와 관련된 것인지 알기 쉽게 볼 수 있습니다.\n본문은 commit 내용에 대한 추가 설명입니다. 한 줄당 72자 이내로 작성 하는 것이 좋으며, 본문 내용의 경우 변경 사항에 대한 정보를 기입하는 것이 좋습니다.\n푸터는 이슈 트래커 참조 용도로 사용됩니다.\n보통 푸터에 종료 키워드와 이슈 번호를 함께 작성하면 해당 이슈가 종료 처리도 됩니다.\nType의 종류 Type의 종류도 강제적이지는 않습니다. 다만 아래의 정보면 충분히 설명이 가능합니다.\n Feat 새로운 기능 Fix 버그 수정 Docs 문서와 관련된 추가 수정 삭제 Style 코드의 의미에 영향을 주지 않는 변경 사항(공백, 서식, 세미콜론 누락 등) Refactor 버그를 수정하거나 기능을 추가하지 않는 코드 변경 Perf 성능을 향상시키는 코드 변경 Test 테스트 추가 Chore 빌드 프로세스 또는 라이브러리에 대한 변경 사항  제목  총 글자 수 50자 이내로 작성 마지막에 ., !, ? 같은 특수문자 제외 제목은 동사원형 형태로 추가  본문  간단한 변경 사항의 경우 작성할 필요 없음 한 줄 당 72자 이내로 작성 부연 설명 및 어떻게 보다는 무엇을 왜 변경했는지 기입  푸터  간단한 변경 사항의 경우 작성할 필요 없음 이슈 트래커 id를 작성할 때 사용  Reference  좋은 git 커밋 메시지를 작성하기 위한 7가지 약속 협업을 위한 git 커밋 컨벤션 설정하기 How to Write a Git Commit Message How to Write Good Commit Messages: A Practical Git Guide  ","permalink":"https://haservi.github.io/posts/tips/git-commit-message-rule/","summary":"Git Commit git commit message convetion은 회사 또는 프로젝트 마다 다를 수 있습니다.\nmessage의 형태는 다를 수 있지만 기본적인 목적은 같습니다.\n잘 만들어진 git 커밋 메시지는 해당 프로젝트에서 작업하는 팀원과 미래의 자신에게 변경 사항에 대한 의미를 전달하기 위한 좋은 방법입니다.\n일반적으로 커밋 메시지는 다음과 같은 구조를 권장합니다.\ntype: Subject body footer 보통 위와 같은 형태입니다.\n제목은 새로운 기능 추가인 경우 feat: Subject, Feat: Subject, Feat Subject, Feature Subject 등 조금씩 type의 형태가 다르지만 그건 프로젝트에 따라 일관되게 맞추면 됩니다.","title":"Git Commit 메시지 규칙"},{"content":"Windows는 line ending으로 CR(Carriage-Return, \\r)과 LF(Line Feed \\n)을 사용합니다. CRLF는 커서를 다음 라인의 맨앞으로 옮기는 표시이며, ↲ 이러한 표현입니다.\nMac, Linux(Unix 계열)의 경우 LF(Line Feed \\n)를 사용합니다. LF는 현재 위치에서 바로 아래로 이동하는 것을 의미하며, ↓ 와 같은 표현입니다.\n문제는 같은 작업 영역에서 같은 코드를 수정할 경우 windows와 mac의 코드가 일치하더라도 커서의 표현값이 다르기 때문에 충돌이 일어나는 경우가 발생합니다.\n해결 방법으로는 각 운영체제별로 git을 기준으로 LF로 맞춰주는 것입니다.\nWindows는 CRLF를 LF로 변경되도록 git config 설정 중 core.autocrlf를 설정해주면 됩니다. Mac은 기존 개행 형식으로 저장되도록 설정해줍니다.\ncore.autocrlf 는 text file 을 git object database 에 checkin, checkout 할 때 어떻게 처리할지를 설정하는 변수입니다.\nWindows git config --global core.autocrlf true text file을 넣기전 CRLF를 LF로 변경합니다.\nMac git config --global core.autocrlf input Mac, Linux(Unix 계열)의 경우 LF만 사용하기 때문에 input으로 설정하면 됩니다.\n위와 같은 설정은 결국 아래와 같은 그림과 같은 형태로 text 파일이 저장됩니다.\n","permalink":"https://haservi.github.io/posts/tips/git-crlf/","summary":"Windows는 line ending으로 CR(Carriage-Return, \\r)과 LF(Line Feed \\n)을 사용합니다. CRLF는 커서를 다음 라인의 맨앞으로 옮기는 표시이며, ↲ 이러한 표현입니다.\nMac, Linux(Unix 계열)의 경우 LF(Line Feed \\n)를 사용합니다. LF는 현재 위치에서 바로 아래로 이동하는 것을 의미하며, ↓ 와 같은 표현입니다.\n문제는 같은 작업 영역에서 같은 코드를 수정할 경우 windows와 mac의 코드가 일치하더라도 커서의 표현값이 다르기 때문에 충돌이 일어나는 경우가 발생합니다.\n해결 방법으로는 각 운영체제별로 git을 기준으로 LF로 맞춰주는 것입니다.\nWindows는 CRLF를 LF로 변경되도록 git config 설정 중 core.","title":"git CRLF 개행 문자 차이 해결 방법"},{"content":"우선순위 큐(Priority Queue) 란? 우선순위 큐(Priority Queue)는 일반적인 큐의 구조와 달리 들어가는 순서와 상관없이 정의한대로 우선순위를 먼저 결정하고 그 우선순위가 높은 데이터가 먼저 나가는 자료구조 입니다. 그렇기 때문에 dequeue를 하면 이미 정의한 순서에 맞게 가장 위의 값이 나타납니다.\n우선순위 큐는 힙을 기반으로 하는 완전이진트리로 우선순위를 정하게 됩니다.\n사용 방법 우선순위 큐는 우선순위가 꼭 필요한 경우에 사용합니다. 람다식으로 정의해도 되고 Comparable을 이용해서 정의해도 됩니다.\n// 낮은 숫자가 우선순위가 높은 방식 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); // 높은 숫자가 우선순위가 높은 방식 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(Collections.reverseOrder()); // 이중 배열에서 0번째 낮은 숫자가 우선순위가 높은 방식(람다식) PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((o1, o2) -\u0026gt; o1[0] - o2[0]); // 이중 배열에서 0번째 낮은 숫자가 우선순위가 높은 방식(Comparator) PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(new Comparator\u0026lt;int[]\u0026gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] - o2[0]; }; }); 위 처럼 다양한 방법으로 우선순위를 정할 수 있습니다.\n간단한 예제 및 원리 간단히 예를 들어 가장 작은 수를 기준으로 우선순위 큐를 만들면\nPriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); pq.offer(1); pq.offer(2); pq.offer(3); pq.offer(4); pq.offer(5); pq.offer(6); pq.offer(7); 의 형태로 만들어집니다.\n그렇지만 각각 enqueue할 때는 이진트리의 마지막부분에서 조건에 맞게 값이 들어가는거죠.\n위의 경우는 가장작은 수부터 차례로 들어가기 때문에 swap을 하지 않고 값이 들어가게됩니다.\n그렇지만 만약 큰 수부터 우선순위 큐를 하게 되면\nPriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(Collections.reverseOrder()); pq.offer(1); pq.offer(2); pq.offer(3); pq.offer(4); pq.offer(5); pq.offer(6); pq.offer(7); 의 형태로 만들어집니다. 위의 순서를 그림으로 그리면 아래와 같은 순서로 완전 이진트리 형태로 값이 들어갑니다.\n조건에 맞게 우선 가장 마지막 노드에 값이 들어가고 부모와 비교를 해서 자신의 위치를 찾아가는 것이죠.\n반대로 dequeue인 poll()의 경우는 우선 Root를 제거하고 가장 마지막의 노드를 Root로 가져온 뒤 자식노드 중 자신보다 우선순위가 높은 값이 있다면 Swap을 하여 자신의 위치를 찾아가는 식입니다.\nwhile (!pq.isEmpty()) { pq.poll(); } 실제로 코드 내부로 들어가면 enqueue의 경우는 아래와 같이 Comparable로 정의하고 부모 노드와 현재 노드를 변경하는 코드가 들어가 있습니다.\npublic boolean offer(E e) { if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i \u0026gt;= queue.length) grow(i + 1); siftUp(i, e); size = i + 1; return true; } private void siftUp(int k, E x) { if (comparator != null) siftUpUsingComparator(k, x, queue, comparator); else siftUpComparable(k, x, queue); } private static \u0026lt;T\u0026gt; void siftUpComparable(int k, T x, Object[] es) { Comparable\u0026lt;? super T\u0026gt; key = (Comparable\u0026lt;? super T\u0026gt;) x; while (k \u0026gt; 0) { int parent = (k - 1) \u0026gt;\u0026gt;\u0026gt; 1; Object e = es[parent]; if (key.compareTo((T) e) \u0026gt;= 0) break; es[k] = e; k = parent; } es[k] = key; } private static \u0026lt;T\u0026gt; void siftUpUsingComparator( int k, T x, Object[] es, Comparator\u0026lt;? super T\u0026gt; cmp) { while (k \u0026gt; 0) { int parent = (k - 1) \u0026gt;\u0026gt;\u0026gt; 1; Object e = es[parent]; if (cmp.compare(x, (T) e) \u0026gt;= 0) break; es[k] = e; k = parent; } es[k] = x; } 마찬가지로 dequeue의 경우도 Comparable로 정의하고 child 노드와 현재 노드를 변경하는 식의 코드가 들어있습니다.\npublic E poll() { final Object[] es; final E result; if ((result = (E) ((es = queue)[0])) != null) { modCount++; final int n; final E x = (E) es[(n = --size)]; es[n] = null; if (n \u0026gt; 0) { final Comparator\u0026lt;? super E\u0026gt; cmp; if ((cmp = comparator) == null) siftDownComparable(0, x, es, n); else siftDownUsingComparator(0, x, es, n, cmp); } } return result; } private static \u0026lt;T\u0026gt; void siftDownComparable(int k, T x, Object[] es, int n) { // assert n \u0026gt; 0;  Comparable\u0026lt;? super T\u0026gt; key = (Comparable\u0026lt;? super T\u0026gt;)x; int half = n \u0026gt;\u0026gt;\u0026gt; 1; // loop while a non-leaf  while (k \u0026lt; half) { int child = (k \u0026lt;\u0026lt; 1) + 1; // assume left child is least  Object c = es[child]; int right = child + 1; if (right \u0026lt; n \u0026amp;\u0026amp; ((Comparable\u0026lt;? super T\u0026gt;) c).compareTo((T) es[right]) \u0026gt; 0) c = es[child = right]; if (key.compareTo((T) c) \u0026lt;= 0) break; es[k] = c; k = child; } es[k] = key; } private static \u0026lt;T\u0026gt; void siftDownUsingComparator( int k, T x, Object[] es, int n, Comparator\u0026lt;? super T\u0026gt; cmp) { // assert n \u0026gt; 0;  int half = n \u0026gt;\u0026gt;\u0026gt; 1; while (k \u0026lt; half) { int child = (k \u0026lt;\u0026lt; 1) + 1; Object c = es[child]; int right = child + 1; if (right \u0026lt; n \u0026amp;\u0026amp; cmp.compare((T) c, (T) es[right]) \u0026gt; 0) c = es[child = right]; if (cmp.compare(x, (T) c) \u0026lt;= 0) break; es[k] = c; k = child; } es[k] = x; } ","permalink":"https://haservi.github.io/posts/algorithms/priority-queue/","summary":"우선순위 큐(Priority Queue) 란? 우선순위 큐(Priority Queue)는 일반적인 큐의 구조와 달리 들어가는 순서와 상관없이 정의한대로 우선순위를 먼저 결정하고 그 우선순위가 높은 데이터가 먼저 나가는 자료구조 입니다. 그렇기 때문에 dequeue를 하면 이미 정의한 순서에 맞게 가장 위의 값이 나타납니다.\n우선순위 큐는 힙을 기반으로 하는 완전이진트리로 우선순위를 정하게 됩니다.\n사용 방법 우선순위 큐는 우선순위가 꼭 필요한 경우에 사용합니다. 람다식으로 정의해도 되고 Comparable을 이용해서 정의해도 됩니다.\n// 낮은 숫자가 우선순위가 높은 방식 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); // 높은 숫자가 우선순위가 높은 방식 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(Collections.","title":"Java Priority Queue(우선순위 큐) 원리 및 사용 방법"},{"content":"H2를 최신 버전(2.1.210)으로 업데이트하니 아래와 같은 에러가 발생했습니다.\nCaused by: org.hibernate.HibernateException: Access to DialectResolutionInfo cannot be null when \u0026#39;hibernate.dialect\u0026#39; not set ... java.lang.IllegalStateException: Failed to load ApplicationContext at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132) at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:124) at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:190) ... 일단 임시방편으로 H2 url을 연결하는 곳에 추가적으로 옵션(;MODE=LEGACY)을 넣으면 해결됩니다.\nurl: jdbc:h2:tcp://localhost/~/test;MODE=LEGACY MODE=LEGACY를 모드를 사용하면 H2 1.X용으로 작성된 응용 프로그램에 대한 일부 호환성 기능이 활성화됩니다. Hibernate ORM에서 H2에 대해서 유효하지 않은 SQL을 생성하기 때문이라고 합니다.\n그렇다면.. hibernate ORM에서 H2 방언에 대한 문제를 해결해야 합니다.\n현재는 hibernate ORM은 5.6 안정화 버전과 6.0 개발 버전이 있습니다.\nReference  Upgrade H2 version 2.0.202 from 1.4.200 h2database document  ","permalink":"https://haservi.github.io/posts/spring/spadework/h2-version-upgrade-error/","summary":"H2를 최신 버전(2.1.210)으로 업데이트하니 아래와 같은 에러가 발생했습니다.\nCaused by: org.hibernate.HibernateException: Access to DialectResolutionInfo cannot be null when \u0026#39;hibernate.dialect\u0026#39; not set ... java.lang.IllegalStateException: Failed to load ApplicationContext at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132) at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:124) at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:190) ... 일단 임시방편으로 H2 url을 연결하는 곳에 추가적으로 옵션(;MODE=LEGACY)을 넣으면 해결됩니다.\nurl: jdbc:h2:tcp://localhost/~/test;MODE=LEGACY MODE=LEGACY를 모드를 사용하면 H2 1.X용으로 작성된 응용 프로그램에 대한 일부 호환성 기능이 활성화됩니다. Hibernate ORM에서 H2에 대해서 유효하지 않은 SQL을 생성하기 때문이라고 합니다.\n그렇다면.. hibernate ORM에서 H2 방언에 대한 문제를 해결해야 합니다.","title":"H2 2.1.210 Upgrade시 JPA 테스트 에러 해결 방법"},{"content":"JPQL 이란? 예전에는 JPQL은 Java Persistence Query Language로 불렸지만 현재의 JPQL은(Jakarta Persistence Query Language) 라고 합니다.(나무위키 링크)\n2019년부터 JPA(Java Persistence API)또한 Jakarta Persistence로 변경됐습니다.\n이름은 달라졌지만 역할은 달라지지 않았습니다. JPQL을 이용하여 관계형 데이터베이스의 엔티티를 정의하고 이를 활용한 쿼리 언어를 자바를 이용하여 구현합니다.\n더 나아가 Querydsl을 이용하면 좀 더 직관적이고 오류 없이 자바를 이용하여 작성할 수 있습니다.\n간단한 예시로 회원 조회를 하는 경우 JPQL과 Querydsl의 차이는 아래와 같습니다.\nJPQL\npublic List\u0026lt;Member\u0026gt; findAll() { EntityManager entityManager; return entityManager.createQuery(\u0026#34;select m from Member m \u0026#34;, Member.class) .getResultList(); } Querydsl\npublic List\u0026lt;Member\u0026gt; findAll() { JPAQueryFactory queryFactory; return queryFactory .selectFrom(QMember.member) .fetch(); } 결국은 같은 결과를 호출하지만 Querydsl을 이용하면 쿼리작성 및 빌드 오류를 컴파일 시점에 방지할 수 있습니다.\n가독성도 Querydsl쪽이 더 좋습니다.\nSpring Data JPA란? CRUD 처리를 위한 공통 인터페이스를 JPA에서 미리 만들어 놓은 것입니다.\n일반적으로 Entity 어노테이션을 선언한 클래스를 매개변수로 JpaRepository 인터페이스를 상속받아 사용합니다.\n이렇게되면 실제로 SQL관련 코드하나 사용하지 않고 간단한 CRUD는 처리가 가능합니다.\n사용자 정의 인터페이스 상속받기 인터페이스는 다중상속이 가능하기 때문에 먼저 CustomRepository를 인터페이스로 생성합니다.\npublic interface CustomMemberRepository { void customSave(Member member); } 그리고 구현체에 해당 선언한 함수들을 구현합니다.\n@RequiredArgsConstructor public class CustomMemberRepositoryImpl implements CustomMemberRepository { private final EntityManager em; @Override public void customSave(Member member) { em.persist(member); } } 마지막으로 직접사용할 인터페이스에 위의 인터페이스를 추가합니다.\npublic interface MemberRepository extends JpaRepository\u0026lt;Member, Long\u0026gt;, CustomMemberRepository { } 위와 같이 스프링 데이터 JPA에서 제공하는 기능과 필요한 기능이 복잡해짐에 따른 커스텀 쿼리를 인터페이스화 하여 함께 사용할 수 있습니다.\n같은 결과라도 memberRepository.customSave(member)와 memberRepository.save(member)의 방식이 다릅니다.\n아래는 package org.springframework.data.jpa.repository.support;에서 구현된 save(S entity) 구현체 입니다.\n@Transactional @Override public \u0026lt;S extends T\u0026gt; S save(S entity) { Assert.notNull(entity, \u0026#34;Entity must not be null.\u0026#34;); if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else { return em.merge(entity); } } 스프링 데이터 JPA에서 제공하는 함수 가이드 링크 입니다.\n","permalink":"https://haservi.github.io/posts/spring/springdatajpa-and-customquery/","summary":"JPQL 이란? 예전에는 JPQL은 Java Persistence Query Language로 불렸지만 현재의 JPQL은(Jakarta Persistence Query Language) 라고 합니다.(나무위키 링크)\n2019년부터 JPA(Java Persistence API)또한 Jakarta Persistence로 변경됐습니다.\n이름은 달라졌지만 역할은 달라지지 않았습니다. JPQL을 이용하여 관계형 데이터베이스의 엔티티를 정의하고 이를 활용한 쿼리 언어를 자바를 이용하여 구현합니다.\n더 나아가 Querydsl을 이용하면 좀 더 직관적이고 오류 없이 자바를 이용하여 작성할 수 있습니다.\n간단한 예시로 회원 조회를 하는 경우 JPQL과 Querydsl의 차이는 아래와 같습니다.\nJPQL\npublic List\u0026lt;Member\u0026gt; findAll() { EntityManager entityManager; return entityManager.","title":"Spring Data JPA와 JPQL 함께 사용하기"},{"content":"Mybatis란? 자바의 관계형 데이터베이스 프로그래밍을 좀 더 쉽게 할 수 있게 도와 주는 개발 프레임 워크입니다.\nJDBC를 통해 데이터베이스에 엑세스하는 작업을 캡슐화하고 일반 SQL 쿼리, 저장 프로시저 및 고급 매핑을 지원하며 모든 JDBC 코드 및 매개 변수의 중복작업을 제거 합니다.\n또한 Java코드와 SQL코드를 분리하여 서로 다른 역할에 집중할 수 있게 합니다.\nMyBatis는 DAO(Data Access Object)인터페이스를 통해 SQL과 연결 후 VO(Value Object) 또는 DTO(Data Transfer Object)로 바로 데이터를 가져옵니다.\nJPA란? JPA(Java Persistence API)는 ORM(Object-Relational Mapping) 기술 표준으로 JPA가 제공하는 API를 사용하면 직접적으로 SQL을 사용하지 않고도 DB에 접근이 가능합니다.\nJPA는 반복적인 CRUD 작업을 이미 인터페이스에서 제공하고 있습니다. JPA를 제대로 사용하기 위해서는 약간의 러닝커브가 존재하지만 익숙해지면 빠른 개발과 유지보수 측면에서 효율적입니다.\nJPA는 Entity와 DTO(Data Transper Object)를 구분지어서 정의하는 것이 좋습니다. 컨트롤러에서는 DTO를 통해 유효성검사 및 FrontEnd와의 연결을 책임지며, DB와 관련된 것은 Entity로 제어 하는거죠. 이러한 Object Mapping은 직접 함수를 만들거나 라이브러리를 이용해도 됩니다.\n자주 사용하는 라이브러리는 Model Mapper와 Map Struct가 대표적이며, 성능 이슈가 적은 Map Struct 사용을 추천합니다.\n일반적으로 JPA는 Spring Data JPA와 Querydsl 조합을 많이 사용합니다.\nMabatis or JPA 그렇지만 현재의 구글 트렌드를 검색해보면 전세계적으로는 압도적으로 JPA가 우위에 있으며 우리나라의 경우는 비슷한 정도로 나타납니다.\nJPA와 MyBatis와의 차이점이라면 DB를 바라보는 관점이 다른 것 같습니다.\n서로의 장단점이 있기 때문에 프로젝트의 성격과 적합도에 맞게 선택하는 것이 좋을 것 같습니다.\nJPA가 조금 더 공부해야 할 것이 많긴 하지만 잘 이해하고 사용하면 유지보수하기 좋을 것 같다 생각합니다.😓\n","permalink":"https://haservi.github.io/posts/spring/mybatis-and-jpa/","summary":"Mybatis란? 자바의 관계형 데이터베이스 프로그래밍을 좀 더 쉽게 할 수 있게 도와 주는 개발 프레임 워크입니다.\nJDBC를 통해 데이터베이스에 엑세스하는 작업을 캡슐화하고 일반 SQL 쿼리, 저장 프로시저 및 고급 매핑을 지원하며 모든 JDBC 코드 및 매개 변수의 중복작업을 제거 합니다.\n또한 Java코드와 SQL코드를 분리하여 서로 다른 역할에 집중할 수 있게 합니다.\nMyBatis는 DAO(Data Access Object)인터페이스를 통해 SQL과 연결 후 VO(Value Object) 또는 DTO(Data Transfer Object)로 바로 데이터를 가져옵니다.\nJPA란? JPA(Java Persistence API)는 ORM(Object-Relational Mapping) 기술 표준으로 JPA가 제공하는 API를 사용하면 직접적으로 SQL을 사용하지 않고도 DB에 접근이 가능합니다.","title":"Mybatis와 JPA에 대하여"},{"content":"@Autowired는 필드 주입이고, @RequiredArgsConstructor는 생성자 주입(Constructor Injection) 입니다.\n@RequiredArgsConstructor는 Lombok에서 제공하는 어노테이션 입니다.\n결론적으로 생성자 주입을 권장합니다. 인텔리제이에서 코드를 작성하다보면 @Autowired를 사용하면 아래와 같은 경고를 알려줍니다.\n.notice{--root-color: #000; --root-background: #e7f2fa; --title-color: #fff; --title-background: #6ab0de; --warning-title: rgba(217, 83, 79, 0.9); --warning-content: #fae2e2; --info-title: #f0b37e; --info-content: #fff2db; --note-title: #6ab0de; --note-content: #e7f2fa; --tip-title: rgba(92, 184, 92, 0.8); --tip-content: #e6f9e6;}body.dark .notice{--root-color: #fff; --root-background: #e7f2fa; --title-color: #fff; --title-background: #6ab0de; --warning-title: rgba(130, 49, 47, 0.9); --warning-content: #341312; --info-title: #906B4B; --info-content: #392A1E; --note-title: #3f6985; --note-content: #192A35; --tip-title: rgba(46, 92, 46, 0.8); --tip-content: #122412;}.notice{padding: 18px; line-height: 24px; margin-bottom: 24px; border-radius: 4px; color: var(--root-color); background: var(--root-background);}.notice p:last-child{margin-bottom: 0;}.notice-title{margin: -18px -18px 12px; padding: 4px 18px; border-radius: 4px 4px 0 0; font-weight: 700; color: var(--title-color); background: var(--title-background);}.notice.warning .notice-title{background: var(--warning-title);}.notice.warning{background: var(--warning-content);}.notice.info .notice-title{background: var(--info-title);}.notice.info{background: var(--info-content);}.notice.note .notice-title{background: var(--note-title);}.notice.note{background: var(--note-content);}.notice.tip .notice-title{background: var(--tip-title);}.notice.tip{background: var(--tip-content);}.icon-notice{display: inline-flex; align-self: center; margin-right: 8px;}.icon-notice img, .icon-notice svg{height: 1em; width: 1em; fill: currentColor;}.icon-notice img, .icon-notice.baseline svg{top: 0.125em; position: relative;} 경고\nField injection is not recommended\nInspection info: Spring Team recommends: \u0026ldquo;Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies\u0026rdquo;.\n 뭐.. 추천하지 않고 생성자 주입방식을 쓰라고 하는거 같네요.\n생성자 주입으로 코드를 작성하면 아래와 같은 장점이 있습니다.\n 순환 참조 방지 테스트 코드 작성 용이 코드 악취 제거 객체 변이 방지  필드 주입방식을 쓰면 아래와 같은 단점이 있습니다.\n 단일 책임의 원칙 위반 숨은 의존성 제공 의존성을 가진 클랙스를 곧바로 인스턴스화 할 수 없음 final을 선언할 수 없기 때문에 객체가 변할 수 있음  Lombok를 쓰면 아래와 같이 간단하게 처리 할 수 있습니다.\n@Controller @RequiredArgsConstructor public class ItemController { private final ItemService itemService; private final OrderService orderService; } 만약 Lombok을 사용하지 않으면 아래와 같이 처리해야 합니다. 아래와 같이 생성자가 1개인 경우는 @Autowired를 생략해도 됩니다.\n@Controller public class ItemController { private final ItemService itemService; private final OrderService orderService; @Autowired public ItemController(final ItemService itemService, final OrderService orderService) { this.itemService = itemService; this.orderService = orderService; } } ","permalink":"https://haservi.github.io/posts/spring/diff-requiredargsconstructor-autowired/","summary":"@Autowired는 필드 주입이고, @RequiredArgsConstructor는 생성자 주입(Constructor Injection) 입니다.\n@RequiredArgsConstructor는 Lombok에서 제공하는 어노테이션 입니다.\n결론적으로 생성자 주입을 권장합니다. 인텔리제이에서 코드를 작성하다보면 @Autowired를 사용하면 아래와 같은 경고를 알려줍니다.\n.notice{--root-color: #000; --root-background: #e7f2fa; --title-color: #fff; --title-background: #6ab0de; --warning-title: rgba(217, 83, 79, 0.9); --warning-content: #fae2e2; --info-title: #f0b37e; --info-content: #fff2db; --note-title: #6ab0de; --note-content: #e7f2fa; --tip-title: rgba(92, 184, 92, 0.8); --tip-content: #e6f9e6;}body.dark .notice{--root-color: #fff; --root-background: #e7f2fa; --title-color: #fff; --title-background: #6ab0de; --warning-title: rgba(130, 49, 47, 0.9); --warning-content: #341312; --info-title: #906B4B; --info-content: #392A1E; --note-title: #3f6985; --note-content: #192A35; --tip-title: rgba(46, 92, 46, 0.","title":"@Autowired와 @RequiredArgsConstructor 차이점 "},{"content":"logitech options 란? 일부 로지텍 마우스 중에는 특정 소프트웨어를 지원하는 기능이 있습니다.\n그 중 logitech options는 Flow기능으로 기기간 파일전송이나 하나의 마우스로 여러대의 기기를 제어할 수 있습니다.\n이번에 소개해드릴 기능은 Flow기능이 아닌 마우스 제스처 모드에 따른 설정입니다.\n설치 해당 사이트에서 OS에 맞는 프로그램을 설치하면 됩니다.\n설치 후 정상적으로 마우스가 연결되면 아래와 비슷한 사진이 보입니다.\n커스텀 설정하기 프로그램 실행 후 흰색 동그라미가 있는 모든 버튼이 커스텀 가능합니다.\n저의 경우 뒤로가기와 앞으로가기 버튼만 커스텀하여 사용하고 있습니다.\n해당 프로그램은 특정 소프트웨어에서 다르게 커스텀을 적용할 수 있습니다. 아래는 제가 사용하는 입력할 키 지정 모드입니다.\n.notice{--root-color: #000; --root-background: #e7f2fa; --title-color: #fff; --title-background: #6ab0de; --warning-title: rgba(217, 83, 79, 0.9); --warning-content: #fae2e2; --info-title: #f0b37e; --info-content: #fff2db; --note-title: #6ab0de; --note-content: #e7f2fa; --tip-title: rgba(92, 184, 92, 0.8); --tip-content: #e6f9e6;}body.dark .notice{--root-color: #fff; --root-background: #e7f2fa; --title-color: #fff; --title-background: #6ab0de; --warning-title: rgba(130, 49, 47, 0.9); --warning-content: #341312; --info-title: #906B4B; --info-content: #392A1E; --note-title: #3f6985; --note-content: #192A35; --tip-title: rgba(46, 92, 46, 0.8); --tip-content: #122412;}.notice{padding: 18px; line-height: 24px; margin-bottom: 24px; border-radius: 4px; color: var(--root-color); background: var(--root-background);}.notice p:last-child{margin-bottom: 0;}.notice-title{margin: -18px -18px 12px; padding: 4px 18px; border-radius: 4px 4px 0 0; font-weight: 700; color: var(--title-color); background: var(--title-background);}.notice.warning .notice-title{background: var(--warning-title);}.notice.warning{background: var(--warning-content);}.notice.info .notice-title{background: var(--info-title);}.notice.info{background: var(--info-content);}.notice.note .notice-title{background: var(--note-title);}.notice.note{background: var(--note-content);}.notice.tip .notice-title{background: var(--tip-title);}.notice.tip{background: var(--tip-content);}.icon-notice{display: inline-flex; align-self: center; margin-right: 8px;}.icon-notice img, .icon-notice svg{height: 1em; width: 1em; fill: currentColor;}.icon-notice img, .icon-notice.baseline svg{top: 0.125em; position: relative;} 알림\n모든 이미지는 Windows를 기준으로 작성했으며, 응용 프로그램의 경우 공통 제스처모드이면 각각 설정값을 입력해야합니다.\n 뒤로가기 버튼 뒤로가기 버튼의 제스처 모드는 2가지 입니다. 이것만 설정해도 매우 편하게 이용할 수 있습니다.\n공통    설명 제스처 Windows Mac     데스크탑 왼쪽 뒤로가기 버튼 클릭 + 왼쪽 이동 Ctrl + Window + ← control + ←   데스크탑 오른쪽 뒤로가기 버튼 클릭 + 오른쪽 이동 Ctrl + Window + → control + →   뒤로 뒤로가기 버튼 클릭 뒤로가기 뒤로가기    아래와 같이 설정했습니다.\n앞으로가기 버튼 앞으로가기 버튼의 경우 우측 상단의 프로그램마다 설정을 할 수 있습니다.\n코딩 시 디버깅을 할 때 IDE마다 조금씩 디버깅 버튼이 다를 수 있습니다. 그렇기 때문에 자주 사용하는 프로그램의 경우 디버깅 버튼을 단축키로 지정합니다.\n다음과 같이 모든 방향 제스처를 통일하였습니다.\n 앞으로가기 버튼 클릭 + 위 : Step Out 앞으로가기 버튼 클릭 + 아래 : Step Into 앞으로가기 버튼 클릭 + 왼쪽 : Continue 앞으로가기 버튼 클릭 + 오른쪽 : Step Over  거의 대다수 프로그램이 위와 같은 디버깅 로직입니다. 그렇기 때문에 응용프로그램을 선택 후 입력할 키 지정만 올바르게 하면 IDE마다 동일한 제스처로 디버깅이 가능합니다.\n간단하게 Visual Studio Code와 Eclipse IntelliJ 정도만 설정하면 다음과 같습니다.\nSTS(Spring Tools)    설명 제스처 Windows Mac     Step Out 앞으로가기 버튼 클릭 + 위 F7 F7   Step Into 앞으로가기 버튼 클릭 + 아래 F5 F5   Continue 앞으로가기 버튼 클릭 + 왼쪽 F8 F8   Step Over 앞으로가기 버튼 클릭 + 오른쪽 F6 F6    Visual Studio Code    설명 제스처 Windows Mac     Step Out 앞으로가기 버튼 클릭 + 위 Shift + F11 Shift + F11   Step Into 앞으로가기 버튼 클릭 + 아래 F11 F11   Continue 앞으로가기 버튼 클릭 + 왼쪽 F5 F5   Step Over 앞으로가기 버튼 클릭 + 오른쪽 F10 F10    IntelliJ    설명 제스처 Windows Mac     Step Out 앞으로가기 버튼 클릭 + 위 Shift + F8 Shift + F8   Step Into 앞으로가기 버튼 클릭 + 아래 F7 F7   Continue 앞으로가기 버튼 클릭 + 왼쪽 F9 F9   Step Over 앞으로가기 버튼 클릭 + 오른쪽 F8 F8    이외에도 마우스를 이용하여 다양한 옵션과 제스처를 설정할 수 있습니다.\n","permalink":"https://haservi.github.io/posts/tools/how-to-logitech-option/","summary":"logitech options 란? 일부 로지텍 마우스 중에는 특정 소프트웨어를 지원하는 기능이 있습니다.\n그 중 logitech options는 Flow기능으로 기기간 파일전송이나 하나의 마우스로 여러대의 기기를 제어할 수 있습니다.\n이번에 소개해드릴 기능은 Flow기능이 아닌 마우스 제스처 모드에 따른 설정입니다.\n설치 해당 사이트에서 OS에 맞는 프로그램을 설치하면 됩니다.\n설치 후 정상적으로 마우스가 연결되면 아래와 비슷한 사진이 보입니다.\n커스텀 설정하기 프로그램 실행 후 흰색 동그라미가 있는 모든 버튼이 커스텀 가능합니다.\n저의 경우 뒤로가기와 앞으로가기 버튼만 커스텀하여 사용하고 있습니다.","title":"Logitech Options를 이용한 마우스 커스텀하기"},{"content":"Git Command를 사용하면서 자주 사용하는 명령어를 정리했습니다.\n이외에도 수많은 명령어가 존재하지만 작업과 관련된 명령어는 아래의 경우로 충분하다고 생각합니다.\n해당 명령어 이외에 더 참고하고 싶다면 https://git-scm.com/book/ko/v2 해당 사이트에서 무료로 책을 다운로드 받아서 볼 수 있습니다.\n또한, 요즘은 소스트리(https://www.sourcetreeapp.com/)에서 GUI로 편하게 작업할 수 도 있습니다.\n기본적인 명령어는 숙지하는 것이 좋지만 history나 간단한 업무용으로는 충분하다고 생각합니다.\n기본 명령어   git 설정 보기\ngit config --list   사용자 이름 입력\ngit config --global user.name \u0026#34;이름\u0026#34;   사용자 이메일 입력\ngit config --global user.email \u0026#34;이메일\u0026#34;   자주쓰는 명령어 작업과 관련된 명령어   git branch 정보보기\ngit branch -a   git branch 변경하기\ngit checkout 브랜치명   코드 수정 관련 명령어   수정하거나 추가한 파일 모두 스테이지에 올리기\n// 전체 작업 한번에 올리기 git add -A // 특정 파일만 올리기 git add README.md(파일명)   스테이지에 올라간 코드 나의 작업에 Commit 하기\ngit commit -m \u0026#34;작업한 코멘트\u0026#34;   Git 작업 내역 확인하기\ngit status   Commit한 작업 내역 push 하기\ngit push   자주는 안쓰지만 종종 써야하는 명령어   Git 삭제\nsudo apt-get remove git   이미 push한 최종 커밋 메시지 변경\ngit commit --amend -m \u0026#34;변경할 메시지\u0026#34; git push origin 브랜치명 -f   가장 최근 push 제거\ngit reset HEAD^ git commit -m \u0026#34;commit delete\u0026#34; git push origin 브랜치명 -f   workspace작업 정보 stash에 저장\ngit stash   stash 목록 확인\ngit stash list   가장 최근 stash 적용\ngit stash apply   특정 stash 적용\ngit stash apply [stash 이름]   가장 최근 stash 삭제\ngit stash drop   특정 stash 삭제\ngit stash drop [stash 이름]   설정과 관련된 명령어   한글 깨짐 현상 수정\ngit config --global core.quotepath false   Git 대소문자 인식(특정 git 폴더 내에서)\ngit config core.ignorecase false   ","permalink":"https://haservi.github.io/posts/tips/git-frequently-used-commands/","summary":"Git Command를 사용하면서 자주 사용하는 명령어를 정리했습니다.\n이외에도 수많은 명령어가 존재하지만 작업과 관련된 명령어는 아래의 경우로 충분하다고 생각합니다.\n해당 명령어 이외에 더 참고하고 싶다면 https://git-scm.com/book/ko/v2 해당 사이트에서 무료로 책을 다운로드 받아서 볼 수 있습니다.\n또한, 요즘은 소스트리(https://www.sourcetreeapp.com/)에서 GUI로 편하게 작업할 수 도 있습니다.\n기본적인 명령어는 숙지하는 것이 좋지만 history나 간단한 업무용으로는 충분하다고 생각합니다.\n기본 명령어   git 설정 보기\ngit config --list   사용자 이름 입력\ngit config --global user.","title":"자주 사용하는 Git Command 정리"},{"content":"Service, ServiceImpl Spring 프로젝트를 하면 종종 관례적으로 Service를 interface로 기능 명세를 한 뒤 ServiceImpl에 기능을 구현하게 되는 Factory Pattern을 사용하게 됩니다.\ninterface는 기능을 추상화하여 클래스간 결합도를 낮추어 주고, 협업 시 업무분담도 용이합니다.\n게임으로 예를 들면 스타크래프트에서 모든 유닛의 기본적인 특성 HP, 이동하기를 interface로 기능만 명시하고 각각 분업하여 유닛에 대한 HP나 이동속도를 구현할 수 있습니다.\n하지만 일반적인 Spring 웹프로젝트에서는 Service interface는 1:1 구조인 경우가 많습니다. 만약 확장성을 고려한 1:N의 경우에는 interface로 가는 것이 좋지만 너무 막연한 경우에는 그냥 class로 생성 후 추후 시나리오 변경 또는 로직상 확장성이 필요한 경우 interface로 변경하는 것이 좋다고 생각합니다.\n그렇다면 interface를 사용하는 경우는 어떤 경우에 사용해야할까요??\n보통 하나의 기능에서 여러 곳으로 파생되는 것을 interface로 나누는게 좋을 것 같습니다.\n예를 들어 소셜로그인, 패스워드 변경(개인정보수정, 패스워드찾기), 아이디 찾기(휴대폰 인증, 이메일 인증, 기타 등등), 카드 결제(카드사 별 결제 취소), 게임(게임별 플레이, 종료)등이 있습니다.\n공통적으로 쓰이는 기능을하나의 기능에서 충분히 확장될 수 있는 경우 interface를 사용하는 것이 좋습니다.\n로그인의 기능을 만들 때 Spring Security의 OAuth2를 이용하여 보통 기능 구현을 합니다.\n그렇지만 oauth2를 사용하지 않고 기능을 구현하는 경우를 샘플 코드를 이용하여 설명해보겠습니다.\n먼저 로그인 유형에 대한 정의를 합니다.\npublic enum AuthProvider { local, google, kakao, github, naver } 그런 뒤 LoginService로 인터페이스를 생성합니다.\npublic interface LoginService { LoginDto.Response login(LoginDto.Request dto); } 그리고 소셜에 따라 로그인 서비스에 맞게 구현 로직을 추가합니다. 이제 로그인 요청이 들어오면 해당 소셜 로그인이 동작하도록 LoginFactory 클래스를 생성합니다.\npublic LoginService getLoginType(LoginDto.Request dto) { if (dto == null) { return null; } if (dto.getAuthProvider().equals(AuthProvider.github)) { return new LoginGithubService(); } else if (dto.getAuthProvider().equals(AuthProvider.google)) { return new LoginGoogleService(); } else if (dto.getAuthProvider().equals(AuthProvider.kakao)) { return new LoginKakaoService(); } else if (dto.getAuthProvider().equals(AuthProvider.naver)) { return new LoginGoogleService(); } else if (dto.getAuthProvider().equals(AuthProvider.local)) { return new LoginLocalService(); } return null; } 안의 내용들은 구현하지 않고 해당 로직을 타는지 print만 했습니다.\n위와 같이 구현하면 dto 요청에서 소셜 로그인 정보와 일치하는 Service의 로직이 동작합니다.\nTest코드로 확인하기 위해 정상적으로 하는지 확인해봅니다.\n@Test void 로그인_타입_테스트() { LoginFactory loginFactory = new LoginFactory(); LoginDto.Request request = new LoginDto.Request(); LoginService loginService = new LoginLocalService(); request.setAuthProvider(AuthProvider.github); loginService = loginFactory.getLoginType(request); loginService.login(request); request.setAuthProvider(AuthProvider.google); loginService = loginFactory.getLoginType(request); loginService.login(request); request.setAuthProvider(AuthProvider.kakao); loginService = loginFactory.getLoginType(request); loginService.login(request); request.setAuthProvider(AuthProvider.naver); loginService = loginFactory.getLoginType(request); loginService.login(request); request.setAuthProvider(AuthProvider.local); loginService = loginFactory.getLoginType(request); loginService.login(request); } 테스트 코드를 통해 service가 정상적으로 동작하는지 확인 할 수 있습니다.\nReference  https://www.manty.co.kr/bbs/detail/develop?id=13 https://itzjamie96.github.io/2021/01/24/spring-service-and-serviceimpl/ https://cheese10yun.github.io/spring-oop-04/ https://blog.jiniworld.me/55 https://www.tutorialspoint.com/design_pattern/factory_pattern.htm  ","permalink":"https://haservi.github.io/posts/spring/service-and-serviceimp/","summary":"Service, ServiceImpl Spring 프로젝트를 하면 종종 관례적으로 Service를 interface로 기능 명세를 한 뒤 ServiceImpl에 기능을 구현하게 되는 Factory Pattern을 사용하게 됩니다.\ninterface는 기능을 추상화하여 클래스간 결합도를 낮추어 주고, 협업 시 업무분담도 용이합니다.\n게임으로 예를 들면 스타크래프트에서 모든 유닛의 기본적인 특성 HP, 이동하기를 interface로 기능만 명시하고 각각 분업하여 유닛에 대한 HP나 이동속도를 구현할 수 있습니다.\n하지만 일반적인 Spring 웹프로젝트에서는 Service interface는 1:1 구조인 경우가 많습니다. 만약 확장성을 고려한 1:N의 경우에는 interface로 가는 것이 좋지만 너무 막연한 경우에는 그냥 class로 생성 후 추후 시나리오 변경 또는 로직상 확장성이 필요한 경우 interface로 변경하는 것이 좋다고 생각합니다.","title":"[Spring] Service와 ServiceImpl에 대해"},{"content":"SpringBoot에서 Spring Starter Project로 프로젝트를 처음 만든 후 dependency를 추가하고 싶은 경우 해당 프로젝트 우클릭 후 Spring목록의 Add Starters에서 추가하거나 maven repository링크에서 추가해 줘야 합니다.\nmaven repository 사이트에서 하나하나 찾아서 넣기 번거로운 경우 쉽게 추가할 수 있습니다.\n아마도 인텔리j의 ultimate의 경우에도 위와 비슷한 방법으로 dependency를 추가할 수 있을 것이라 생각되네요.\n","permalink":"https://haservi.github.io/posts/spring/springboot-add-dependency/","summary":"SpringBoot에서 Spring Starter Project로 프로젝트를 처음 만든 후 dependency를 추가하고 싶은 경우 해당 프로젝트 우클릭 후 Spring목록의 Add Starters에서 추가하거나 maven repository링크에서 추가해 줘야 합니다.\nmaven repository 사이트에서 하나하나 찾아서 넣기 번거로운 경우 쉽게 추가할 수 있습니다.\n아마도 인텔리j의 ultimate의 경우에도 위와 비슷한 방법으로 dependency를 추가할 수 있을 것이라 생각되네요.","title":"springtoolsuite4에서 dependency 추가 방법"},{"content":"기본적으로 웹상에서는 Git 저장소 안의 폴더를 다운받으려면 해당 저장소 전부를 다운 받은 후에 특정 폴더의 정보를 봐야 합니다.\n간단한 방법은 아래의 링크에서 다운로드 받는게 제일 쉬운방법이지만 터미널에서 다운로드 방법도 한번 다루어보겠습니다. 터미널로 다운 받은 경우 이후 해당 소스가 변경이 있다면 당겨올 수 있는 이점도 있습니다.\n해결방법 웹 다운로드 https://downgit.github.io/#/home 해당 사이트에 github 저장소 특정 폴더의 링크를 복사 한 후 붙여넣고 Download 버튼 클릭\n터미널 다운로드 기본적으로 git이 설치돼 있어야합니다.\n예제로 https://github.com/android/architecture-components-samples/tree/main/NavigationAdvancedSample 해당 저장소를 다운받는다고 가정하겠습니다.\n  폴더 생성 후 이동\nmkdir sample-code1 cd sample-code1   git 초기화\ngit init   git checkout 설정 변경\ngit config core.sparseCheckout true   원하는 git 저장소 추가\ngit remote add -f origin https://github.com/android/architecture-components-samples.git   원하는 특정 폴더 저장소 선택(window)\necho NavigationAdvancedSample/* \u0026gt; .git/info/sparse-checkout   원하는 특정 폴더 저장소 선택(ubuntu)\necho \u0026#34;NavigationAdvancedSample/*\u0026#34; \u0026gt; .git/info/sparse-checkout   git 당기기(특정 브렌치 정보)\ngit pull origin main   사소한 이슈이지만 Windows에서는 경로를 인용해서는 안된다고 하네요. 그렇기 때문에 \u0026ldquo;\u0026ldquo;을 붙이면 안됩니다(참고)\n","permalink":"https://haservi.github.io/posts/tips/git-inner-folder-download/","summary":"기본적으로 웹상에서는 Git 저장소 안의 폴더를 다운받으려면 해당 저장소 전부를 다운 받은 후에 특정 폴더의 정보를 봐야 합니다.\n간단한 방법은 아래의 링크에서 다운로드 받는게 제일 쉬운방법이지만 터미널에서 다운로드 방법도 한번 다루어보겠습니다. 터미널로 다운 받은 경우 이후 해당 소스가 변경이 있다면 당겨올 수 있는 이점도 있습니다.\n해결방법 웹 다운로드 https://downgit.github.io/#/home 해당 사이트에 github 저장소 특정 폴더의 링크를 복사 한 후 붙여넣고 Download 버튼 클릭\n터미널 다운로드 기본적으로 git이 설치돼 있어야합니다.\n예제로 https://github.","title":"Github 저장소 안의 폴더 다운로드 받는 방법"},{"content":"작업의 효율을 높이기 위해 기존 화면에서 필요한 정보를 잠시 동안 캡쳐하는 방법이 있습니다.\n캡쳐프로그램은 정말 다양하게 존재하는데요. 예를 들어 알캡쳐, picpic, 윈도우 기본 내장 캡쳐, pureRef, snipaste 등 많이 있습니다.\n저 같은 경우 포스팅 할 때 화면캡쳐 용도로는 picpick을 자주 이용하며, 업무 중 필요한 정보를 캡쳐 할 때는 snipaste를 사용합니다.\npicpick의 경우는 워낙 잘 알려져 있기 때문에 snipaste에 대해 알아보겠습니다.\nSnipaste (download link) Snipaste는 특정 화면을 지정하여 캡쳐하여 화면에 띄워놓을 수 있습니다.\nWindows는 지원하고 있으며, Mac의 경우 Beta테스트를 하는 것 같네요.\n기본적인 기능으로는 특정 화면 캡쳐, 캡쳐 화면 Color Picker, 캡쳐 화면 확대 축소, 캡쳐 화면 투명도 조절, 캡쳐 화면 저장, 캡쳐 화면 Annotation 지정 등이 있습니다.\n기본 버전으로도 충분히 이용할 수 있지만, pro버전 도 지원을 하는 것 같습니다.\n설치 방법 해당 사이트에서 다운로드 후 설치하시면 됩니다.\n사용방법 기본적인 사용방법은 설치 후 F1로 화면 선택 또는 영역 지정 후 화면에서 더블 클릭 후 F3을 눌러 출력하면 됩니다.\n단축키를 변경 할 수도 있으며, 위를 이용하면 다양한 용도로 사용 할 수 있을 것이라 생각됩니다.\n제 경우 자주 사용하는 용도로는 변수 참조용 또는 퍼블리싱 디자인 또는 유용한 디자인을 참조할 때 자주 쓰는 것 같습니다.\n이외에도 잘 활용하면 여러모로 쾌적한 이용할 수 있습니다. 그 중 자주 사용하는 기본 단축키입니다.\n 화면 캡쳐: F1 후 영역 더블클릭 또는 클릭 후 드레그 하여 화면 지정 후 더블클릭 화면 불러오기: F1 저장 후 F3 캡쳐 화면 이동: F3으로 불러오 화면에서 마우스 좌클릭 후 이동 캡쳐 화면 이동: F3으로 불러오 화면에서 마우스 휠 조정 캡쳐 화면 색상 확인: F3으로 불러온 화면에서 Alt키를 누른 후 원하는 색상에서 C버튼 클릭(복사됨) 캡쳐 화면 투명도 조절: F3으로 불러온 화면에서 Ctrl키를 누른 후 마우스 휠 조정 캡쳐 화면 주석 추가: F3으로 불러온 화면에서 Annotation 선택 후 그림도구 사용  ","permalink":"https://haservi.github.io/posts/tools/how-to-capture/","summary":"작업의 효율을 높이기 위해 기존 화면에서 필요한 정보를 잠시 동안 캡쳐하는 방법이 있습니다.\n캡쳐프로그램은 정말 다양하게 존재하는데요. 예를 들어 알캡쳐, picpic, 윈도우 기본 내장 캡쳐, pureRef, snipaste 등 많이 있습니다.\n저 같은 경우 포스팅 할 때 화면캡쳐 용도로는 picpick을 자주 이용하며, 업무 중 필요한 정보를 캡쳐 할 때는 snipaste를 사용합니다.\npicpick의 경우는 워낙 잘 알려져 있기 때문에 snipaste에 대해 알아보겠습니다.\nSnipaste (download link) Snipaste는 특정 화면을 지정하여 캡쳐하여 화면에 띄워놓을 수 있습니다.","title":"화면 캡쳐 프로그램 추천"},{"content":"Windows WSL Ubuntu 커스텀 하기 Window에서는 WSL(Windows Subsystem for Linux)를 제공합니다.\n예전엔 가상환경(VM)에 리눅스를 올렸다면 지금은 손쉽게 리눅스 커널을 WSL로 접근할 수 있게 됐습니다.\n그렇기 때문에 웹개발을 한다면 Window에서 개발하여 WSL에 배포 테스트를 손쉽게? 할 수 있는 환경을 구축 할 수 있습니다. 예를 들어 웹의 경우 Backend, Frontend, DB 같은 환경을 Docker로 설정하여 WSL에 올린 뒤 바로 배포가 성공했다면 이러한 설정을 그대로 AWS나 Azure에 적용할 수 있습니다.\n해당 글은 단지 커스텀에 대한 이야기이지만 추후 위와 같은 방법으로 배포테스트도 한 번 다뤄볼 생각입니다.\n먼저 이 글대로 설정을 마칠 경우 아래와 같은 터미널을 얻을 수 있습니다. 😮\n설치 방법 1. Ubuntu 설치 Window Store에서 Ubuntu를 설치합니다. 2. zsh 설치  먼저 ubuntu 업데이트를 진행합니다.  sudo apt-get install sudo apt-get update zsh를 기본 셸로 설정합니다.  sudo chsh -s $(which zsh) 실행 시 zsh를 실행되도록 지정합니다.  sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 3. Meslo Nerd Font 설치   해당 폰트를 사용하지 않으면 powerlevel10k 테마의 아이콘이 표시되지 않습니다.\n아래 링크를 통해 MesloLGS NF 폰트를 다운로드 받아주세요.\nromkatv/powerlevel10k   다운받은 폰트를 Ubuntu에서 폰트를 변경합니다. 상단에서 마우스 우클릭 후 속성을 누른 뒤 폰트를 변경 할 수 있습니다.   4. powerlever10k 설치  zsh를 설치하면 oh-my-zsh라는 폴더가 생깁니다. 해당 폴더에 아래의 테마를 설치합니다.  git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 설치 후 편집기를 이용하여 테마를 변경합니다.  vim ~/.zshrc 기존 테마인 ZSH_THEME=\u0026ldquo;robbyrussell\u0026quot;를 ZSH_THEME=\u0026ldquo;powerlevel10k/powerlevel10k\u0026rdquo; 로 변경합니다.(i를 누르면 편집이 가능하며, 수정이 완료된 뒤 ESC를 누르고 :wq 입력)  ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34;  적용을 하셨다면 해당 창을 종료 후 다시 시작하면 아래와 같이 나오게 됩니다.\n(만약 나오지 않은 경우 명령어 source ~/.zshrc 입력)   여기서 본인의 스타일에 맞게 ()안의 답을 선택하면 됩니다. 만약 설정을 잘못하셨거나 바꾸고 싶다면 아래의 커맨드를 입력하시면 됩니다.\n  p10k configure 5. 폴더 아이콘 테마 변경  해당 테마를 변경하기 위해서는 ruby를 설치하여 colorls를 설치해야 합니다.  sudo apt-get install ruby-full colorls를 설치합니다.(만약 아래의 명령어가 안되거나 우분투 20.04 이상 버전인 경우는 sudo apt install gcc make 커맨드 입력 후 다시 설치하시면 됩니다.)  sudo gem install colorls 설치가 완료됐으면 ~/.zshrc 가장 하단에 아래 코드를 추가합니다.  source $(dirname $(gem which colorls))/tab_complete.sh alias ls=colorls 6. fzf 설치 fzf는 zsh의 확장팩? 같은 느낌입니다. 일단 속도가 매우 빠릅니다.(golang??)\n터미널에서 파일검색, 명령 기록, 프로세스, 호스트 이름, 책갈피 등 다양한 기능이 있습니다.\n몇가지 자주쓰는 명령어로\n ctrl + r 커맨드에서 사용한 명령어 history 리스트 출력 ctrl + t 해당 폴더의 디렉토리 또는 파일 검색 vim $(fzf) 해당 폴더 안의 검색된 파일 열기 cd 스페이스 ctrl + t 검색 후 폴더 이동  이것 외에도 fzf내에서 플러그인을 설치하여 탐색기처럼 이용할 수도 있고, 프로세스 kill 등 다양한 방법이 있는데 저도 아직 제대로 활용은 못하는 것 같습니다\u0026hellip;\n이와 관련된 링크로 대체하겠습니다. 😓\n윈도우 터미널 테마 변경 WSL를 설치하면 store에 있는 윈도우 터미널도 WSL을 선택할 수 있습니다. 이와 관련하여 테마를 설정할 수 있습니다.\n1. 터미널 색상 변경 기본적으로 터미널의 색을 바꾸고 싶다면 위와 같이 설정에 들어가서 json 파일 선택 후 defaults 제이슨 값에\n\u0026#34;defaults\u0026#34;: { // color theme \u0026#34;colorScheme\u0026#34;: \u0026#34;Campbell\u0026#34; }, 해당 테마이름을 지정하고, profiles제이슨 항목 안에\n\u0026#34;schemes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Campbell\u0026#34;, \u0026#34;cursorColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;selectionBackground\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#0C0C0C\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#CCCCCC\u0026#34;, \u0026#34;black\u0026#34;: \u0026#34;#0C0C0C\u0026#34;, \u0026#34;blue\u0026#34;: \u0026#34;#4b6ed6\u0026#34;, \u0026#34;cyan\u0026#34;: \u0026#34;#3A96DD\u0026#34;, \u0026#34;green\u0026#34;: \u0026#34;#C50F1F\u0026#34;, \u0026#34;purple\u0026#34;: \u0026#34;#881798\u0026#34;, \u0026#34;red\u0026#34;: \u0026#34;#C50F1F\u0026#34;, \u0026#34;white\u0026#34;: \u0026#34;#CCCCCC\u0026#34;, \u0026#34;yellow\u0026#34;: \u0026#34;#C19C00\u0026#34;, \u0026#34;brightBlack\u0026#34;: \u0026#34;#767676\u0026#34;, \u0026#34;brightBlue\u0026#34;: \u0026#34;#3B78FF\u0026#34;, \u0026#34;brightCyan\u0026#34;: \u0026#34;#61D6D6\u0026#34;, \u0026#34;brightGreen\u0026#34;: \u0026#34;#16C60C\u0026#34;, \u0026#34;brightPurple\u0026#34;: \u0026#34;#B4009E\u0026#34;, \u0026#34;brightRed\u0026#34;: \u0026#34;#E74856\u0026#34;, \u0026#34;brightWhite\u0026#34;: \u0026#34;#F2F2F2\u0026#34;, \u0026#34;brightYellow\u0026#34;: \u0026#34;#F9F1A5\u0026#34; } ], 이렇게 지정해주면 됩니다. 공식 사이트(링크) 에서도 참조하면 좋을 것 같습니다.\n위와 같은 방법으로 다른 테마를 적용하고 싶다면, https://windowsterminalthemes.dev/ 에서 원하는 테마를 복사하셔도 됩니다.\n2. 터미널 배경 변경 터미널 배경을 변경하고 싶으면 아래와 같이 설정해주시면 됩니다.\n\u0026#34;defaults\u0026#34;: { \u0026#34;acrylicOpacity\u0026#34; : 0.4, \u0026#34;backgroundImage\u0026#34;: \u0026#34;D:/ProgramFiles/Images/cool-wallpaper-preview-1.jpg\u0026#34;, \u0026#34;backgroundImageOpacity\u0026#34;: 0.4 }, 3. 글꼴 변경 해당 글꼴을 넣어줘야 powerlink10k에서 아이콘을 볼 수 있습니다.\n\u0026#34;defaults\u0026#34;: { \u0026#34;fontFace\u0026#34; : \u0026#34;MesloLGS NF\u0026#34;, \u0026#34;fontSize\u0026#34; : 13 }, 탐색기에 WSL 연결하기  탐색기 주소창에 아래의 주소값을 입력합니다.  \\\\wsl$ Unbutu 폴더에서 우측마우스 클릭 후 네트워크 드라이브 연결을 선택한다. 연결 후 원하는 이름으로 변경하면 탐색기에서 WSL에 접근이 가능합니다.   에러 관련  아래와 같은 에러가 발생하면  bash: ll: command not found 이렇게 명령어를 입력하면 해결됩니다.  echo \u0026#34;alias ll=\u0026#39;ls -lGaf\u0026#39;\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile 이상으로 윈도우에서 WSL 우분투 터미널 꾸미는 방법에 대해 알아보았습니다.\nReference  Setting up Windows Terminal, WSL and Oh-my-Zsh - Ivo\u0026rsquo;s Blog! https://snowdeer.github.io/mac-os/2018/11/04/how-to-use-fzf/ fzf Github WSL 동작 원리 FZF 터미널 사용 방법  ","permalink":"https://haservi.github.io/posts/linux/used-zsh-powerline10/","summary":"Windows WSL Ubuntu 커스텀 하기 Window에서는 WSL(Windows Subsystem for Linux)를 제공합니다.\n예전엔 가상환경(VM)에 리눅스를 올렸다면 지금은 손쉽게 리눅스 커널을 WSL로 접근할 수 있게 됐습니다.\n그렇기 때문에 웹개발을 한다면 Window에서 개발하여 WSL에 배포 테스트를 손쉽게? 할 수 있는 환경을 구축 할 수 있습니다. 예를 들어 웹의 경우 Backend, Frontend, DB 같은 환경을 Docker로 설정하여 WSL에 올린 뒤 바로 배포가 성공했다면 이러한 설정을 그대로 AWS나 Azure에 적용할 수 있습니다.\n해당 글은 단지 커스텀에 대한 이야기이지만 추후 위와 같은 방법으로 배포테스트도 한 번 다뤄볼 생각입니다.","title":"윈도우 WSL2 Ubuntu 터미널 꾸미기"},{"content":"ddl-auto 란 JPA에서는 기본적으로 Entity에 테이블을 매핑하면 쿼리를 사용하지 않고 값을 가져올 수 있습니다.\n설정 옵션으로\njpa: hibernate: ddl-auto: create #create-drop, update, validate, none 각각의 옵션을 봐보면 아래와 같습니다.\n create : SessionFactory 시작시 스키마를 삭제하고 다시 생성 create-drop : SessionFactory 종료 시 스키마를 삭제 update : SessionFactory 연결된 DB와 비교하여 추가된 항목은 추가 만약 같은 변수명이면 오류발생 validate : SessionFactory 시작시 객체구성과 스키마가 다르다면 예외 발생 none: 아무것도 안함  실제 서비스 배포시에는 create, create-drop, update 와 같은 옵션을 사용하면 안되지만 개발 초기 테스트시에는 유용하게 사용할 수 있습니다.\n샘플데이터 추가 방법 그렇지만 데이터 테이블만 생기고 데이터가 없으니 오히려 테스트하기 불편한 점이 있습니다.\n그렇기에 찾아보니 역시 당연하게도.. resources 폴더에 import.sql 파일을 추가하면 hibernate에서 알아서 해당 더미데이터 쿼리를 찾아 실해시켜줍니다.\n만약 특정 파일을 지정하고 싶다면 아래와 같이\njpa: properties: hibernate: hbm2ddl: import_files: classpath:db/data.sql # DB 파일 명시적으로 선택 import_files_sql_extractor: org.hibernate.tool.hbm2ddl.MultipleLinesSqlCommandExtractor # 멀티 라인 입력 가능하도록 connection: charSet: UTF-8 # 인코딩 설정 파일명을 명시주면 create에 자동으로 해당 데이터를 insert 할 수 있습니다.\n예제 만약 아래와 같이 user 테이블이 있다면..\nimport java.time.LocalDateTime; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; import lombok.AccessLevel; import lombok.Builder; import lombok.Getter; import lombok.NoArgsConstructor; import org.hibernate.annotations.ColumnDefault; import org.hibernate.annotations.DynamicUpdate; @NoArgsConstructor(access = AccessLevel.PROTECTED) @Getter @Entity @DynamicUpdate @Table(name = \u0026#34;user\u0026#34;) public class UserEntity { @Id @GeneratedValue(strategy= GenerationType.IDENTITY) @Column(nullable = false, updatable = false) private Long userSno; @Column(length = 20, nullable = false, unique = true) private String userId; @Column(length = 20) private String userName; @Column(length = 20, nullable = false) private String password; @Column(length = 30) private String email; @Column(nullable = false, updatable = false, insertable = false, columnDefinition = \u0026#34;TIMESTAMP DEFAULT CURRENT_TIMESTAMP\u0026#34;) private LocalDateTime createDt; @Column(nullable = false, updatable = false, insertable = false) @ColumnDefault(\u0026#34;0\u0026#34;) private int useYn; @Builder public UserEntity(Long userSno, String userId, String userName, String password, String email) { this.userSno = userSno; this.userId = userId; this.userName = userName; this.password = password; this.email = email; } } import.sql파일 또는 지정한 sql파일에 아래와 같이 코드를 추가해주면 빌드 시 자동적으로 데이터를 넣을 수 있습니다.\ninsertinto`user`(`email`,`password`,`user_id`,`user_name`)values(\u0026#39;admin@admin.com\u0026#39;,\u0026#39;$2a$10$dyiw3YfbmBkHlUdbgWhsYesqniOsXo71KBzF75le5.YtS/rsrsM22\u0026#39;,\u0026#39;admin\u0026#39;,\u0026#39;관리자\u0026#39;);insertinto`user`(`email`,`password`,`user_id`,`user_name`)values(\u0026#39;test@test.com\u0026#39;,\u0026#39;$2a$10$PMc5QFOUViVsGmsNMQqUzOuQG2rZ2wUJjSTRGFkBo9jZR/CSnQ03K\u0026#39;,\u0026#39;test\u0026#39;,\u0026#39;테스트\u0026#39;);주의할 점은 실제 배포시에는 꼭 ddl-auto를 none으로 해야 합니다.\nddl-auto의 경우 초기 DB 설정 및 간단한 테스트에서만 쓰는게 좋습니다.\n","permalink":"https://haservi.github.io/posts/spring/hibernate-ddl-auto/","summary":"ddl-auto 란 JPA에서는 기본적으로 Entity에 테이블을 매핑하면 쿼리를 사용하지 않고 값을 가져올 수 있습니다.\n설정 옵션으로\njpa: hibernate: ddl-auto: create #create-drop, update, validate, none 각각의 옵션을 봐보면 아래와 같습니다.\n create : SessionFactory 시작시 스키마를 삭제하고 다시 생성 create-drop : SessionFactory 종료 시 스키마를 삭제 update : SessionFactory 연결된 DB와 비교하여 추가된 항목은 추가 만약 같은 변수명이면 오류발생 validate : SessionFactory 시작시 객체구성과 스키마가 다르다면 예외 발생 none: 아무것도 안함  실제 서비스 배포시에는 create, create-drop, update 와 같은 옵션을 사용하면 안되지만 개발 초기 테스트시에는 유용하게 사용할 수 있습니다.","title":"JPA ddl-auto 설정과 더미데이터 생성 방법"},{"content":"간단하게 무거운 프로그램을 이용하지 않고 영상을 gif로 만드는 방법입니다.\n 윈도우 - https://www.screentogif.com/ Mac - https://apps.apple.com/us/app/giphy-capture-the-gif-maker/id668208984?mt=12  위 프로그램을 다운로드 받아서 설치하면 됩니다.\n설치 방법(Window)  https://www.screentogif.com/ 사이트에 접속하셔서 다운로드 합니다. 다운로드 후 설치 합니다. 설치가 완료되면 실행합니다.\n 위와 같은 화면에서 선택 영역을 지정(예시: 메모장)하고 녹화를 누르면 아래와 같이 나타납니다.\n 여기서 그냥 녹화를 누른뒤 진행하면 됩니다. 녹화를 마치고 정지를 누르시면 아래와 같은 화면이 나타납니다.\n 저 같은 경우 초당 30프레임으로 설정하여서 5초짜리 영상에 대략 150프레임의 스크린샷이 찍혔습니다. 많약 더 부드럽게 만드시고 싶다면 프레임을 올리면 됩니다. 그리고 각각의 프레임들은 모두 제거가 가능하기 때문에 쓸모없는 동작들의 프레임을 제거 할 수 있습니다. 편집 작업이 끝나고 상단의 파일의 저장 버튼을 누르시면 됩니다.\n 최종적으로 아래와 같이 애니메이션 화면을 볼 수 있습니다.\n  해당 프로그램을 이용하여 처음 구동화면이나 미리 결과물을 보여주면 직관적으로 결과물을 볼 수 있습니다.\n","permalink":"https://haservi.github.io/posts/tools/how-to-create-gif/","summary":"간단하게 무거운 프로그램을 이용하지 않고 영상을 gif로 만드는 방법입니다.\n 윈도우 - https://www.screentogif.com/ Mac - https://apps.apple.com/us/app/giphy-capture-the-gif-maker/id668208984?mt=12  위 프로그램을 다운로드 받아서 설치하면 됩니다.\n설치 방법(Window)  https://www.screentogif.com/ 사이트에 접속하셔서 다운로드 합니다. 다운로드 후 설치 합니다. 설치가 완료되면 실행합니다.\n 위와 같은 화면에서 선택 영역을 지정(예시: 메모장)하고 녹화를 누르면 아래와 같이 나타납니다.\n 여기서 그냥 녹화를 누른뒤 진행하면 됩니다. 녹화를 마치고 정지를 누르시면 아래와 같은 화면이 나타납니다.\n 저 같은 경우 초당 30프레임으로 설정하여서 5초짜리 영상에 대략 150프레임의 스크린샷이 찍혔습니다.","title":"영상을 gif로 만드는 방법"},{"content":"조이스틱 문제 설명 조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.\nex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA\n조이스틱을 각 방향으로 움직이면 아래와 같습니다.\n▲ - 다음 알파벳 ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로) ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서) ▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 \u0026ldquo;JAZ\u0026quot;를 만들 수 있습니다.\n- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다. - 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다. - 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다. 따라서 11번 이동시켜 \u0026quot;JAZ\u0026quot;를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.\n제한 사항  name은 알파벳 대문자로만 이루어져 있습니다. name의 길이는 1 이상 20 이하입니다.  입출력 예    name return     \u0026ldquo;JEROEN\u0026rdquo; 56   \u0026ldquo;JAN\u0026rdquo; 23    출처 ※ 공지 - 2019년 2월 28일 테스트케이스가 추가되었습니다.\n문제 풀이 리뷰 몇일을 고민한 문제이다. 알파벳 위아래의 최소값은 간단히 구하였지만, 좌우의 최소거리를 찾는 부분에서 생각을 많이하였다.\n기본적으로 모든 알파벳 위치에서의 최소거리를 구하고, 바로앞의 A가 있다면 해당 값을 제외한 뒤에 거리를 정의해야한다.\n또한, 해당 인덱스의 위치에서 정방향과 역방향에서 둘 중의 거리가 짧은 곳을 구한 뒤 바로앞의 A를 제외한 총이동거리를 더하는 부분이 중요하다.\n그렇게 모든 알파벳의 좌우 이동 최소거리 중 가장작은 값을 상하 알파벳 이동값과 더하여 주면된다.\nSource code public int solution(String name) { int answer = 0; int nameLength = name.length(); int changeAlpabatCount = 0; for (int i = 0; i \u0026lt; nameLength; i++) { // 알파벳 변경 시 최소값 선정 후 화살표 위아래 변경 횟수 추가  changeAlpabatCount += Math.min(name.charAt(i) - \u0026#39;A\u0026#39;, \u0026#39;Z\u0026#39; - name.charAt(i) + 1); } // 알파벳의 정방향 최대 이동거리를 최소거리로 지정  int minMove = nameLength - 1; for (int i = 0; i \u0026lt; nameLength; i++) { int next = i + 1; int nextCountA = 0; while (next \u0026lt; nameLength \u0026amp;\u0026amp; name.charAt(next) == \u0026#39;A\u0026#39;) { next++; nextCountA++; } // 0번쨰 인덱스에서 앞의 A를 제외하고 이동한 거리  int moveWithoutA = name.length() - nextCountA - 1; // System.out.println(\u0026#34;movewithA:\u0026#34; + moveWithoutA);  // 처음부터 i번째 까지 왔다가 돌아가는 방식과 뒤에서 출발하여 i번째 까지 오는 방식중 작은 값 선택  int min = Math.min(i, name.length() - next); // 알파벳을 순회하며 작은 값을 선택  minMove = Math.min(minMove, moveWithoutA + min); // System.out.println(i + \u0026#34;번째값의 평균 이동 거리는 \u0026#34; + (moveWithoutA + min) + \u0026#34;이다.\u0026#34;);  } // System.out.println(\u0026#34;총 알파벳 변경 회수는 \u0026#34; + changeAlpabatCount + \u0026#34;이며, 최소이동 거리는 \u0026#34; + minMove + \u0026#34;이다.\u0026#34;);  answer = (changeAlpabatCount + minMove); return answer; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level2/03-joystick/","summary":"조이스틱 문제 설명 조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.\nex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA\n조이스틱을 각 방향으로 움직이면 아래와 같습니다.\n▲ - 다음 알파벳 ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로) ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서) ▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 \u0026ldquo;JAZ\u0026quot;를 만들 수 있습니다.\n- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.","title":"[프로그래머스]조이스틱"},{"content":"다리를 지나는 트럭 문제 설명 트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다.\n모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다.\n다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다.\n단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다.\n예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.\n   경과 시간 다리를 지난 트럭 다리를 건너는 트럭 대기 트럭     0 [] [] [7,4,5,6]   1~2 [] [7] [4,5,6]   3 [7] [4] [5,6]   4 [7] [4,5] [6]   5 [7,4] [5] [6]   6~7 [7,4,5] [6] []   8 [7,4,5,6] [] []    따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다.\nsolution 함수의 매개변수로 다리에 올라갈 수 있는 트럭 수 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭 별 무게 truck_weights가 주어집니다.\n이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요.\n제한 조건  bridge_length는 1 이상 10,000 이하입니다. weight는 1 이상 10,000 이하입니다. truck_weights의 길이는 1 이상 10,000 이하입니다. 모든 트럭의 무게는 1 이상 weight 이하입니다.  입출력 예    bridge_length weight truck_weights return     2 10 [7,4,5,6] 8   100 100 [10] 101   100 100 [10,10,10,10,10,10,10,10,10,10] 110    문제 풀이 리뷰  Java Source Code   트럭이 모두 다리를 건너가야 하기 때문에 트럭의 횟수만큼 순회한다. 다리를 지날 때는 트럭큐를 이용하며, 시간을 계속 추가한다. 마지막 트럭의 경우 지나갈 때 다리의 길이만큼 시간을 소모하기 때문에 처음에 다리의 길이만큼 값을 더해주었다.  ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level2/02-truck-crossing-the-bridge/","summary":"다리를 지나는 트럭 문제 설명 트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다.\n모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다.\n다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다.\n단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다.\n예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.","title":"[프로그래머스]다리를 지나는 트럭"},{"content":"위장 문제 설명 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.\n예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.\n   종류 이름     얼굴 동그란 안경, 검정 선글라스   상의 파란색 티셔츠   하의 청바지   겉옷 긴 코트    스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.\n제한사항  clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 \u0026lsquo;_\u0026rsquo; 로만 이루어져 있습니다. 스파이는 하루에 최소 한 개의 의상은 입습니다.  입출력 예    clothes return     [[\u0026ldquo;yellowhat\u0026rdquo;, \u0026ldquo;headgear\u0026rdquo;], [\u0026ldquo;bluesunglasses\u0026rdquo;, \u0026ldquo;eyewear\u0026rdquo;], [\u0026ldquo;green_turban\u0026rdquo;, \u0026ldquo;headgear\u0026rdquo;]] 5   [[\u0026ldquo;crowmask\u0026rdquo;, \u0026ldquo;face\u0026rdquo;], [\u0026ldquo;bluesunglasses\u0026rdquo;, \u0026ldquo;face\u0026rdquo;], [\u0026ldquo;smoky_makeup\u0026rdquo;, \u0026ldquo;face\u0026rdquo;]] 3    입출력 예 설명 예제 #1\nheadgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다.\n1. yellow_hat 2. blue_sunglasses 3. green_turban 4. yellow_hat + blue_sunglasses 5. green_turban + blue_sunglasses 예제 #2 face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다.\n1. crow_mask 2. blue_sunglasses 3. smoky_makeup 문제 풀이 문제 풀이 리뷰  확률 문제이다. 예를 들어 정육각형 주사위A 주사위B 2개로 나오는 경우의 수는 6 * 6으로 36개이다. 그렇지만 주사위 객체 1개도 경우의 수로 인정하게 되면 (7 x 7) - 1로 48개 이다. 여기서 -1은 주사위가 없는 경우라고 생각할 수 있다. 해당 문제도 같은 방식으로 이해하면 각 옷들은 주사위이고 옷의 개수는 주사위의 번호 개수이다. 예를 들어 옷의 종류가 3개이며, 각각 2벌씩이면 ((2 + 1) * (2 + 1) * (2 + 1)) - 1 = 26 이다. 해당 문제의 풀이 방법은 어느 정도 알았지만, hashMap의 확장함수로 getOrDefault가 있다는 것을 알게됐다. getOrDefault의 두 번째 매개변수인 defaultValue는 지정된 키로 매핑된 값이 없으면 반환되는 값이다.  Source code Java (Source code) public int solution(String[][] clothes) { int answer = 1; int clothCount = clothes.length; HashMap\u0026lt;String, Integer\u0026gt; hashMap = new HashMap\u0026lt;String, Integer\u0026gt;(); for (int i = 0; i \u0026lt; clothCount; i++) { int clothSum = hashMap.getOrDefault(clothes[i][1], 0) + 1; hashMap.put(clothes[i][1], clothSum); } for (int count : hashMap.values()) { answer = answer * (count + 1); } answer = answer - 1; return answer; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level2/01-camouflage/","summary":"위장 문제 설명 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.\n예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.\n   종류 이름     얼굴 동그란 안경, 검정 선글라스   상의 파란색 티셔츠   하의 청바지   겉옷 긴 코트    스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.","title":"[프로그래머스]위장"},{"content":"하샤드 수 문제 설명 양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다.\n예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다.\n자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.\n제한 조건  x는 1 이상, 10000 이하인 정수입니다.  입출력 예    arr return     10 true   12 true   11 false   13 false    입출력 예 설명 입출력 예 #1\n10의 모든 자릿수의 합은 1입니다. 10은 1로 나누어 떨어지므로 10은 하샤드 수입니다.\n입출력 예 #2\n12의 모든 자릿수의 합은 3입니다. 12는 3으로 나누어 떨어지므로 12는 하샤드 수입니다.\n입출력 예 #3\n11의 모든 자릿수의 합은 2입니다. 11은 2로 나누어 떨어지지 않으므로 11는 하샤드 수가 아닙니다.\n입출력 예 #4\n13의 모든 자릿수의 합은 4입니다. 13은 4로 나누어 떨어지지 않으므로 13은 하샤드 수가 아닙니다.\n문제 풀이 리뷰  [Java](https://github.com/haservi/study-algorithm/blob/main/programmers/Level1/lv1_47_%ED%95%98%EC%83%A4%EB%93%9C_%EC%88%98/Solution.java   각 자리수의 합을 구한 뒤 나머지가 0인 경우 true를 반환한다.  나의 풀이(Source code) public boolean solution(int x) { int sum = 0; int num = x; // 자릿수의 합  while (num != 0) { sum += num % 10; num /= 10; } // 나머지가 0이면 하샤드 수라고 판단  if (x % sum == 0) return true; else return false; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/04-algo-hasshadsu/","summary":"하샤드 수 문제 설명 양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다.\n예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다.\n자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.\n제한 조건  x는 1 이상, 10000 이하인 정수입니다.  입출력 예    arr return     10 true   12 true   11 false   13 false    입출력 예 설명 입출력 예 #1","title":"[프로그래머스]하샤드 수"},{"content":"콜라츠 추측 문제 설명 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.\n1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다. 2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다.\n위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요.\n단, 작업을 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요.\n제한 사항  입력된 수, num은 1 이상 8000000 미만인 정수입니다.  입출력 예    n result     6 8   16 4   626331 -1    입출력 예 설명 입출력 예 #1\n문제의 설명과 같습니다.\n입출력 예 #2\n16 -\u0026gt; 8 -\u0026gt; 4 -\u0026gt; 2 -\u0026gt; 1 이되어 총 4번만에 1이 됩니다.\n입출력 예 #3\n626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야합니다.\n문제 풀이 문제 풀이 리뷰  반복적으로 돌면서 짝수이면 2로 나누고 홀수이면 해당값에 3을 곱한 후 1을 더해준다. 해당 반복이 500회가 되면 -1을 리턴한다.  Java (Source code) public int solution(long num) { int answer = 0; while (num != 1) { if (num % 2 == 0) { num = num / 2; } else { num = (num * 3) + 1; } answer++; if (answer == 500) { return -1; } } return answer; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/03-algo-colatz-guess/","summary":"콜라츠 추측 문제 설명 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.\n1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다. 2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다.\n위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요.","title":"[프로그래머스]콜라츠 추측"},{"content":"직업군 추천하기 문제 설명 개발자가 사용하는 언어와 언어 선호도를 입력하면 그에 맞는 직업군을 추천해주는 알고리즘을 개발하려고 합니다.\n아래 표는 5개 직업군 별로 많이 사용하는 5개 언어에 직업군 언어 점수를 부여한 표입니다.\n   점수 SI CONTENTS HARDWARE PORTAL GAME     5 JAVA JAVASCRIPT C JAVA C++   4 JAVASCRIPT JAVA C++ JAVASCRIPT C#   3 SQL PYTHON PYTHON PYTHON JAVASCRIPT   2 PYTHON SQL JAVA KOTLIN C   1 C# C++ JAVASCRIPT PHP JAVA    예를 들면, SQL의 SI 직업군 언어 점수는 3점이지만 CONTENTS 직업군 언어 점수는 2점입니다.\nSQL의 HARDWARE, PORTAL, GAME 직업군 언어 점수는 0점입니다.\n직업군 언어 점수를 정리한 문자열 배열 table, 개발자가 사용하는 언어를 담은 문자열 배열 languages, 언어 선호도를 담은 정수 배열 preference가 매개변수로 주어집니다.\n개발자가 사용하는 언어의 언어 선호도 x 직업군 언어 점수의 총합이 가장 높은 직업군을 return 하도록 solution 함수를 완성해주세요.\n총합이 같은 직업군이 여러 개일 경우, 이름이 사전 순으로 가장 빠른 직업군을 return 해주세요.\n제한사항  table의 길이 = 5  table의 원소는 \u0026ldquo;직업군 5점언어 4점언어 3점언어 2점언어 1점언어\u0026quot;형식의 문자열입니다. 직업군, 5점언어, 4언어, 3점언어, 2점언어, 1점언어는 하나의 공백으로 구분되어 있습니다. table은 모든 테스트케이스에서 동일합니다.   1 ≤ languages의 길이 ≤ 9  languages의 원소는 \u0026ldquo;JAVA\u0026rdquo;, \u0026ldquo;JAVASCRIPT\u0026rdquo;, \u0026ldquo;C\u0026rdquo;, \u0026ldquo;C++\u0026rdquo; ,\u0026ldquo;C#\u0026rdquo; , \u0026ldquo;SQL\u0026rdquo;, \u0026ldquo;PYTHON\u0026rdquo;, \u0026ldquo;KOTLIN\u0026rdquo;, \u0026ldquo;PHP\u0026rdquo; 중 한 개 이상으로 이루어져 있습니다. languages의 원소는 중복되지 않습니다.   preference의 길이 = languages의 길이  1 ≤ preference의 원소 ≤ 10   preference의 i번째 원소는 languages의 i번째 원소의 언어 선호도입니다. return 할 문자열은 \u0026ldquo;SI\u0026rdquo;, \u0026ldquo;CONTENTS\u0026rdquo;, \u0026ldquo;HARDWARE\u0026rdquo;, \u0026ldquo;PORTAL\u0026rdquo;, \u0026ldquo;GAME\u0026rdquo; 중 하나입니다.  입출력 예    table languages preference result     [\u0026ldquo;SI JAVA JAVASCRIPT SQL PYTHON C#\u0026rdquo;, \u0026ldquo;CONTENTS JAVASCRIPT JAVA PYTHON SQL C++\u0026rdquo;, \u0026ldquo;HARDWARE C C++ PYTHON JAVA JAVASCRIPT\u0026rdquo;, \u0026ldquo;PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP\u0026rdquo;, \u0026ldquo;GAME C++ C# JAVASCRIPT C JAVA\u0026rdquo;] [\u0026ldquo;PYTHON\u0026rdquo;, \u0026ldquo;C++\u0026rdquo;, \u0026ldquo;SQL\u0026rdquo;] [7, 5, 5] \u0026ldquo;HARDWARE\u0026rdquo;   [\u0026ldquo;SI JAVA JAVASCRIPT SQL PYTHON C#\u0026rdquo;, \u0026ldquo;CONTENTS JAVASCRIPT JAVA PYTHON SQL C++\u0026rdquo;, \u0026ldquo;HARDWARE C C++ PYTHON JAVA JAVASCRIPT\u0026rdquo;, \u0026ldquo;PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP\u0026rdquo;, \u0026ldquo;GAME C++ C# JAVASCRIPT C JAVA\u0026rdquo;] [\u0026ldquo;JAVA\u0026rdquo;, \u0026ldquo;JAVASCRIPT\u0026rdquo;] [7, 5] \u0026ldquo;PORTAL\u0026rdquo;    입출력 예 설명 입출력 예 #1\n각 직업군 별로 점수를 계산해보면 아래와 같습니다.\n아래 사진은 개발자 언어 선호도 나타낸 표입니다.     Python C++ SQL     선호도 7 5 5    아래 사진은 개발자가 선호하는 언어의 직업군 언어 점수를 나타낸 표입니다.     SI CONTENTS HARDWARE PORTAL GAME     PYTHON 2 3 3 3 0   c++ 0 1 4 0 5   SQL 3 2 0 0 0   직업군별 점수 식 $72 + 50 + 5*3$ $73 + 51 + 5*2$ $73 + 54 + 5*0$ $73 + 50 + 5*0$ $70 + 55 + 5*0$   점수 총합 29 36 41 21 25    따라서 점수 총합이 41로 가장 높은 \u0026quot;HARDWARE\u0026quot;를 return 해야 합니다.\n입출력 예 #2 각 직업군 별로 점수를 계산해보면 아래와 같습니다.\n아래 사진은 개발자 언어 선호도 나타낸 표입니다.     JAVA JAVASCRIPT     선호도 7 5    아래 사진은 개발자가 선호하는 언어의 직업군 언어 점수를 나타낸 표입니다.     SI CONTENTS HARDWARE PORTAL GAME     JAVA 5 4 2 5 1   JAVASCRIPT 4 5 1 4 3   직업군별 점수 식 $75 + 54$ $74 + 55$ $72 + 51$ $75 + 54$ $71 + 53$   점수 총합 55 53 19 55 22    점수 총합이 55로 가장 높은 직업군은 \u0026ldquo;SI\u0026rdquo; 와 \u0026ldquo;PORTAL\u0026quot;입니다. 따라서 사전 순으로 먼저 오는 \u0026quot;PORTAL\u0026quot;을 return 해야 합니다.\n문제 풀이 리뷰  Java   TreeMap에 language 값에 맞는 table의 배열을 맞춘 후 preference 값을 더하였다. 이렇게 하면 자동적으로 언어 별 점수의 합이 정렬된다. 이 후 점수 가 큰 순서로 내림차순 한 뒤 첫번째 값을 리턴하였다.  import java.util.*; class Solution { public static void main(String[] args) { Solution solution = new Solution(); String[] table = { \u0026#34;BI JAVA JAVASCRIPT SQL PYTHON C#\u0026#34;, \u0026#34;AONTENTS JAVASCRIPT JAVA PYTHON SQL C++\u0026#34;, \u0026#34;HARDWARE C C++ PYTHON JAVA JAVASCRIPT\u0026#34;, \u0026#34;AORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP\u0026#34;, \u0026#34;GAME C++ C# JAVASCRIPT C JAVA\u0026#34; }; String[] languages = { \u0026#34;JAVA\u0026#34;, \u0026#34;JAVASCRIPT\u0026#34; }; int[] preference = { 7, 5 }; String result = solution.solution(table, languages, preference); System.out.println(\u0026#34;결과 : \u0026#34; + result); } public String solution(String[] table, String[] languages, int[] preference) { Map\u0026lt;String, Integer\u0026gt; jobResultMap = new TreeMap\u0026lt;String, Integer\u0026gt;(); // ValueComparator bvc = new ValueComparator(jobResultMap);  // TreeMap\u0026lt;String, Integer\u0026gt; sortedMap = new TreeMap\u0026lt;String, Integer\u0026gt;(bvc);  int tableCount = table.length; for (int i = 0; i \u0026lt; tableCount; i++) { String[] splitTable = table[i].split(\u0026#34; \u0026#34;); // 해당 점수별로 값 넣기  jobResultMap.put(splitTable[0], 0); for (int j = 1; j \u0026lt; splitTable.length; j++) { for (int k = 0; k \u0026lt; languages.length; k++) { if (splitTable[j].equals(languages[k])) { jobResultMap.put(splitTable[0], jobResultMap.get(splitTable[0]) + (splitTable.length - j) * preference[k]); } } } } List\u0026lt;String\u0026gt; listKeySet = new ArrayList\u0026lt;\u0026gt;(jobResultMap.keySet()); Collections.sort(listKeySet, (value1, value2) -\u0026gt; (jobResultMap.get(value2).compareTo(jobResultMap.get(value1)))); String answer = listKeySet.get(0); System.out.println(jobResultMap.toString()); System.out.println(listKeySet.toString()); return answer; } } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/02-algo-recommend-job/","summary":"직업군 추천하기 문제 설명 개발자가 사용하는 언어와 언어 선호도를 입력하면 그에 맞는 직업군을 추천해주는 알고리즘을 개발하려고 합니다.\n아래 표는 5개 직업군 별로 많이 사용하는 5개 언어에 직업군 언어 점수를 부여한 표입니다.\n   점수 SI CONTENTS HARDWARE PORTAL GAME     5 JAVA JAVASCRIPT C JAVA C++   4 JAVASCRIPT JAVA C++ JAVASCRIPT C#   3 SQL PYTHON PYTHON PYTHON JAVASCRIPT   2 PYTHON SQL JAVA KOTLIN C   1 C# C++ JAVASCRIPT PHP JAVA    예를 들면, SQL의 SI 직업군 언어 점수는 3점이지만 CONTENTS 직업군 언어 점수는 2점입니다.","title":"[프로그래머스]직업군 추천하기"},{"content":"비밀지도 문제 설명 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다.\n그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다.\n다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.\n 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 \u0026ldquo;공백\u0026rdquo;(\u0026quot; \u0026ldquo;) 또는 \u0026ldquo;벽\u0026rdquo;(\u0026quot;#\u0026quot;) 두 종류로 이루어져 있다. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;라고 하자.\n지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다.\n지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다. \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;는 각각 정수 배열로 암호화되어 있다. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.  네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.\n입력 형식 입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.\n 1 ≦ n ≦ 16 arr1, arr2는 길이 n인 정수 배열로 주어진다. 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.  출력 형식 원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라.\n입출력 예제    매개변수 값     n 5   arr1 [9, 20, 28, 18, 11]   arr2 [30, 1, 21, 17, 28]   출력 [\u0026quot;#####\u0026rdquo;,\u0026quot;# # #\u0026rdquo;, \u0026ldquo;### #\u0026rdquo;, \u0026ldquo;# ##\u0026rdquo;, \u0026ldquo;#####\u0026quot;]       매개변수 값     n 6   arr1 [46, 33, 33 ,22, 31, 50]   arr2 [27 ,56, 19, 14, 14, 10]   출력 [\u0026quot;######\u0026rdquo;, \u0026ldquo;### #\u0026rdquo;, \u0026ldquo;## ##\u0026rdquo;, \u0026quot; #### \u0026ldquo;, \u0026quot; #####\u0026rdquo;, \u0026ldquo;### # \u0026ldquo;]    문제 풀이 리뷰  각각의 미로의 길을 이진화 한다. 만약 이진수의 값의 앞 공백이 있는 경우 \u0026ldquo;0\u0026quot;을 추가해준다. 서로 비교하여 0인 경우는 \u0026quot; \u0026ldquo;, 그렇지 않은 경우 \u0026ldquo;#\u0026ldquo;을 추가해준다.  해결 코드 import java.util.*; class Solution { public static void main(String[] args) { Solution solution = new Solution(); int n = 5; int[] arr1 = { 9, 20, 28, 18, 11 }; int[] arr2 = { 30, 1, 21, 17, 28 }; String[] result = solution.solution(n, arr1, arr2); System.out.println(\u0026#34;결과 : \u0026#34; + Arrays.toString(result)); } public String[] solution(int n, int[] arr1, int[] arr2) { String[] answer = new String[n]; // 경로를 십진수를 이진수로 변경 및 이진수 앞 공백 추가  int count = n; for (int i = 0; i \u0026lt; count; i++) { String firstKeyMap = makeZero(Integer.toBinaryString(arr1[i]), count); String secondKeyMap = makeZero(Integer.toBinaryString(arr2[i]), count); String rowKey = \u0026#34;\u0026#34;; // System.out.println(firstKeyMap);  for (int j = 0; j \u0026lt; count; j++) { if ((firstKeyMap.charAt(j) == \u0026#39;0\u0026#39;) \u0026amp;\u0026amp; (secondKeyMap.charAt(j) == \u0026#39;0\u0026#39;)) { rowKey += \u0026#34; \u0026#34;; } else { rowKey += \u0026#34;#\u0026#34;; } } // System.out.println(rowKey);  answer[i] = rowKey; } return answer; } private String makeZero(String binaryString, int length) { int binaryLength = binaryString.length(); while (binaryLength != length) { binaryString = \u0026#34;0\u0026#34; + binaryString; binaryLength++; } return binaryString; } } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/01-algo-secret-map/","summary":"비밀지도 문제 설명 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다.\n그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다.\n다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.\n 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 \u0026ldquo;공백\u0026rdquo;(\u0026quot; \u0026ldquo;) 또는 \u0026ldquo;벽\u0026rdquo;(\u0026quot;#\u0026quot;) 두 종류로 이루어져 있다. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;라고 하자.\n지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다.","title":"[프로그래머스]비밀지도"},{"content":"","permalink":"https://haservi.github.io/projects/","summary":"projects","title":"Projects"}]