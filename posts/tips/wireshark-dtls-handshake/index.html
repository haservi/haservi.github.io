<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>와이어 샤크를 이용해 DTLS1.2 handshake 확인하기 | Halog</title><meta name=keywords content=","><meta name=description content="프로젝트 중 LwM2M과 Anjay의 통신이 간헐적으로 끊기는 현상이 발생하여 이와 관련하여 프로토콜의 개념에 대해 알아보고, 와이어샤크를 이용해 DTLS handshake를 확인한 내용입니다.
LwM2M에 대해 LwM2M (Lightweight M2M)은 경량화된 기기 간 통신 프로토콜로서, IoT (Internet of Things) 기기와 서버 간의 효율적인 통신을 위해 설계되었습니다.
LwM2M은 경량화된 프로토콜로, 리소스 제약이 있는 IoT 기기에서도 효율적으로 동작합니다. 작은 패킷 크기와 최소한의 대역폭을 사용하여 효율적인 통신을 제공합니다.
LwM2M은 RESTful 아키텍처를 기반으로 하며, HTTP/CoAP 프로토콜을 사용하여 기기와 서버 간 통신을 지원합니다."><meta name=author content><link rel=canonical href=https://haservi.github.io/posts/tips/wireshark-dtls-handshake/><meta name=google-site-verification content="G-MXZP81P04W"><link rel=stylesheet as=style crossorigin href=https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.6/dist/web/static/pretendard.css><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://haservi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://haservi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://haservi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://haservi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://haservi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1400973749140762" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-RP5NDCM8J9"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RP5NDCM8J9",{anonymize_ip:!1})}</script><meta property="og:title" content="와이어 샤크를 이용해 DTLS1.2 handshake 확인하기"><meta property="og:description" content="프로젝트 중 LwM2M과 Anjay의 통신이 간헐적으로 끊기는 현상이 발생하여 이와 관련하여 프로토콜의 개념에 대해 알아보고, 와이어샤크를 이용해 DTLS handshake를 확인한 내용입니다.
LwM2M에 대해 LwM2M (Lightweight M2M)은 경량화된 기기 간 통신 프로토콜로서, IoT (Internet of Things) 기기와 서버 간의 효율적인 통신을 위해 설계되었습니다.
LwM2M은 경량화된 프로토콜로, 리소스 제약이 있는 IoT 기기에서도 효율적으로 동작합니다. 작은 패킷 크기와 최소한의 대역폭을 사용하여 효율적인 통신을 제공합니다.
LwM2M은 RESTful 아키텍처를 기반으로 하며, HTTP/CoAP 프로토콜을 사용하여 기기와 서버 간 통신을 지원합니다."><meta property="og:type" content="article"><meta property="og:url" content="https://haservi.github.io/posts/tips/wireshark-dtls-handshake/"><meta property="og:image" content="https://haservi.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-11T19:26:03+09:00"><meta property="article:modified_time" content="2023-11-11T19:26:03+09:00"><meta property="og:site_name" content="Halog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://haservi.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="와이어 샤크를 이용해 DTLS1.2 handshake 확인하기"><meta name=twitter:description content="프로젝트 중 LwM2M과 Anjay의 통신이 간헐적으로 끊기는 현상이 발생하여 이와 관련하여 프로토콜의 개념에 대해 알아보고, 와이어샤크를 이용해 DTLS handshake를 확인한 내용입니다.
LwM2M에 대해 LwM2M (Lightweight M2M)은 경량화된 기기 간 통신 프로토콜로서, IoT (Internet of Things) 기기와 서버 간의 효율적인 통신을 위해 설계되었습니다.
LwM2M은 경량화된 프로토콜로, 리소스 제약이 있는 IoT 기기에서도 효율적으로 동작합니다. 작은 패킷 크기와 최소한의 대역폭을 사용하여 효율적인 통신을 제공합니다.
LwM2M은 RESTful 아키텍처를 기반으로 하며, HTTP/CoAP 프로토콜을 사용하여 기기와 서버 간 통신을 지원합니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://haservi.github.io/posts/"},{"@type":"ListItem","position":2,"name":"와이어 샤크를 이용해 DTLS1.2 handshake 확인하기","item":"https://haservi.github.io/posts/tips/wireshark-dtls-handshake/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"와이어 샤크를 이용해 DTLS1.2 handshake 확인하기","name":"와이어 샤크를 이용해 DTLS1.2 handshake 확인하기","description":"프로젝트 중 LwM2M과 Anjay의 통신이 간헐적으로 끊기는 현상이 발생하여 이와 관련하여 프로토콜의 개념에 대해 알아보고, 와이어샤크를 이용해 DTLS handshake를 확인한 내용입니다.\nLwM2M에 대해 LwM2M (Lightweight M2M)은 경량화된 기기 간 통신 프로토콜로서, IoT (Internet of Things) 기기와 서버 간의 효율적인 통신을 위해 설계되었습니다.\nLwM2M은 경량화된 프로토콜로, 리소스 제약이 있는 IoT 기기에서도 효율적으로 동작합니다. 작은 패킷 크기와 최소한의 대역폭을 사용하여 효율적인 통신을 제공합니다.\nLwM2M은 RESTful 아키텍처를 기반으로 하며, HTTP/CoAP 프로토콜을 사용하여 기기와 서버 간 통신을 지원합니다.","keywords":["",""],"articleBody":"프로젝트 중 LwM2M과 Anjay의 통신이 간헐적으로 끊기는 현상이 발생하여 이와 관련하여 프로토콜의 개념에 대해 알아보고, 와이어샤크를 이용해 DTLS handshake를 확인한 내용입니다.\nLwM2M에 대해 LwM2M (Lightweight M2M)은 경량화된 기기 간 통신 프로토콜로서, IoT (Internet of Things) 기기와 서버 간의 효율적인 통신을 위해 설계되었습니다.\nLwM2M은 경량화된 프로토콜로, 리소스 제약이 있는 IoT 기기에서도 효율적으로 동작합니다. 작은 패킷 크기와 최소한의 대역폭을 사용하여 효율적인 통신을 제공합니다.\nLwM2M은 RESTful 아키텍처를 기반으로 하며, HTTP/CoAP 프로토콜을 사용하여 기기와 서버 간 통신을 지원합니다.\nAnjay에 대해 Anjay는 LwM2M 프로토콜을 구현한 오픈 소스 라이브러리로, C 언어로 작성되었습니다. 주로 임베디드 시스템 및 경량 IoT 장치에서 사용됩니다.\nAnjay는 임베디드 디바이스에서 CoAP(Constrained Application Protocol)을 구현하기 위한 오픈 소스 라이브러리입니다. CoAP는 저전력 비동기 통신 프로토콜 입니다. UDP를 기반으로 비동기 통신을 사용합니다. Anjay는 mbedTLS를 사용하여 보안 기능을 제공합니다.\nmbedTLS를 사용하여 보안 기능을 통합하는 것은 Anjay의 디바이스 측 보안 기능을 강화하는 데 도움이 되며, DTLS (Datagram Transport Layer Security)를 통한 CoAP 통신을 안전하게 구현하는 데 적합합니다.\nmbedTLS 란 mbedTLS는 오픈 소스의 암호 라이브러리로, TLS(Transport Layer Security) 및 SSL(Secure Sockets Layer) 프로토콜을 구현하는 데 사용됩니다.\nTLS 및 SSL은 네트워크 통신을 보안하고 데이터를 암호화하는 데 사용되는 프로토콜로, 주로 웹 서버 및 클라이언트 간의 안전한 통신을 제공하는 데 사용됩니다.\nmbed TLS는 C 언어로 작성된 라이브러리로, 경량이며 임베디드 시스템 및 리소스 제한된 환경에서도 사용할 수 있도록 설계되었습니다. 이 라이브러리를 사용하면 암호화, 디지털 서명, 인증 및 안전한 통신을 구현하는 데 도움을 줍니다.\nmbed TLS안에는 DTLS 1.2 기능이 포함돼 있습니다.\nRFC 9146의 문서에서는 DTLS 1.2에 연결 식별자를 추가하는 방법에 대한 표준이 정의돼 있습니다.\n연결 식별자를 CID라고 하며, 아래와 같이 연결 식별자의 형식과 사용 방법에 대한 예제가 나옵니다.\n예제는 아래와 같습니다.\n구현 과정 중 문제점 문제는 RFC 9146의 예제 문서대로라면 위와 같이 돼야 하는데 와이어 샤크로 확인했을 때는 위의 예제처럼 동작하지 않았습니다.\n공식 문서와 스택오버플로우, 구글링을 통해 확인해보니 결론적으로 LwM2M과 Anjay의 통신 설정을 문서를 참조하여 올바르게 설정 해야합니다.\n이렇게 Server(LwM2M)와 Client(Anjay)가 정상적으로 통신하면 아래와 같이 위의 예제 문서와 동일하게 출력한 걸 확인할 수 있습니다.\n위와 같이 Client에서는 ClientHello의 신호를 Server에 보내고 Server에서는 HelloVerifyRequest로 Client에 요청합니다.\nClient는 위 값을 받고 다시 Server에게 ConnectionID를 요청합니다. Server는 내부적으로 ConnectionId(c89be44b77a2)를 만들어서 Client에게 전달합니다.\n그렇게 ConnectionId(c89be44b77a2)를 받은 Client는 해당 값을 다시 Server에게 ConnectionId(c89be44b77a2)를 확인 받은 뒤에 해당 ConnectionId를 이용하여 통신을 합니다.\n위의 handshake 절차를 통해 정상적으로 연결을 유지할 수 있습니다.\n아래는 와이어 샤크로 통신한 내용의 세부 내용입니다.\nClinet(ClientHello) Server(HelloVerifyRequest) Client(ClientHello - CID 요청) Server(ServerHello - CID 제공) Client(Server에 해당 CID 재확인 요청) Server(인증 완료) Client(CID를 이용해 통신) 와이어 샤크를 실제로 자주 사용한 적은 없지만 네트워크 패킷을 분석하여 여러 상황에서 유용하게 쓸 수 있는 도구라고 생각됩니다.\n참고 DTLS 1.2 RFC 9146 문서 ","wordCount":"412","inLanguage":"ko","datePublished":"2023-11-11T19:26:03+09:00","dateModified":"2023-11-11T19:26:03+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://haservi.github.io/posts/tips/wireshark-dtls-handshake/"},"publisher":{"@type":"Organization","name":"Halog","logo":{"@type":"ImageObject","url":"https://haservi.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://haservi.github.io/ accesskey=h title="Halog (Alt + H)">Halog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://haservi.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://haservi.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://haservi.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://haservi.github.io/>홈</a>&nbsp;»&nbsp;<a href=https://haservi.github.io/posts/>Posts</a></div><h1 class=post-title>와이어 샤크를 이용해 DTLS1.2 handshake 확인하기</h1><div class=post-meta><span title='2023-11-11 19:26:03 +0900 +0900'>11월 11, 2023</span>&nbsp;·&nbsp;2 분</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#lwm2m%ec%97%90-%eb%8c%80%ed%95%b4 aria-label="LwM2M에 대해">LwM2M에 대해</a></li><li><a href=#anjay%ec%97%90-%eb%8c%80%ed%95%b4 aria-label="Anjay에 대해">Anjay에 대해</a></li><li><a href=#mbedtls-%eb%9e%80 aria-label="mbedTLS 란">mbedTLS 란</a></li><li><a href=#%ea%b5%ac%ed%98%84-%ea%b3%bc%ec%a0%95-%ec%a4%91-%eb%ac%b8%ec%a0%9c%ec%a0%90 aria-label="구현 과정 중 문제점">구현 과정 중 문제점</a></li><li><a href=#%ec%b0%b8%ea%b3%a0 aria-label=참고>참고</a></li></ul></div></details></div><div class=post-content><p>프로젝트 중 LwM2M과 Anjay의 통신이 간헐적으로 끊기는 현상이 발생하여 이와 관련하여 프로토콜의 개념에 대해 알아보고, 와이어샤크를 이용해 DTLS handshake를 확인한 내용입니다.</p><h2 id=lwm2m에-대해>LwM2M에 대해<a hidden class=anchor aria-hidden=true href=#lwm2m에-대해>#</a></h2><p>LwM2M (Lightweight M2M)은 경량화된 기기 간 통신 프로토콜로서, IoT (Internet of Things) 기기와 서버 간의 효율적인 통신을 위해 설계되었습니다.</p><p>LwM2M은 경량화된 프로토콜로, 리소스 제약이 있는 IoT 기기에서도 효율적으로 동작합니다. 작은 패킷 크기와 최소한의 대역폭을 사용하여 효율적인 통신을 제공합니다.</p><p>LwM2M은 RESTful 아키텍처를 기반으로 하며, HTTP/CoAP 프로토콜을 사용하여 기기와 서버 간 통신을 지원합니다.</p><h2 id=anjay에-대해>Anjay에 대해<a hidden class=anchor aria-hidden=true href=#anjay에-대해>#</a></h2><p>Anjay는 LwM2M 프로토콜을 구현한 오픈 소스 라이브러리로, C 언어로 작성되었습니다. 주로 임베디드 시스템 및 경량 IoT 장치에서 사용됩니다.</p><p>Anjay는 임베디드 디바이스에서 CoAP(Constrained Application Protocol)을 구현하기 위한 오픈 소스 라이브러리입니다. CoAP는 저전력 비동기 통신 프로토콜 입니다. UDP를 기반으로 비동기 통신을 사용합니다. Anjay는 mbedTLS를 사용하여 보안 기능을 제공합니다.</p><p>mbedTLS를 사용하여 보안 기능을 통합하는 것은 Anjay의 디바이스 측 보안 기능을 강화하는 데 도움이 되며, DTLS (Datagram Transport Layer Security)를 통한 CoAP 통신을 안전하게 구현하는 데 적합합니다.</p><h2 id=mbedtls-란>mbedTLS 란<a hidden class=anchor aria-hidden=true href=#mbedtls-란>#</a></h2><p>mbedTLS는 오픈 소스의 암호 라이브러리로, TLS(Transport Layer Security) 및 SSL(Secure Sockets Layer) 프로토콜을 구현하는 데 사용됩니다.</p><p>TLS 및 SSL은 네트워크 통신을 보안하고 데이터를 암호화하는 데 사용되는 프로토콜로, 주로 웹 서버 및 클라이언트 간의 안전한 통신을 제공하는 데 사용됩니다.</p><p>mbed TLS는 C 언어로 작성된 라이브러리로, 경량이며 임베디드 시스템 및 리소스 제한된 환경에서도 사용할 수 있도록 설계되었습니다. 이 라이브러리를 사용하면 암호화, 디지털 서명, 인증 및 안전한 통신을 구현하는 데 도움을 줍니다.</p><p>mbed TLS안에는 DTLS 1.2 기능이 <a href=https://github.com/Mbed-TLS/mbedtls/pull/6264>포함</a>돼 있습니다.</p><p>RFC 9146의 <a href=https://datatracker.ietf.org/doc/rfc9146/>문서</a>에서는 DTLS 1.2에 연결 식별자를 추가하는 방법에 대한 표준이 정의돼 있습니다.</p><p>연결 식별자를 CID라고 하며, 아래와 같이 연결 식별자의 형식과 사용 방법에 대한 예제가 나옵니다.<br>예제는 아래와 같습니다.</p><p><img loading=lazy src=./images/image01.png#center alt=image></p><h2 id=구현-과정-중-문제점>구현 과정 중 문제점<a hidden class=anchor aria-hidden=true href=#구현-과정-중-문제점>#</a></h2><p>문제는 RFC 9146의 예제 문서대로라면 위와 같이 돼야 하는데 와이어 샤크로 확인했을 때는 위의 예제처럼 동작하지 않았습니다.</p><p>공식 문서와 스택오버플로우, 구글링을 통해 확인해보니 결론적으로 LwM2M과 Anjay의 통신 설정을 문서를 참조하여 올바르게 설정 해야합니다.</p><p>이렇게 Server(LwM2M)와 Client(Anjay)가 정상적으로 통신하면 아래와 같이 위의 예제 문서와 동일하게 출력한 걸 확인할 수 있습니다.</p><p><img loading=lazy src=./images/image02.png#center alt=image></p><p>위와 같이 Client에서는 <code>ClientHello</code>의 신호를 Server에 보내고 Server에서는 <code>HelloVerifyRequest</code>로 Client에 요청합니다.</p><p>Client는 위 값을 받고 다시 Server에게 ConnectionID를 요청합니다. Server는 내부적으로 ConnectionId(c89be44b77a2)를 만들어서 Client에게 전달합니다.</p><p>그렇게 ConnectionId(c89be44b77a2)를 받은 Client는 해당 값을 다시 Server에게 ConnectionId(c89be44b77a2)를 확인 받은 뒤에 해당 ConnectionId를 이용하여 통신을 합니다.</p><p>위의 handshake 절차를 통해 정상적으로 연결을 유지할 수 있습니다.</p><p>아래는 와이어 샤크로 통신한 내용의 세부 내용입니다.</p><p>Clinet(ClientHello)
<img loading=lazy src=./images/image10.png#center alt=image></p><p>Server(HelloVerifyRequest)
<img loading=lazy src=./images/image11.png#center alt=image></p><p>Client(ClientHello - CID 요청)
<img loading=lazy src=./images/image12.png#center alt=image></p><p>Server(ServerHello - CID 제공)
<img loading=lazy src=./images/image13.png#center alt=image></p><p>Client(Server에 해당 CID 재확인 요청)
<img loading=lazy src=./images/image14.png#center alt=image></p><p>Server(인증 완료)
<img loading=lazy src=./images/image15.png#center alt=image></p><p>Client(CID를 이용해 통신)
<img loading=lazy src=./images/image16.png#center alt=image></p><p>와이어 샤크를 실제로 자주 사용한 적은 없지만 네트워크 패킷을 분석하여 여러 상황에서 유용하게 쓸 수 있는 도구라고 생각됩니다.</p><h2 id=참고>참고<a hidden class=anchor aria-hidden=true href=#참고>#</a></h2><ul><li><a href=https://datatracker.ietf.org/doc/rfc9146/>DTLS 1.2 RFC 9146 문서</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer><section class=comments><script>loadComment();function loadComment(){document.body.className.includes("dark")?theme="photon-dark":theme="boxy-light";let e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","haservi/haservi.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",theme),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.comments").innerHTML="",document.querySelector("section.comments").appendChild(e)}</script></section></article></main><footer class=footer><span>&copy; 2023 <a href=https://haservi.github.io/>Halog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>const images=Array.from(document.querySelectorAll(".post-content img"));images.forEach(e=>{mediumZoom(e,{margin:0,background:"#1d1e20",scrollOffset:40,container:null,template:null})})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark")),loadComment()})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>